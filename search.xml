<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于博客迁移的几点教训]]></title>
    <url>%2Flife%2Fblog%2F</url>
    <content type="text"><![CDATA[一直以来都有记笔记的习惯, 记录生活点滴、技术感想. 从最初的博客园, 简书, 知乎, 再到个人博客站点, 一路走来, 颇有感触. 个人博客迁移痛点 历史遗留博客无备份. 历史博客没有备份, 一直是个痛点, 工作忙是个借口, 但主要原因在于个人主观臆断, 想当然地认为只要谷歌, 百度还在, 找篇博文应该不是什么难事. 博客分散. 国内各大主流博客网站, 基本扒过, 留下过”拙文”, 有些印象颇深, 有些至今无感. 在国内各大主流博客网站上同步自己的”拙文”, 也是一项”技术活”, 不巧遇上很”不幸的”事儿(如某篇冷门博文被人转载, 个人转发反被骂), 想想也是心累. 从个人博文, 到公共资产、大众共享, 跨度其实还是挺大的, 难免有心理落差. 缺乏系统梳理. 记得刚开始在博客园写博客时, “Too Young, Too Navie”, 难免产生从众心理, 看到比自己写得好的博文, 疯狂转发、”点赞”. 然后对于自己要写的博文果断弃笔, 跑到其它站点考虑下一话题. 由于历史遗留博客缺乏系统梳理, 至今不得不面临”历史博客”迁移困难的尴尬局面. 博客建站历程2016年开始系统博客建站, 建站至今, 经历过VPS停用(忘记续费), 博客站点”长草”, “荒芜”, 到现在重新梳理. 历程参考如下: 2016 - 2018, 经好友推荐, 站点托管于Linode. 博客比较随意, 主要用于科学上网. 2018 - 2019, 站点迁移至Vultr, 没别的, 主要在于想试下其它的VPS供应商, 毕竟试用无法准确评估VPS实际服务质量. (好吧, 其实是Linode忘了续费). 该阶段博客站点开始”长草”, “荒芜”. 2019 - 至今, 开始重新整理博客, 站点迁移 Digital Ocean -&gt; Liquid Web . 个人比较推荐Vultr和Liquid Web, 两者对新用户均有优惠, 比如新用户注册Vultr可获取100美金新人礼. Vultr比较稳定, 个人VPS使用期间, 从未出现过宕机情况. 域名购买推荐Namesilo, 他家域名比较公道, 也比较实惠. 推荐一款个人使用过的CDN, 速度很快, 免备案. 尽管有自己的站点, 但比较致命的是由于没有及时查看邮件通知, Linode忘记续费, 数据毫无备份, 之前写的博客, 全是泪. 别问我本地数据备份, 换了电脑, 更新系统, 有种”大海捞针”的既视感. 与时俱进, 紧跟迭代进行博客迁移时, 有时不得不面临着技术迭代层面的考量. 新技术层出不穷、迭代速度”日新月异”. 历史遗留博客中, 当时看起来可能比较”新颖”的技术, 现在已俨然过时. 举个简单例子, 以下是一段可以正常运行的代码12345678910111213141516171819202122232425import scala.actors._import Actor._val caller = selfval accumulator = actor &#123; var continue = true var sum = 0 loopWhile(continue) &#123; reactWithin(500) &#123; case number: Int =&gt; sum += number case TIMEOUT =&gt; continue = false caller ! sum &#125; &#125;&#125;accumulator ! 1accumulator ! 15receiveWithin(1000) &#123; case result =&gt; println(s"Total is $result")&#125; 如果你使用的Scala版本在2.11及以下, 上面这段代码可以正常运行, 没什么问题. 但如果你安装的是Scala 2.12, 这段代码无法正常通过编译, 原因在于Scala 2.12标准库中正式移除了scala-actors包, 而2.11及以下版本并无影响, Scala 2.12版本需要增加Akka Actor依赖才能正常使用Actor. 关于Scala 2.12.X 正式移除scala-actors包, 个人看法有两点: 一是EPFL为了减轻维护工作量, Scala Actor后期维护工作自然落在了Lightbend Akka团队; 二是马丁老爷子(马丁·奥德斯基, Scala之”父”)试图尽量统一Scala中Actor生态、减少分化, 毕竟除了Akka Actor、还有Scalaz Actor、Lift Actor等. 个人看法, 仅供参考. 实际上, 上面这段代码还存在一个问题, 闭包使用太频繁, 如使用actor闭包方法隐式实例化Actor, Akka官方推荐使用OOP(面向对象)方式显示实例化Actor. 上面这段代码, 在早些年很常见, 特别是当你开始使用Scala 2.9 进行Hacking时. 以上仅是一个小例子, 实际上个人历史遗留博客中有很大一部分博文, 由于技术迭代频繁之故, 已经不能看了, 比如曾经写过的Akka学习笔记, 使用了好多过时的API. 再比如当年Apache Mahout分布式机器学习笔记, 现在要迁移依然存在困难, 主要原因有以下两点: Apache Mahout PMC于2014年决定使用Scala作为Mahout内核源码主要开发语言(之前是Java), 并全面拥抱Apache Spark和Flink作为Mahout后端计算引擎 Apache Mahout自身一些API迭代原因 以上这几点, 意味着之前花了很多时间梳理的Mahout与Hadoop计算引擎MapReduce关系的源码解读笔记, 现在看来几乎没有什么意义, 完全没有迁移必要 (再者笔记中很多Mahout Java源码有些过时). 由于以上几点原因, 个人历史遗留博客, 能迁移的占少数, 特别是2015年以前的博文, 几乎”全军覆没”. 忙完工作, 以后有时间再整理、迁移能看的部分吧. 活在当下, 欢迎交流 !]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务内部进程通信之gRPC篇]]></title>
    <url>%2Fmicrosrvc%2Fgrpc%2F</url>
    <content type="text"><![CDATA[微服务内部进程通信方式, 常用的有以下几种, 限于篇幅, 本文仅讨论gRPC. REST gRPC Events (或基于异步事件消息) gRPC概述gRPC是一个开源框架, 最初是由谷歌开发, 通过网络进行通用远程过程调用. gRPC与HTTP 2语义对齐, 且允许全双工流式传输. 支持不同的传输格式,如Protobuf(默认),JSON,XML,Thrift等,Protobuf在性能方面远高于其他格式. gRPC是一个分层架构,具有以下几层： Stub层: Stub层位于最顶层, Stub层从IDL(接口定义语言)定义的文件生成, 通常IDL文件包含具有服务、方法和消息的接口. 默认使用如Protobuf,但也可以使用其他IDL,如messagepack. 客户端通过Stub层调用服务端. Channel(通道)层: 通道层是一个中间层, 提供Stub层使用的应用程序二进制接口(ABI). Transport(传输)层: 最底层,使用HTTP 2协议, gRPC在同一网络中提供全双工通信及多路并行调用. gRPC特征gRPC结合了REST和RPC(远程过程调用)优点, 非常适合在分布式网络中进行API通信, 其特征如下： 低延迟, 可拓展, 为分布式系统而生 分层设计, 可轻松集成到应用层, 在流控制方面具有很好的交互性 支持负载平衡和故障转移 通信应用广泛, 从移动应用程序到服务端、从Web应用程序到服务端以及从客户端应用程序到不同节点服务器等 支持取消级联调用 gRPC优点 跨语言、跨平台, 支持多种主流语言, 如C++、Java、Golang、Scala、Kotlin、Swift等 高效, 由于采用HTTP 2和二进制消息进行通信, gRPC非常快, 吞吐量大. 将数据流式传输到客户端的功能很不错, 从移动的角度来看, 客户端只需与服务端保持单一连接, 服务端便可将数据更新推送给客户端 安全, gRPC支持TLS加密、身份验证及请求验证 可拓展, 可以编写自定义插件 可维护性佳, 更新gRPC非常容易, 如谷歌投入了大量工作保证Protobuf v3规范向下兼容v2 开源, 可以查看并修改源码 代码生成, 如使用Protobuf作为IDL文件定义服务接口时, 可进行代码生成, 开发人员只需关注业务逻辑即可 gRPC与REST对比gRPC和REST均使用了HTTP 1.1和HTTP 2规范, gRPC还支持全双工流式通信. 通常, REST可以通过Query、路径参数以及请求主体, 传递有效负载, 这意味请求数据有不同来源, 且对不同来源的数据解析(Query,路径及请求主体)增加了时延, 加剧了复杂性. gRPC在使用静态路径时比REST性能更佳. REST调用错误取决于HTTP状态代码, 而gRPC有对应规范标准, 以适用于API. REST API完全基于HTTP, 有不同的方式实现API. 除了DELETE方法外, REST还允许开发人员使用其它HTTP方法删除资源. HTTP提供了灵活性, 但有严格的验证标准与约定. gRPC可用于处理负载平衡、故障转移及调用取消等, 但REST更加成熟, 运用广泛. REST和gRPC各有优缺点, 对比如下: REST gRPC 基于HTTP 基于HTTP语义及RPC 非CS(服务端/客户端)协议 基于CS协议(服务端/客户端) 使用HTTP术语, 如request 使用RPC语义, 如call gRPC代码实战gRPC实现步骤gRPC主要实现步骤如下： 定义服务接口, 包括各种方法签名(如参数和返回类型设计等) 在服务端实现服务接口, 并允许远程调用 生成服务接口Stub, 并在客户端应用中使用 客户端应用调用Stub, 即调用本地对象, 然后Stub与gRPC服务端进行通信, 将返回值传给gRPC客户端, 如下图所示(gRPC跨语言, 图中仅以Java和C++为例): 在此期间, 客户端应用只需进行本地对象(Stub)调用并获取回复, 服务端可位于不同节点. 这使得编写分布式服务变得简单, gRPC也是微服务进行内部进程通信的理想方式之一. gRPC跨语言,意味着可以使用不同语言编写服务端服务与客户端应用, 开发灵活. 进行gRPC服务设计时, 代码实现步骤, 参考如下： 使用IDL(接口定义语言)文件(若使用Protobuf, 则为.proto文件)定义服务接口 实现步骤1中定义的服务接口 创建gRPC Server并注册服务 创建gRPC Client及Stub gRPC编码实战本文将以Golang和Protobuf为例, 实现一个简单的gRPC通信应用. 首先编写IDL文件, 定义具体服务接口, 本例定义一个简单的ZBonjour服务, 当服务端收到客户端Request请求时, 回复Response消息.123456789101112131415syntax = "proto3";package xavier.grpc;message Request &#123; string name = 1;&#125;message Response &#123; string msg = 1;&#125;service ZBonjour &#123; rpc Hello(Request) returns (Response) &#123;&#125;&#125; 可以使用ptotoc工具对Protobuf进行代码生成, 参考指令如下:1protoc -I ./proto ./proto/zbonjour.proto --go_out=plugins=grpc:./proto 生成的Golang代码, 示意如下, 完整代码请参考这里 服务端核心代码: 123456789101112131415161718192021// 对应Protobuf代码生成的ZBonjourServer接口type zBonjourServer struct&#123;&#125;// 服务端 Handlerfunc (k *zBonjourServer) Hello(ctx context.Context, request *proto.Request) (*proto.Response, error) &#123; response := &amp;proto.Response&#123;&#125; response.Msg = fmt.Sprintf("Request received from %v", request.Name) fmt.Println(response.Msg) return response, nil&#125;lis, err := net.Listen("tcp", fmt.Sprintf(":%d", 9000))if err != nil &#123; log.Fatalf("failed to listen: %v", err)&#125;fmt.Println("Receiving Requests.......")// 实例化服务端grpcServer := grpc.NewServer()proto.RegisterZBonjourServer(grpcServer, &amp;zBonjourServer&#123;&#125;)grpcServer.Serve(lis) 客户端核心代码123456789101112131415conn, err := grpc.Dial("127.0.0.1:9000", grpc.WithInsecure())if err != nil &#123; log.Fatal("Unable to create connection to server: ", err)&#125;// 实例化客户端client := proto.NewZBonjourClient(conn)response, err := client.Hello(context.Background(), &amp;proto.Request&#123;Name: "Xavier.IO"&#125;)if err != nil &#123; log.Fatal("Error calling service: ", err)&#125;fmt.Println("Sending a request...")// 客户端连接建立后, 进行具体客户端应用请求, 主要逻辑代码略 效果如下, 详细代码, 请参考这里.]]></content>
      <categories>
        <category>Distributed System</category>
        <category>Microservices</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>Microservices</tag>
        <tag>gRPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漫谈Golang软件架构 (二) -- API构建]]></title>
    <url>%2Fgo%2Fapi-build%2F</url>
    <content type="text"><![CDATA[Golang软件架构漫谈之API设计篇, 本文将对API设计相关问题进行细述. 服务通常很少孤立运作, 一般通过网络交互, 通常使用标准化协议在特定端点进行数据交换, 通信方式有以下两种： 通过API(应用程序编程接口)进行通信, API作为一种请求/响应模型, 通常使用如HTTP等其它网络协议 通过消息传递进行通信, 服务通过交换消息的方式进行数据交换 本文主要侧重API相关设计, 关于消息传递后续博文会详细阐述. 数据序列化常见的数据序列化格式有以下几种: XML JSON Protobuf 不同的序列化格式在对象序列化/反序列化方面具有不同的特性, 对系统整体性能产生重大影响、尤其是在微服务架构中.单个用户请求可能由多个服务处理.这些服务使用序列化(反序列化)对象、通过API或消息传递进行通信. 通常.可从Schema文件(如Protobuf)进行代码生成的序列化格式比通用序列化格式(如JSON)性能更佳.后者需使用反射来确定对象结构(如字段和类型等). 当然, 这些序列化格式(Protobuf等)在调试方面有些不太方便, 如不能通过简单的curl请求读取数据, 需使要反序列化器或解码器进行解码. 路由与端点 进行网络通信时必须定义一组数据交换规则, 这些规则通常通过协议标准化并进行分层—即经典的”五层”(或七层, 在五层基础上将应用层细分为应用层、表示层和会话层)网络协议, 如上图所示 多数API通过TCP协议进行网络通信, 通常在进行数据交换前, 客户端需与服务端建立连接. 建立连接前, 客户端需要知道以下内容: 托管服务的主机IP 服务监听端口 应用层细节, 如应用层特定端点(如HTTP中URL)、数据协议(如数据序列化格式、数据内容)等 服务端服务发现服务部署在集群中, 而客户端通常不会、也不关心哪个特定实例提供服务.在服务端服务发现架构中, 负载均衡器接收请求并将其路由到合适的服务实例, 如下图所示: 通常, 负载均衡器具有一组虚拟IP地址(VIP), 对应每项服务, 存在对应该虚拟IP后端实例的静态列表, 负载均衡器将来自客户端的请求多路复用到后端实例集上, 即使列表是静态的, 依然存在各种机制支持自动化配置更新, 如实例开闭等.经典的负载均衡器, 如Nginx, Nginx高性能、可扩展. Nginx包含一组有限的worker进程(通常一个CPU内核对应一woker进程), 通过使用非阻塞、事件驱动IO(如epoll和kqueue)路由请求, Nginx Woker进程体系架构如下: 后端实例的NGINX配置是静态的, 但可以使用辅助组件(如Consul Template)进行动态配置, 通常这些解决方案会对新生实例或死亡实例进行事件监视, 重写NGINX配置文件或正常重启NGINX进程. 进行服务连接时, 客户端请求的URL通过域名服务(DNS)转换为服务端虚拟IP, 然后客户端使用该虚拟IP及端口初始化连接. 负载均衡器通常还具有健康检测特性, 以便找出健康状况良好的后端实例集, 未定期Check-in的实例被判断为unhealthy, 并从后端实例集中移除. 服务端服务发现, 优点如下: 客户端不需要了解服务实例 高可用、容错 缺点在于: 负载均衡器存在单点故障, 需准备备用服务器 客户端无法选择特定服务实例 客户端服务发现客户端服务发现, 客户端检测可用服务实例对应端点, 然后路由请求, 客户端查询服务注册表, 然后将请求路由最佳服务实例, 可以使用Round-Robin算法.每个服务实例在启动时连接到服务注册表, 通过定期使用注册表更新其健康状况, 该架构参考如下 Netflix Eureka可用于服务注册与发现, Netflix Ribbon是一个用Java编写的IPC客户端, 可与Eureka一起结合使用进行负载均衡, 非Java程序可以使用REST API与Eureka进行交互. Golang可以通过fargo包, 向Eureka进行服务注册, 通过心跳信息进行实例健康状况检查. 连接到Eureka并获取应用实例列表, 代码参考如下: 123c = fargo.NewConn("http://127.0.0.1:8080/eureka/v2")// 返回一个 map[String]fargo.Applicationc.GetApps() Consul也可用于服务发现, 通过Service Catalog方式组织服务, 并在此基础上提供DNS和HTTP API接口, Consul监视已注册的服务实例并管理一系列状况良好的服务集, 具体请参考Consul官方文档. REST服务使用Golang标准库自带的net/http包可以很方便地构建Web服务, 如下:123456789101112131415161718192021222324252627package mainimport ( "fmt" "log" "net/http" ) func main() &#123; // 设置 Router http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) &#123; log.Println("path", r.URL.Path) fmt.Fprintf(w, "pong! on %sn", r.URL.Path) &#125;) // 监听服务. 其中`ListenAndServe()` 方法: // 1. 实例化 Http Server // 2. 调用 `net.Listen(tcp, addr)` 方法监听指定端口(本例9090端口) // 3. 开启循环并接收循环主体中请求 // 4. 为每一个请求开启一个Go协程 // 5. 读取请求数据 // 6. 搜寻URL句柄(Handler)并执行代码 err:= http.ListenAndServe(":9090", nil) if err != nil &#123; log.Fatal("ListenAndServe: ", err) &#125; &#125; Go Web应用中, 通常每一个请求对应后端一个独立Go协程, 提高了资源利用率及拓展性, 如下图所示: Golang构建REST服务, 相对简单, 如下图所示: GraphQLREST API使用简单、应用广泛, 但对于快节奏的Web开发而言,繁杂、不灵活的Endpoint和Schema可能会严重降低开发效率; 此外,REST效率较低, 特别是只需获取部分服务数据时. 如开发一个酒店搜索相关的移动应用程序, 并不希望页面展示酒店所有属性, 因为手机屏幕可能没办法显示所有数据(比如有些设备屏幕小, 后端返回的很多字段数据对这些设备而言根本就用不上，纯粹是浪费网络带宽); 此外进行REST API设计时, 需要一系列URL和所有酒店的Schema. 但如果是平板电脑则希望显示更多详细信息以适应屏幕, 可以通过使用其它辅助资源或使用一些查询参数来判定屏幕规格, 但这样的话客户端需求和服务端代码将耦合在一起. 为避免这种问题, 可以考虑使用GraphQL. GraphQL由Facebook推出, 定义了API开发的新模式. GraphQL官方提供了对Golang支持, 使用参考如下 12345678910111213141516171819202122232425262728293031323334353637// 本例以酒旅业务为例, 编写一简单的GraphQL接口type Hotel struct &#123; Id string `json:"id"` DisplayName string `json:"displayName"` City string `json:"city"` NoRooms int `json:"noRooms"` StarRating int `json:"starRating"` &#125;// 为结构体`Hotel`定义GraphQL对象类型var hotelType = graphql.NewObject(graphql.ObjectConfig&#123; Name: "Hotel", Fields: graphql.Fields&#123; "id": &amp;graphql.Field&#123; Type: graphql.String, &#125;, "displayName": &amp;graphql.Field&#123; Type: graphql.String, &#125;, "city": &amp;graphql.Field&#123; Type: graphql.String, &#125;, "noRooms": &amp;graphql.Field&#123; Type: graphql.Int, &#125;, "starRating": &amp;graphql.Field&#123; Type: graphql.Int, &#125;, &#125;, &#125;)// 定义Schemavar schema, schemaErr = graphql.NewSchema(graphql.SchemaConfig&#123; Query: rootQuery, Mutation: rootMutation, &#125;) Endpoint使用REST API时,每个资源均有一特定端点, 这些端点拥有多个方法(或谓词), 以特定方式获取(或提供)数据. 而GraphQL恰恰相反, 通常GraphQL中只有一个端点, 数据结构不固定,整个协议完全由客户端驱动, 如获取据时, 客户端需明确指定所需数据.12345678910111213141516171819http.HandleFunc("/graphql", func(w http.ResponseWriter, r *http.Request) &#123; fmt.Println("[in handler]", r.URL.Query()) result:= executeQuery(r.URL.Query()["query"][0], schema) json.NewEncoder(w).Encode(result) &#125;) fmt.Println("Graphql server is running on port 8080") http.ListenAndServe(":8080", nil)func executeQuery(query string, schema graphql.Schema) *graphql.Result &#123; result:= graphql.Do(graphql.Params&#123; Schema: schema, RequestString: query, &#125;) if len(result.Errors) &gt; 0 &#123; fmt.Printf("wrong result, unexpected errors: %v", result.Errors) &#125; return result &#125; Queries回到Golang代码, rootQuery处理所有查询, 可以通过graphql.NewObject()函数创建 123456789101112131415161718192021222324// 实际生产环境, 使用数据库存储、获取数据, 而非基于内存的Mapvar hotels map[string]Hotel// 基于酒店ID获取数据var rootQuery = graphql.NewObject(graphql.ObjectConfig&#123; Name: "RootQuery", Fields: graphql.Fields&#123; "hotel": &amp;graphql.Field&#123; Type: hotelType, Description: "Get a hotel with this id", Args: graphql.FieldConfigArgument&#123; "id": &amp;graphql.ArgumentConfig&#123; Type: graphql.String, &#125;, &#125;, Resolve: (funcparams graphql.ResolveParams) (interface&#123;&#125;, error) &#123; id, _:= params.Args["id"].(string) return hotels[id], nil &#125;, &#125;, &#125;, &#125;) 使用CURL请求给定ID的酒店相关数据, 如名称、城市、空房数、评分等 1curl -g 'http://localhost:8080/graphql?query=&#123;hotel(id:"XVlBzgba")&#123;displayName,city,noRooms,starRating&#125;&#125;' 或使用GraphQL DSL获取所有酒店ID: 12345&#123; allHotels &#123; id &#125; &#125; 服务端返回 12345678&#123; "allHotels": [ &#123; "id": "xyz" &#125;, &#123; "id": "abc" &#125;, &#123; "id": "pqr" &#125;, ... ] &#125; Mutations除了检索数据,API还需支持数据修改, 通常有以下几种数据变更： 新增数据 更新数据 删除数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var rootMutation = graphql.NewObject(graphql.ObjectConfig&#123; Name: "RootMutation", Fields: graphql.Fields&#123; "createHotel": &amp;graphql.Field&#123; Type: hotelType, Description: "Create new hotel", Args: graphql.FieldConfigArgument&#123; "displayName": &amp;graphql.ArgumentConfig&#123; Type: graphql.NewNonNull(graphql.String), &#125;, "city": &amp;graphql.ArgumentConfig&#123; Type: graphql.NewNonNull(graphql.String), &#125;, "noRooms": &amp;graphql.ArgumentConfig&#123; Type: graphql.NewNonNull(graphql.Int), &#125;, "starRating": &amp;graphql.ArgumentConfig&#123; Type: graphql.NewNonNull(graphql.Int), &#125;, &#125;, Resolve: func(params graphql.ResolveParams) (interface&#123;&#125;, error) &#123; displayName, _:= params.Args["displayName"].(string) city, _:= params.Args["city"].(string) noRooms, _:= params.Args["noRooms"].(int) starRating, _:= params.Args["starRating"].(int) newHotel:= Hotel&#123; Id: randomId(), DisplayName: displayName, City: city, NoRooms: noRooms, StarRating: starRating, &#125; hotels[newHotel.Id] = newHotel return newHotel, nil &#125;, &#125;, &#125;, &#125;)var letterRunes = []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ") // 随机生成IDfunc randomId() string &#123; b:= make([]rune, 8) for i:= range b &#123; b[i] = letterRunes[rand.Intn(len(letterRunes))] &#125; return string(b) &#125; 使用CURL创建新增酒店数据: 1curl -g 'http://localhost:8080/graphql?query=mutation+_&#123;createHotel(displayName:"HotelX",city:"NY",noRooms:300,starRating:5)&#123;id&#125;&#125;' Subscriptions通过订阅,客户端可获取不同事件的更新,客户端与服务端建立持久化连接,服务端数据流入客户端. 如客户端要获取新增酒店名称和ID数据,可以发送以下订阅： 123456subscription &#123; newHotel &#123; name id &#125; &#125; 此后,客户端与服务端建立连接, 每次进行数据变更如新增酒店,服务端将数据流式传输至已订阅的客户端： 123456&#123; "newHotel": &#123; "name": "NewHotel", "id": rndid16 &#125; &#125; 高级API设计模式 MVC API 网关 负载均衡、健康监测.服务部署集群中通常存在在冗余实例(如可靠性及拓展性考虑), 对于客户端而言, 最好能够访问运行状况良好实例以避免服务不可用.通常,该模式对每个服务实例进行深层健康状况检查（即检查所有子系统)并告知负载均衡器或服务注册表有关实例运行状况, 负载均衡器或服务注册表拥有一个代理,该代理调用每个服务后端实例并在给定时间内接收回复,可以通过异步健康监测方式, 以便获取更好的性能.]]></content>
      <categories>
        <category>Distributed System</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>Software Architecture</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漫谈Golang软件架构 (一) -- 分布式系统]]></title>
    <url>%2Fgo%2Fdistros%2F</url>
    <content type="text"><![CDATA[分布式系统, 从设计、开发调试到部署上线、后期维护, 每个过程并非易事. 分布式系统复杂, 具有挑战性, 比单机系统更容易出错. Java之父—James Gosling曾提出八个有关分布式计算的谬论: 网络可靠 延迟为零 带宽无限 网络安全 拓扑不变 传输代价为零 网络同构 管理人员”无所不能” 对于这些谬论, 暂且一笑了之, 但在20年前, 真的很难预测, 特别是分布式计算. 今天我们依然面临这些限制: 网络不可靠,不安全,带宽有限,网络的拓扑结构将发生变化,其组件的配置方式不同. 意识到这些限制将有助于我们设计更好的分布式系统. 分布式系统架构分层架构 如图, 分层架构中的每一层聚合了下一层的相关职责和抽象. 严格类型分层系统中, 每层组件只能和同一层组件或下一层组价交互. 分布式系统中存在多个节点, 这种分层架构也可以称为N阶架构, 如典型的Web应用包含以下几层: 展现层, UI相关特性 HTTP服务层, 处理HTTP/HTTPS请求、HTTP持久化连接、SSL/TLS加密、逆向缓存、负载均衡等 业务逻辑层, 基于具体业务规则进行处理, 代码部署至Web容器或Web相关框架中 数据层, 与数据库进行交互, 代码复用, 初期数据层可与业务逻辑层放在一起. 尽量保持客户端代码简单, 以便获得最大复用灵活性以及拓展性(通常服务端代码比客户端代码更容易变更和部署). 当然, 有时客户端代码封装了好几层, 以便进行如延迟优化等. 基于对象系统最简单的分布式系统由对象构成, 对象间彼此通过远程过程调用(RPC)或远程方法调用(RMI)进行交互. 每个节点一般包括以下三层 代理/框架层, 存在客户端代理以及服务器主框架, 客户端代理转发请求给实际服务器对象及远程引用层 远程引用层, 负责执行调用语义, 具体通信委托给传输层 传输层, 负责连接管理及远程对象追踪 基于对象系统, 通常有以下两类生态 CORBA(通用对象请求代理体系结构, Common Object Request Broker Architecture), 由对象管理组织(OMG)定义, Java中RPC框架常用此技术 DCOM(分布式组件对象模型, Distributed Component Object Model), 由微软赞助 在Go语言中, Go标准库有rpc包允许开发人员通过远程过程调用导出任意对象方法1234567891011// 简单实现一个乘法服务type Args struct &#123; A, B int&#125;type MultiplyService struct &#123;&#125;func (t *Arith) Do(args *Args, reply *int) error &#123; *reply = args.A * args.B return nil&#125; 上面代码中的服务可以通过rpc包在远程过程调用中使用123456789101112func main() &#123; service := new(MuliplyService) rpc.Register(MuliplyService) rpc.HandleHTTP() l, err := net.Listen("tcp", ":1234") if err != nil &#123; log.Fatal("listen error:", err) &#125; go http.Serve(l, nil)&#125; 客户端代码12345678910client, err:= rpc.DialHTTP("tcp", serverAddress + ":1234")if err != nil &#123; log.Fatal("dialing: ", err)&#125;args := &amp;server.Args&#123;10, 12&#125;var reply intclient.Call("Multiply.Do", args, &amp;reply)fmt.Printf("%d*%d=%d", args.A, args.B, reply) 基于对象系统架构, 近几年不再流行, 主要有以下几点原因 试图为远程对象进行封装并伪造本地引用, 实际上远程行为和本地未必相同, 此类架构并没有更好的处理方式 调用双方在进行通信时必须正常运行, 不太符合实际情况, 如应用构建时未必 部分架构, 如CORBA变得原来越复杂 P2P架构所有对等节点分担部分负载或共享资源, P2P架构中, 所有节点既可以充当客户端, 也可以充当服务端. 分布式哈希表, 也是一种P2P结构, 一种结构化的P2P. 分布式哈希表可以跨节点, 可以通过一致性哈希(Consistent Hashing)算法构建分布式哈希表. 一致性哈希算法主要思想是通过使用同一哈希函数对Keys和托管缓存的Server进行哈希, 这样做的理由是将缓存映射为哈希值, 如果移除缓存, 只需移除对应哈希值即可, 其他缓存无需变更. P2P网络中, 有时也可变得具有等级, 如Superpeer. 这些Superpeers负责内部集群通信, 也可以与其他Superpeer进行交互, 这种类型的架构有CDN(内容分发网络), 每一个Edge服务器充当一个peer. 分布式计算 Map-Reduce并行处理框架, 在大数据生态组件中很常见, 如Hadoop 分布式内存计算模型, 如大数据生态组件Spark, RDD(分布式弹性数据集) + 内存计算, 快速而高效地进行数据处理 MPP, 多并行处理, 如Impala 流式处理 微批处理模型, 如Apache Spark/Storm、Samza等流式处理框架, 适合无状态计算 State Transformation, 框架本身拥有一种状态维护机制, 如Apache Flink/Apex, 适合有状态计算. 事件驱动架构通常, 单体应用可通过微服务进行分解, 每项微服务为避免耦合可以拥有自己的数据库, 这也使得分布式事务成为可能, 但也存在不足之处: 与使用单个数据库事务相比, 拟合时间长, 容易出错 所有微服务不一定使用关系型数据库, 有的微服务可能根据具体业务需求使用NoSQL数据库, 如MongoDB等 遇到这种情况可以考虑Event-Driven. 事件驱动(Event-Driven), 通过事件响应对行为进行分解, 进行事件驱动建模时, 一个事件Event通常意味着重要的状态变更, 比如购物付款后订单状态由未支付变为已经支付等. 事件驱动架构设计, 常用的设计模式有 Event Sourcing, 事件溯源, 通过追加日志形式, 实现事务或分布式事务 CQRS, 指令查询责任分离, 指令更新和查询进行分离, 查询部分并不负责更新写入, 反之亦然, 实现最终一致性(Eventual Consistency) Event Stream, 适用于源源不断无边界的事件建模, 流式处理常用模式之一 Actor模型可以通过使用Actor进行异步非阻塞计算, 适用于消息驱动建模. 每个Actor拥有自己的邮箱, 通过交换消息进行通信, 每个Actor拥有内部状态可以影响消息回复. Actor语义和管道-协程语义区别如下: 每个Actor通过邮箱进行唯一性区分, 进行消息处理时由特定Actor进行处理, 管道是通用型, 意味着多个协程可以监听同一管道. 管道基于内存, Actor通过邮箱可以跨主机多节点进行通信. Actor模型基于Actor原语, 管道-协程基于CSP(顺序化通信进程) 容错方面, Actor存在灵活的Supervise监督机制和Let it crash思想(意味着当一个Actor crash时, Supervisor会推选出另一Actor继续进行未完成的任务),而管道-协程需要开发人员手动添加容错处理逻辑. Actor模型遵循分治原则, 将任务进行切分直到每个任务足够小, 能被部分顺序化代码处理. Actor进行消息交换时, 生产者和消费者不需要同时存活, 处理速率可以不对等. 分布式系统中共识算法分布式系统中为保持数据一致性, 对于数据更新达成共识, 常见的实现形式有 Leader选举, 集群节点中推选一个节点作为Leader负责协同、交互等. 分布式锁管理, 多节点间处理互斥访问. 分布式事务, 多节点间通过分布式事务保持数据一致性. 在设计分布式共识算法时, 需要注意以下几点 真实性, 推选出来的值必须在提议值内 生命周期, 共识进程应该在一定时间内中止 共识, 所有参与节点认可提议值 Leader选举 在多个集群节点中推选出Leader, 通常有以下两种常见策略 基于ID选举, 每项实例ID唯一, 不管什么时候发生选举, 实例与ID最小或最大节点进行ID交换. 基于环拓扑实例的Leader选举算法, 复杂度在O(n^2)到O(nlogn)之间, 取决于具体算法实现. 互斥竞争, 实例间共享互斥锁进行争用, 获取锁的实例推选为Leader. 通常为防止Leader故障进行重新选举, 在Leader和其他实例间存在一种保活机制. 选举中一般会用到选举计数器, 进行消息交换时, 选举计数器封装在负载中, 以避免在同一选举中同一节点同时投票给俩不同节点推选为Leader. 多阶段提交提议进程发送提议值给每项参与进程, 每项进程要么接受提议要么回绝提议, 提议进程根据收到所有参与进程的回复, 判定是否达成一致. 分布式提交主要有两种类型: 两阶段提交 三阶段提交 两阶段提交假定提议进程P0, 以及其他参与进程P1…PN(或执行进程)需要更新值, 在两阶段提交中, P0与其他进程进行协同, 以便达成一致, 主要阶段如下: 准备阶段, P0发送消息”Prepare update v = x”给其他执行进程[P1…PN], 每项执行进程可以投票”Prepared”或”No”, 如果存在其他并发事务执行进程可以投票”No”, 或存在局部Stage已经改变可以投票”Prepared” 提交阶段, 收到所有进程的回复后, P0要么发送提交消息”commit”要么发送取消消息, 每项执行进程根据回复完成事务. 为了便于处理类似于重启之类的状况, 每个进程记录自身当前状态并在发送消息前持久化, 如所有执行进程回复消息”Prepared”, P0可以记录处于提交阶段. 两阶段提交容易在提交阶段产生错误: P0可能在准备阶段奔溃. 此时其它所有执行进程阻塞, 直到P0上线, 系统由于共识产生中断. P0也可以判断崩溃节点是否重新上线或中止事务. 如果其中一个执行进程在提交阶段奔溃, P0并不能判断该进程是在提交前还是在提交后产生故障. 小结: 两阶段提交最大的缺点在于阻塞, 如果在重要阶段其中一个进程死亡, 可能会导致”中断不止”. 三阶段提交非阻塞的提交协议在于单进程故障是否影响其他进程判定事务是否提交还是中止, 为了实现这种目的, 可将提交阶段分成俩部分 预提交阶段, 在接收到执行进程的”Prepared”消息后, P0进入预提交阶段. P0发送”precommit”消息给所有的执行进程, 在此阶段并不进行实际提交. 提交阶段, 如果P0在预提交阶段接收到所有执行进程的回复消息”Yes”, 便发送提交消息”commit”至所有的执行进程, 然后完成事务. 如果任一执行进程在预提交阶段回复”No”或没有回复,事务中止. 三阶段提交算法本质上还是两阶段提交, 不过在提交阶段多个了预提交而已. 目前, 绝大多数大数据分布式框架如Flink采用含有预提交的两阶段算法保证恰好一次及时消费语义性. 预提交阶段有助于算法从节点故障中恢复, 每项进程可能会产生超时, 假如执行进程未接收来自P0回复, 可推选出新的Coordinator继续完成事务. 新的Coordinator通过对执行进程进行Query检测当前的事务状态. 另一方面, 如果有一执行进程回复新的Coordinator没有接收到”precommit”消息, 新的Coordinator判定P0是在提交阶段前发生故障, 因为其他执行进程没有任何变更, 可以安全地中断此次事务.含有预提交的两阶段算法, 也存在一定不足, 如容易受网络环境影响. Paxos共识算法Paxos协议灵活, 比两阶段提交算法具有更好的容错性. Paxos算法实现中节点有以下三种角色 提议者(Proposer), 该节点驱动共识处理 接收者(Acceptor), 这些节点可以独立接受或回绝提议 学习者(Learner), 并不直接影响共识构建进程, 基于接收者的接收值进行学习, 通常学习者和接收者打包于同一组件中. Paxos基本步骤和两阶段提交有些类似, Paxos中提议者发送俩种类型消息给接收者—Prepare以及Accept. 在Prepare准备阶段, 除了发送提议值还发送提议序列数, 提议数为单调调增的正数, 具有唯一性. 提议数由两部分组成: 节点标识及对应节点计数器, 当接受者收到有冲突的提议时, 选择提议数最大的提议. Accepter须记住已经接收的最大提议数以及回复其他请求的最大提议数. Paxos主要步骤如下 阶段一: Prepare, 构造提议消息,消息包含提议值v及提议数N(比进程之前使用过的任何数字大), 发送给大多数接收者 Promise, 当一接收者收到Prepare消息后, 检测提议数是否比之前接收过的提议数大, 是的话记录提议值并更新提议数N, 不是的话忽略该消息(尽管没有必要回复, 但回复NACK可以加速算法拟合). 若接收者接受提议, 须发送包含之前提议数及提议值消息回复Proposer提议者. 整个过程中, 一个接收者可以接收多条提议. 阶段二: 接收请求, 一旦提议者接收到绝大多数节点消息时, 算法进入Acceptance(接收)阶段. 基本上提议者希望接收者进行提交, 存在以下几种情况: 如果绝大多数接收者回复NACK消息或回复失败, 提议者放弃提议回到初始状态或初始阶段 如果没有一个接受者接收提议, 提议者可能选择初始值v以及提议数N 如果任一接收者接收过提议, 提议值和提议序列数对提议者可用, 假如此时接受的提议值v、最大提议序列数w, Paxos协议迫使提议者更新提议数为w, 以防止之前死亡过的提议者重新上线分化整个共识进程. 提议者发送包含选定值的消息Accept给所有接收者, 接收, 当接受者接收Accept消息后, 检测以下几种情况: 消息值是否是之前接收提议中值 消息中序列数是否是所有接受者认可的最大提议数 如果上面两个条件都满足, 接收者发送Accept消息给提议者, 否则发送Reject消息 为使多个提议者进行提议时拟合更快, 一般通过Leader选举与Paxos协议结合使用保证多节点间达成共识. 实际上, Zookeeper协同服务主要由Paxos协议和Leader选举实现. Raft共识算法Raft和Paxos共识算法类似, 与Paxos相比具有更少的状态, 算法也比Paxos简单. 任意给定时间, 每项Raft允许的实例状态有: Leader、Follower或Candidate. 刚开始,每项实例作为Follower, 在此期间, 实例很消极仅回复消息, 如基于Log结构消息从Leader处复制状态或回复Candidate的选举消息. 如果一定时间内没有接收消息, 该实例可推选自身为Candidate, 开始进行选举并有可能被推选为Leader. 处于Candidate状态的实例, 向其它对等实例请求投票, 收到绝大多数投票的实例被推选为Leader. 推选为Leader的实例, 主要职责有: 处理写入请求, 如客户端的状态变更请求 处理读取请求, 如不允许读取老数据(Stale read, 或陈旧数据) 复制状态给所有的Follower Raft算法中, 处理写入请求过程一般产生追加日志, Leader将追加日志持久化, 然后对Follower复制进行初始化. 日志在Raft协议中很重要, 共识问题基本转化成了日志副本问题. 如果所有实例具有相同日志项且日志项具有相同顺序, 可以认为系统处于一致性状态. 当大多数节点实例成功复制可视为写入提交, 对于N个实例集群而言, 绝大多数意味着至少(N/2+1)个节点. 写入提交机制, 可能会阻塞客户端写入, 直到已经提交. 一旦日志项提交, 可在实例上运行有限状态机. 有限状态机上可托管特定应用代码, 如处理状态变更, 当然应用代码须具有确定性, 因为所有节点以相同顺序运行相同的数据, 输出也应该相同. 分布式系统中一致性问题 ACID, 关系型数据库中ACID(Atomicity原子性, Consistency一致性, Isolation隔离性, Durability持续性)特性, 缺点在于拓展性不佳 CAP理论, 分布式系统CAP理论, 不能同时取得一致性、可用性和分区容错性 BASE原理, Basically Available(基本可用)、Soft state(软状态) 及 Eventual Consistency(最终一致性) 三个短语缩略. 其核心思想是即使无法做到强一致性(Strong Consistency,CAP的一致性就是强一致性), 但应用可以采用适合的方式达到最终一致性(Eventual Consitency).]]></content>
      <categories>
        <category>Distributed System</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>Software Architecture</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyTorch JIT浅酌]]></title>
    <url>%2Ftorch%2Fjit%2F</url>
    <content type="text"><![CDATA[对于采用Python进行开发的PyTorch应用代码而言, 运用JIT技术, 不仅可以避免Python GIL(全局解释锁)带来的性能瓶颈, 而且有助于加速PyTorch代码进行模型迭代与训练. 当PyTorch于GPU上执行一系列操作时, 底层GPU内核从GPU内存读取输入, 计算结果并存储, 其中大部分时间开销并不在计算上, 而在内存读写上. 为了提升性能, 可以考虑减少读取次数(如仅读取一次), 计算多次并最终写入结果. 运用PyTorch JIT技术, 可以达到这样的效果. 下面以LSTM(长短期记忆, Long Short Term Memory)算法为例, 进行简要说明. 运用PyTorch JIT技术, 可以均衡LSTM算法的运行速率与泛化能力. 图中该LSTM算法的具体细节并不重要, 图中有五项输入, 两项输出, 七项中间结果, 通过运用PyTorch JIT技术, GPU内存读可从12项减少为7项, 写从9项较少为2项, 训练时间减少1/4. 后端与接口PyTorch后端调用示意图, 参考如下: 通常, PyTorch中torch.nn模块使用的接口可传入或返回Tensor, 这些接口通常由C++实现, 执行实际计算的内部库也称ATen(ATen提交计算至GPU后端, 如CuDNN, NNPACK等). 如图所示, PyTorch应用代码, 不管是使用Python实现, 还是C++实现, 基本上”殊途同归”, 均转化为调用底层LibTorch模块或JIT模块. PyTorch JIT提供了一种”软链”计算, 该种”软链”计算实际上为TorchScript中间层代码. PyTorch JIT模块中函数可用于装载, 审视或执行TorchScript模块. (C++代码或Python代码均可访问PyTorch JIT模块) 脚本创建TorchScript有以下两种最直接的方式: 追溯 (Tracing) 脚本化 (Scripting) 当使用Tracing时, 通过样本输入(或随机输入)执行PyTorch模型, PyTorch JIT拥有每个函数对应的钩子(Hook), 用于记录计算. 只有当调用PyTorch中函数时, 才会触发Tracing, 缺点在于没有控制流. 使用Scripting时, PyTorch JIT将Python应用代码编译成TorchScript中间层代码, 缺点在于受限于JIT编译器. 下面, 来看个小例子 123456789101112# 对矩阵中每项列向量中值进行累加(不同列向量不累加), 结果为一行向量def col_sum(x): y = x[0] for i in range(1, x.size(0)): y = y + x[i] return yrdn = torch.randn(5, 5)# 使用Tracing, 运行下面这段代码, 将抛出警告日志# 大意是将Tensor转换成Python Index将导致Trace不准确trace_func = torch.jit.trace(col_sum, rdn)print(trace_func) 如何解决这个问题, 可以考虑使用Scripting, 代码参考如下: 12script_func = torch.jit.script(col_sum)print(script_func.code) 123# 或者打印Scripting后的Graph# 该Graph更接近TorchScript IRprint(script_func.graph) 当然, 最简单的方式, 可以直接使用torch.jit.script装饰器(Decorator) 123456@torch.jit.scriptdef col_sum(x): y = x[0] for i in range(1, x.size(0)): y = y + x[i] return y 尽管TorchScript看起来有些类似于Python子集, 但存在本质区别. 比如PyTorch为TorchScript代码加上了特定类型, 因为TorchScrip代码本质上为静态类型代码, 每种类型受限于TorchScript IR表示. 在程序内部JIT会自动进行类型推断, 不过在使用TorchScript时, 最好注明任意非Tensor类型参数. 使用TorchScript时, 如需暴露对外调用的方法, 可以在类定义时使用@torch.jit.export装饰器. 可追溯性以下代码中, PyTorch JIT将up.shape元组替换成1d 整型Tensor, diff_x, diff_y此类Tensor操作具有可追溯性, 运行以下代码可能产生Tracer警告. 123456789101112131415161718class MNetUpBlock(nn.Module): # 略去部分实现代码 def center_crop(self, layer, target_size): _, _, layer_height, layer_width = layer.size() diff_y = (layer_height - target_size[0]) // 2 diff_x = (layer_width - target_size[1]) // 2 # Tracer警告, 切片中元素为Python中int类型 # 该方法在下面 `forward()` 方法中被调用时, 抛出警告 return layer[:, :, diff_y:(diff_y + target_size[0]), diff_x:(diff_x + target_size[1])] def forward(self, x, bridge): # JIT将`up.shape`元组替换成1d 整型Tensor # 调用 `center_crop` 方法时, 将抛出警告 crop1 = self.center_crop(bridge, up.shape[2:]) # 其它具体实现逻辑略 解决方式, 代码重构, 参考如下: 12345678910111213141516# 使用TorchScript, 使`MNet`模型更具有可追溯性@torch.jit.scriptdef center_crop(layer, target): _, _, layer_height, layer_width = layer.size() diff_y = (layer_height - target_size[0]) // 2 diff_x = (layer_width - target_size[1]) // 2 return layer[:, :, diff_y:(diff_y + target_size[0]), diff_x:(diff_x + target_size[1])]class MNetUpBlock(nn.Module): # 略去部分实现代码 def forward(self, x, bridge): crop1 = center_crop(bridge, up) # 其它具体实现逻辑略 还有一种解决方式, 将非脚本化逻辑(即非TorchScript部分)转换成C++实现的自定义操作, 比如TorchVision库中MaskRCNN模块就是这么干的.]]></content>
      <categories>
        <category>Deep Learning &amp; Machine Learning</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Deep Learning &amp; Machine Learning</tag>
        <tag>PyTorch</tag>
        <tag>PyTorch JIT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Meta-SGD For Deep Learning (Part Two)]]></title>
    <url>%2Fmeta-dl%2Fsgd-code%2F</url>
    <content type="text"><![CDATA[接着上篇博文, 本篇博文主要以Meta-SGD算法代码实战为主. 本文将以经典机器学习算法中常见的二分类任务为例,运用Meta-SGD算法进行模型训练并对超参数进行优化. 为了简单起见,我们随机生成样本数据并使用单层神经网络进行训练, 以找到最优参$\theta$ . 准备样本数据1234567891011import numpy as npdef data_points_sample(k): """ 生成输入数据点(x, y), 参数k表示要取样的数据点数量 """ arr = [0, 1] p = [.5, .5] x = np.random.rand(k, 50) y = np.random.choice(arr, size=k, p=p).reshape([-1, 1]) return x, y 预测输出本例使用单层神经网络预测输出, 通过Meta-SGD算法找到最优参$\theta$、学习率$\alpha$及梯度更新方向, 并在多个任务中生成. 因此对于新任务而言,要训练的梯度少, 学习的数据点少, 花费时间少, 因而学习更加快速. 算法运用步骤回顾下上篇博文Meta-SGD算法步骤, 具体如下: 1. 给定模型$f$,参数$\theta$,Task分布$p(T)$. 首先随机初始化模型参数$\theta$和$\alpha$, 且保证$\alpha$与$\theta$具有相同的Shape. 2. 对满足分布$T_i \sim p(T)$的Task$T_i$, 对其Batch进行采样, 假定对三个Task进行采样 $T=\{T_1, T_2, T_3\}$ 3. 进行内循环遍历, 对于每项Task(假定$T_i$), 采样K个数据点并准备好训练集和测试集. 在$D_i^{train}$上运用监督型算法, 使用梯度下降计算并得到最优参数$\theta_i^{'}$ (注意$\theta_i^{'}=\theta -\alpha o \nabla_\theta L_{T_i} (f_\theta)$), 对于每项Task, 取样K个数据点并在训练集$D_i^{train}$上训练得到最优参数$\theta_i^{'}$ . 如下, 对三个Task进行采样得到三个最优参数$\{\theta_1^{'},\theta_2^{'},\theta_3^{'}\}$ $D_i^{train}=\{(x_1, y_1), (x_2, y_2),(x_3, y_3)\}$ $D_i^{test}=\{ (x_1, y_1), (x_2, y_2)......(x_k, y_k) \}$ 4. 外循环遍历, 在测试集$D_i^{test}$上进行损失优化, 利用上一步得到的最优参数$\theta_i^{'}$进行计算, 使用测试集更新随机初始化参数$\theta$ 以及$\alpha$, 更新规则如下: $\theta=\theta - \beta\nabla_\theta \sum_{T_i \sim p(T)} L_{T_i}(f_{\theta_i^{'}})$ $\alpha=\alpha-\beta\nabla_\alpha \sum_{T_i \sim p(T)} L_{T_i}(f_{\theta_i^{'}})$ 5. 重复步骤2 和步骤4进行N次迭代 MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], displayMath: [ ['$$','$$'], ["\\[","\\]"] ], processEscapes: true } }); 代码实现首先, 对Meta-SGD算法运用面向对象建模, 封装为一Python类MetaSGD. 进行算法训练时, 我们需要知道训练迭代的epochs数量、每个batch训练的任务数num_tasks、每项Task取样的数据点数量num_samples、外部梯度更新或外循环超参数beta, 注意theta 和alpha在初始化时保持相同的Shape. 单层神经网络激活函数使用sigmoid函数. 12def sigmoid(self, variable): return 1.0 / (1 + np.exp(-variable)) 训练过程中, 对数据点进行采样准备训练集 1x_train, y_train = data_points_sample(self.num_samples) 使用单层神经网络进行预测 12a = np.matmul(x_train, self.theta)y_hat = self.sigmoid(a) 计算损失和梯度 123456loss = ((np.matmul(- y_train.T, np.log(y_hat)) - np.matmul((1 - y_train.T), np.log(1 - y_hat)) ) / self.num_samples )[0][0]gradient = np.matmul(x_train.T, (y_hat - y_train)) / self.num_samples 更新梯度并为每项任务找到优化参数 $\theta^{‘}$ 1self.theta_.append(self.theta - (np.multiply(self.alpha, gradient))) 采样准备好训练集$D_i^{test}$, 进行meta训练时预测y值 12345x_test, y_test = sample_points(10)# 预测a = np.matmul(x_test, self.theta_[i])y_pred = self.sigmoid(a) 计算meta梯度 1meta_gradient += np.matmul(x_test.T, (y_pred- y_test)) / self.num_samples 更新模型参数 $\theta$ 和 $\alpha$ $\theta=\theta - \beta\nabla_\theta \sum_{T_i \sim p(T)} L_{T_i}(f_{\theta_i^{'}})$ $\alpha=\alpha-\beta\nabla_\alpha \sum_{T_i \sim p(T)} L_{T_i}(f_{\theta_i^{'}})$ MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], displayMath: [ ['$$','$$'], ["\\[","\\]"] ], processEscapes: true } }); 最后, 打印损失 详细代码, 请参考这里]]></content>
      <categories>
        <category>Deep Learning &amp; Machine Learning</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Deep Learning &amp; Machine Learning</tag>
        <tag>Meta Machine Learning</tag>
        <tag>Supervised Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyTorch实战Neural Style Transfer]]></title>
    <url>%2Fdl%2Fnst%2F</url>
    <content type="text"><![CDATA[个人在公司内部做的有关Neural Style Transfer的技术分享, 有段时间了, 重新整理下. (本文偏代码实战, 数学理论推导部分较少, 如需深入了解该算法理论, 我再找找理论部分PPT, 或者你也可以自行谷歌或百度) 大家好, 今天要分享的是有关Neural Style Transfer在CV(Computer Vision, 计算机视觉)处理方面的应用, (鄙人精力有限, 还请各位大佬不吝赐教). Neural Style Transfer在CV方面比较实用的技巧在于风格迁移, 比如下图为美丽的晚秋落叶图 然后, 有一张满屏毕加索风格的艺术画 通过Neural Style Transfer, 对晚秋落叶图进行毕加索风格迁移, 可以得到以下一张充满立体主义与印象风格的图片 其中, 晚秋落叶图可称为Content Image, 毕加索风格的艺术画也称Style Image, Neural Style Transfer基本思想在于从Content Image与Style Image中提取各自特征(即内容特征与风格特征), 然后将内容特征与风格特征重新组合成目标图像, 之后不断迭代地重建目标图像, 依据是生成图像与内容和风格图像之间的差异. 下面, 通过一个小例子来看下Neural Style Transfer算法大致迭代过程. 准备数据集首先, 看下Content Image (橘猫图) 12345from PIL import Imagecontent_image_path = './dataset/kt.jpg'content_image = Image.open(content_image_path)content_image.show() 然后, 看下Style Image (经典田园风格山水画) 123style_image_path = './dataset/farm.jpg'style_image = Image.open(style_image_path)style_image.show() 现在要做的是, 通过Neural Style Transfer算法对橘猫图进行风格迁移, 最终生成包含田园风格的抽象水墨图. 代码实战 代码主逻辑参考如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859def main(ctnt_img_path, sty_img_path, output_path): # 为了避免再造"轮子", 可以使用PyTorch已经训练好的VGG-19模型 device, model = vgg_model_init() # 首先, 获取Content Image与 Style Image的Image Tensor content_tensor = img_tensor(ctnt_img_path, device) style_tensor = img_tensor(sty_img_path, device) # 获取Content Image的特征输出 content_features = features_extraction( content_tensor, model, feature_layers) # 获取 Style Image的特征输出 style_features = features_extraction( style_tensor, model, feature_layers) # 基于Content Image抽取的Image Tensor确定输入Tensor input_tensor = content_tensor.clone().requires_grad_(True) # 定义优化器(Optimizer) optimizer = optim.Adam([input_tensor], lr=0.01) # 进行迭代 for epoch in range(num_epochs + 1): optimizer.zero_grad() # 基于Input Tensor获取输入特征 input_features = features_extraction( input_tensor, model, feature_layers) # 计算内容损失 content_loss = check_content_loss( input_features, content_features, content_layer) # 计算风格损失 style_loss = check_style_loss( input_features, style_features, style_layers_dict) # 计算Neural Loss, 即最终损失 c_loss = content_weight * content_loss s_loss = style_weight * style_loss neural_loss = c_loss + s_loss neural_loss.backward(retain_graph=True) optimizer.step() # 打印出内容损失及风格损失 if epoch % 100 == 0: print( 'Epoch &#123;&#125;, Content loss: &#123;:.2&#125;, style loss &#123;:.2&#125;' .format(epoch, content_loss, style_loss)) # 保存生成图片 img_pil = img_tensor_to_pil(input_tensor[0].cpu()) img_pil.save(output_path) 下面给出上述代码中相关方法实现, 完整代码, 请参考这里 提取图片张量其中, 对Conent Image与Style Image进行转换, 得到Image Tensor, 图片转换逻辑参考如下: 123456789101112131415161718def img_tensor(img_path, device, h=H, w=W, mean_rgb=MEAN_RGB, std_rgb=STD_RGB): """ `device`, PyTorch device, 即 Cuda 或 CPU `h`- 高, `w` - 宽, `mean_rgb`, `std_rgb`, 一些RGB设置参数 """ img = Image.open(img_path) transformer = transforms.Compose([ transforms.Resize((h, w)), transforms.ToTensor(), transforms.Normalize(mean_rgb, std_rgb) ]) # 将PIL Image 转换成 Tensor img_tensor = transformer(img) print(img_tensor.shape, img_tensor.requires_grad) img_tensor = img_tensor.unsqueeze(0).to(device) return img_tensor 获取中间层特征获取中间层的特征输出(如抽取Content Image与Style Image特征等), 代码参考如下: 1234567def features_extraction(tensor, model, layers): features = &#123;&#125; for name, layer in enumerate(model.children()): tensor = layer(tensor) if str(name) in layers: features[layers[str(name)]] = tensor return features 计算内容及风格损失 卷积神经网络中浅层卷积往往检测低级特征,深层卷积可以提取更高级的特征, 如果希望G能够与C的内容相似, 可以选择一些层的激活来代表图片表征, 事实上,选择网络的中间层（不是太浅也不要太深）有可能取得令人满意的结果. 假设选择每个特殊隐含层来使用.将C作为输入放入VGG中,并运行前向传播, 设a^{(C)} 为所选中隐含层的激活数, G亦如此,将G作为输入,并进行前向传播,a^{(G)} 为对应隐含层的激活数, 则内容损失函数可以定义为 说简单点, 利用一些新建好的网络的中间层,将其看作图片的编码,内容损失就是编码的差异. 计算内容损失, 代码参考如下: 1234567import torch.nn.functional as Fndef check_content_loss(pred_features, target_features, layer): target = target_features[layer] pred = pred_features[layer] loss = Fn.mse_loss(pred, target) return loss 网络的中间层是H W C,每一个通道其实都是差不多同一种类似的风格,如果两个通道之间的相关性很大,说明图片中要么同时出现或要么同时消失两个通道对应的风格,S(Style)图片和G(generate)图片可以各自计算出一个C * C的矩阵,每个像素是对应通道的相关（对应元素相乘）,然后比较两个矩阵的差异就是风格损失 计算风格损失, 代码参考如下: 123456789101112def check_style_loss(pred_features, target_features, style_layers_dict): loss = 0 for layer in style_layers_dict: pred_ftr = pred_features[layer] pred_gram = get_gram_matrix(pred_ftr) n, c, h, w = pred_ftr.shape target_gram = get_gram_matrix(target_features[layer]) layer_loss = style_layers_dict[layer] \ * Fn.mse_loss(pred_gram, target_gram) loss += layer_loss / (n * c * h * w) return loss 其中计算给定张量的Gram矩阵, 代码参考如下: 12345def get_gram_matrix(tensor): n, c, h, w = tensor.size() tensor = tensor.view(n * c, h * w) gram = torch.mm(tensor, tensor.t()) return gram 保存生成图片12img_pil = img_tensor_to_pil(input_tensor[0].cpu())img_pil.save(output_path) 将Image Tensor重新转换成PIL Image, 代码参考如下: 123456789from torchvision.transforms.functional import to_pil_imagedef img_tensor_to_pil(img_tensor, std_rgb=STD_RGB, mean_rgb=MEAN_RGB): img_tensor_ = img_tensor.clone().detach() img_tensor_ *= torch.tensor(std_rgb).view(3, 1, 1) img_tensor_ += torch.tensor(mean_rgb).view(3, 1, 1) img_tensor_ = img_tensor_.clamp(0, 1) pil_img = to_pil_image(img_tensor_) return pil_img 完整代码 效果检测 绝了, 这生成图比我小侄女画的水彩还抽象 …… 优化建议: 超参数调优, 不断迭代训练; 可能漏了一些参数, 请在生产代码中补上.]]></content>
      <categories>
        <category>Deep Learning &amp; Machine Learning</category>
      </categories>
      <tags>
        <tag>Computer Vision</tag>
        <tag>Python</tag>
        <tag>Deep Learning &amp; Machine Learning</tag>
        <tag>PyTorch</tag>
        <tag>Neural Style Transfer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Meta-SGD For Deep Learning (Part One)]]></title>
    <url>%2Fmeta-dl%2Fsgd-math%2F</url>
    <content type="text"><![CDATA[Meta-SGD算法, Meta Learning算法中的一种, 该算法可以快速找到模型最优参数并在多个Task内生成. 当然,该算法不仅能找到最优参, 还能找到最优学习率及更新方向. 本博文要点如下: 首先, 对Meta-SGD算法进行原理剖析 然后, 细聊Meta-SGD算法在监督型机器学习算法中的运用 最后, 聚焦Meta-SGD算法在强化学习中的运用 Meta-SGD 算法原理梯度下降主要组成部分: 参数 $\theta$ 学习率 $\alpha$ 更新方向 算法原理如下, 给定task $T$, 模型$f$, 一些模型参数$\theta$(Task分布为$p(T)$). 通过梯度下降减少模型损失并找到最优参. 还记得梯度下降的更新规则吗？ $\theta=\theta -\alpha\nabla_\theta L_{T_i} (f_\theta)$ 在训练过程中一般给$\theta$设定随机值, 给定较小的$\alpha$值或使其随时间衰退, 更新方向随着梯度变化而改变, 伴随整个训练过程找到最优参.问题是我们可以通过Meta-Machine Learning的方式学习所有梯度下降的主要元素吗？能不能找到最优的初始化参数$\theta$并在多个Task中生成？假如能找到这个最优的初始化参数, 也就意味着更少的梯度迭代训练, 从而提升算法学习效率, 然后再找到最优学习率和更新方向以便能在多个Task内生成. 这样一来的话, 拟合也更快. 假定对于每项$Task_i$对应的最优参$\theta_i^{'}$, 即 $\theta_i^{'}=\theta -\alpha o \nabla_\theta L_{T_i} (f_\theta)$ 这里, 我们随机初始化$\alpha$并使其和$\theta$具有同样的Shape,初始化$\theta$, 以$\alpha o \nabla_\theta L_{T_i} (f_\theta)$ 作为调整期(adaptation term,或适应期). 此时, $\alpha o \nabla_\theta L_{T_i} (f_\theta)$代表着更新方向且以它的length为学习率. 值得注意的是,更新方向和$\alpha o \nabla_\theta L_{T_i} (f_\theta)$一致, 而非梯度方向, 从而隐式学习$\alpha$学习率. 这也意味着Meta-SGD算法并不以很小的Scalar值对学习率$\alpha$进行初始化, 学习率以随机值进行初始化并保证和$\theta$一样的Shape. 然后对Task中的一些Batch进行取样, 每项Task取样K个数据点并通过梯度下降减小损失. 或者说此时的更新等式如下, 更新方向就是调整期方向, 通过$\theta$学习$\alpha$. $\theta_i^{'}=\theta -\alpha o \nabla_\theta L_{T_i} (f_\theta)$ 根据给定最优参数$\theta_i^{'}$计算梯度损失并更新模型参数$\theta$, 整个过程$\theta$和$\alpha$更新如下: $\theta=\theta - \beta\nabla_\theta \sum_{T_i \sim p(T)} L_{T_i}(f_{\theta_i^{'}})$ $\alpha=\alpha-\beta\nabla_\alpha \sum_{T_i \sim p(T)} L_{T_i}(f_{\theta_i^{'}})$ 小节: Meta-SGD算法在调整期内不仅隐式地学习了模型参数$\theta$, 还学习了学习率$\alpha$和更新方向. MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], displayMath: [ ['$$','$$'], ["\\[","\\]"] ], processEscapes: true } }); Meta-SGD 在监督型机器学习算法中的应用可以将Meta-SGD运用于任意使用梯度下降训练的监督性学习中, 如分类或回归. 具体应用步骤如下: 1. 给定模型$f$,参数$\theta$,Task分布$p(T)$. 首先随机初始化模型参数$\theta$和$\alpha$, 且保证$\alpha$与$\theta$具有相同的Shape. 2. 对满足分布$T_i \sim p(T)$的Task$T_i$, 对其Batch进行采样, 假定对三个Task进行采样 $T=\{T_1, T_2, T_3\}$ 3. 进行内循环遍历, 对于每项Task(假定$T_i$), 采样K个数据点并准备好训练集和测试集. 在$D_i^{train}$上运用监督型算法, 使用梯度下降计算并得到最优参数$\theta_i^{'}$ (注意$\theta_i^{'}=\theta -\alpha o \nabla_\theta L_{T_i} (f_\theta)$), 对于每项Task, 取样K个数据点并在训练集$D_i^{train}$上训练得到最优参数$\theta_i^{'}$ . 如下, 对三个Task进行采样得到三个最优参数$\{\theta_1^{'},\theta_2^{'},\theta_3^{'}\}$ $D_i^{train}=\{(x_1, y_1), (x_2, y_2),(x_3, y_3)\}$ $D_i^{test}=\{ (x_1, y_1), (x_2, y_2)......(x_k, y_k) \}$ 4. 外循环遍历, 在测试集$D_i^{test}$上进行损失优化, 利用上一步得到的最优参数$\theta_i^{'}$进行计算, 使用测试集更新随机初始化参数$\theta$ 以及$\alpha$, 更新规则如下: $\theta=\theta - \beta\nabla_\theta \sum_{T_i \sim p(T)} L_{T_i}(f_{\theta_i^{'}})$ $\alpha=\alpha-\beta\nabla_\alpha \sum_{T_i \sim p(T)} L_{T_i}(f_{\theta_i^{'}})$ 5. 重复步骤2 和步骤4进行N次迭代 MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], displayMath: [ ['$$','$$'], ["\\[","\\]"] ], processEscapes: true } }); Meta-SGD 在强化学习中的应用Meta-SGD算法和任意使用梯度下降进行训练的强化学习算法兼容, 应用步骤和上面类似 1. 给定模型$f$,参数$\theta$,Task分布$p(T)$. 首先随机初始化模型参数$\theta$和$\alpha$, 并保证$\alpha$与$\theta$具有相同的Shape. 2. 对满足分布$T_i \sim p(T)$的Task$T_i$, 对其Batch进行采样, 假定对三个Task进行采样 $T=\{T_1, T_2, T_3\}$ 3. 进行内循环遍历, 对于每项Task(假定$T_i$), 在数据集$D_i^{train}$上进行轨迹采样, 通过使用梯度下降计算并得到最优参数$\theta_i^{'}$ (注意$\theta_i^{'}=\theta -\alpha o \nabla_\theta L_{T_i} (f_\theta)$), 如对三个Task进行采样得到三个最优参数$\{\theta_1^{'},\theta_2^{'},\theta_3^{'}\}$, 然后对另一个轨迹数据集$D_i^{test}$进行采样, 以便进行meta更新. 4. 外循环遍历, 在$D_i^{test}$上进行损失优化, 利用上一步得到的最优参数$\theta_i^{'}$进行计算, 并更新随机初始化参数$\theta$ 以及$\alpha$, 更新规则如下: $\theta=\theta - \beta\nabla_\theta \sum_{T_i \sim p(T)} L_{T_i}(f_{\theta_i^{'}})$ $\alpha=\alpha-\beta\nabla_\alpha \sum_{T_i \sim p(T)} L_{T_i}(f_{\theta_i^{'}})$ 5. 重复步骤2 和步骤4进行N次迭代 MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], displayMath: [ ['$$','$$'], ["\\[","\\]"] ], processEscapes: true } }); 本篇博文主要以数学和算法理论为主, 下篇博文将带你实战Meta-SGD算法编码.]]></content>
      <categories>
        <category>Deep Learning &amp; Machine Learning</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Deep Learning &amp; Machine Learning</tag>
        <tag>Meta Machine Learning</tag>
        <tag>Supervised Learning</tag>
        <tag>Reinforcement Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swarm Intelligence(集群智能)牛刀小试]]></title>
    <url>%2Fdl%2Fpsi%2F</url>
    <content type="text"><![CDATA[集群智能(Swarm Intelligence, 简称SI), 作为AI中很重要的一部分, 表示自然或人工中去中心化、自组织系统产生的集体智能行为. 在运用集群智能实现一个简单的游戏AI前, 先了解下集群智能相关概念原理. 集群智能一般包括群体中单个Agent或Boid(AI程序)间进行本地交互或与环境交互, 从而产生集体智能行为. 集群智能基本特点 去中心化, 因而具有较强鲁棒性,即不会由于某一个或几个个体出现故障而影响集群对整个问题的求解. 自组织, 通过群体中不同个体间进行本地交互或与环境交互产生智能 可扩充, 由于集群智能可以通过非直接通信的方进行信息的传输与合作,因而随着个体数目的增加,通信开销的增幅较小,拓展性好. 简单性, 集群中每个个体的能力或遵循的行为规则非常简单,因而集群智能的实现比较方便. 集群智能主要原则 稳定性原则(Stability Principle), 集群不应在每次环境变化时都改变自身的行为 多样性反应原则(Principle of Diverse Response), 集群的行动范围不应该太窄 适应性原则(Adaptability Principle), 集群能够在适当的时候改变自身的行为 邻近原则(Proximity Principle), 集群能够进行简单的空间和时间计算 品质原则(Quality Principle), 集群能够响应环境中的品质因子 集群智能应用 集群智能应用主要包括以下几个方面: 蚁群路由(Ant-Based Routing, 或直译为基蚂路由), 可用于处理类似电信通讯问题, 其核心思想还是基于强化学习, 网络本身涉及到很多特定网络包的转发和后馈, 这些网络包也可以称为蚂蚁, 从而导致整个网络洪化. 群体模拟(Crowd Simulations), 在电影产业中可以借助集群智能优化算法进行群体模拟. 人工群体(Human Swarming), 基于集群智能预测答案, 集结民智解决复杂问题. 集群文法(Swarm Grammars), 通过群体中不同个体得到不同结果, 应用如艺术或建筑等. 群体艺术(Swarmic Art), 群体不同个体行为、模式产生”百花齐放”、”百家争鸣”的艺术. 集群优化算法目前,集群智能主要有两种算法模式,分别是蚁群算法(Ant Colony System, 简称ACS)和粒子群优化算法(Particle Swarm Optimization, 简称PSO). 本文暂时不对这俩种算法展开详细阐述, 仅对优化算法中的Rastrigin函数进行说明. 在数学优化问题中, Rastrigin函数作为非凸函数, 在优化算法中常用于性能测试, 其公式如下: $ f(x) = A_n + \sum_{i=1}^n [x_i^2 -Acos(2 \pi x_i)]$ 假定$A=10$ 且$x_i \in [-5.12, 5.12]$, 当$f(x)=0$时在$x=0$拥有全局最小值. MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], displayMath: [ ['$$','$$'], ["\\[","\\]"] ], processEscapes: true } }); 集群智能牛刀小试利用PySwarms包可以在Python中很方便地实现集群智能算法, 不用再造轮子. PySwarms也可以更加高效地实现集群智能优化算法, 如粒子群优化算法(PSO), 特别是在以下方面很给力: 星拓扑 环拓扑 安装Pyswarms安装PySwarms很简单, 直接键入以下指令即可 1pip install pyswarms 下面, 我们可以检测下PySwarms是否安装成功, 如图, 检测代码运行无误说明PySwarms包安装成功. 牛刀小试 详细代码, 请参考如下:]]></content>
      <categories>
        <category>Deep Learning &amp; Machine Learning</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Swarm Intelligence</tag>
        <tag>Deep Learning &amp; Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Frameworks of Microservices In Java]]></title>
    <url>%2Fmicrosrvc%2Fnetflix-whole-sale-packages%2F</url>
    <content type="text"><![CDATA[微服务架构开发相关软件框架有很多, 为了避免重复造”轮子”, 本文将对微服务架构中常用到的软件框架进行小结. 服务注册和发现Eureka, 不仅可以用于服务注册和发现, 还可用于中间层的负载均衡. 服务通信Ribbon, 支持HTTP、TCP和UDP协议, 支持异步通信和响应式模型. Ribbon还具有缓存和批(Batch)特性, Ribbon可与Eureka结合使用进行负载均衡, 与Hystrix结合使用进行容错或熔断器操作. 熔断器Hystrix, 常用于容错和熔断器操作, 可防止错误拓展扩散, 实时监控服务和property变化, 支持并发. 代理服务器Zuul, 作为代理服务器或Edge服务器, 为外部应用提供服务, 如UI客户端、Android/iOS应用或其它第三方服务等. Zuul允许动态路由并监控请求, 支持验证. 构建Nebula, 如果你使用Gradle进行打包编译, Netflix Nebula插件是个不错的选择, Nebula插件允许你快速高效地对微服务进行编译打包, 该插件还可以减少很多Gradle模板代码. 分布式配置管理Archaius, 分布式配置管理工具, 通过Archaius, 你可以: 进行线程安全的配置操作 使用轮询框架检测Property变更 使用动态或静态类型Property 在有序的层级配置中使用回调 使用JConsole对Property进行审查或操作 在分布式环境中配置不同的Property 调度器如果你使用Mesos容器进行微服务部署, 可使用Fenzo作为调度器 部署交付Spinnaker/Aminator, 如果你使用AWS EC2, Animator可以构建AMI镜像, Spinnaker部署AMI镜像至AWS 可用性监控如果你的微服务部署至云端, 如AWS等, 可以考虑使用Simaian Army作为可用性监控工具, Simaian Army使用以下服务进行监控: Chaos Monkey, 该服务区分一组系统并随机中止组内一个系统, 一般运行在可控时间范围内, 如运行在工作时间以便工程师接到警报并响应. Janitor Monkey, 该服务找到没有用的资源并及时清理, 通过一些列给定规则进行资源清理. Conformity Monkey, 该服务调度可配置, 找到没有遵循预定义规则的实例, 发出通知给实例所有者. Security Monkey, 监控账号政策变更或不安全配置, 主要用于安全监控. 运维监控Atlas, 提供近实时监控信息, 可记录多维时序数据, 可拓展, 内存存储因而可以快速呈现大量Metrics报表. 远程主机监控Vector, 可在安装了PCP(Performance Co-Pilot)远程主机上进行性能监控, 便于对性能问题进行排查或更好地理解系统运行. AWS资源监控Edda, 可监控AWS资源动态变化, Edda通过使用AWS API对AWS资源进行轮询并记录结果, Edda主要特征如下: 动态查询, Edda提供了 Rest API, 支持矩阵参数及字段选择器进行数据筛选 历史变更, Edda维护AWS所有资源记录历史, 有助于进行问题排查. 多配制, 支持从多地区多账号轮询信息并行数据汇总, 支持不同的配置项如AWS、Crawler、Elector以及MongoDB等. Why Netflix全家桶?可能你已经发现了, 貌似上面大多数软件框架都是Netflix的. So, Why Netflix全家桶? Well, Netflix虽然是一家以在线流视频为主营业务的科技公司, 但是该公司在响应式编程(Reactive Programming),JVM性能优化方面一直走在前面, 比如大名鼎鼎的RxJava, 最早由Netflix推出并开源, 然后影响了大批JVM攻城狮, 并在Akka几位创始人的推动下组织Reactive Manifesto并发布宣言, Reactive Manifesto宣言无论对于后端开发还是分布式系统开发, 均具有深远影响. The part above should be the end of this post. God, D**N it, sometimes I hate myself. Since this post was on Netflix’s Microservices whole-sale packages, I got my story to be told. The interpreting language of this post usually goes with Chinese (Since this is the offical language of the Dynasty of Heaven (“大天朝”官方语言)), check it below.个人接触Nexflix “全家桶”纯属意外, 曾经比较关注Akka, 然后从Akka CTO Roland Kuhn博士(德国人, 现在自己开公司, 于是便成了Akka前CTO)那里接触到Reactive/Reactive Manifesto, 接着RxJava, 最后Netflix进入眼帘, 自然地, Netflix微服务 “全家桶”必不可少. Since this little story went behind Akka, there’re something you need to know about Akka (Trust me, you should not be biased enough especially if you’re in China). Like, Akka provides多并行、并发原语支持, 如共享内存Agent(类似于Clojure中Agent), 并行数据结构如CRDT(请不要认为Akka只有Actor, Future/Promise)分布式设计模式, 如Event Sourcing/Event Stream/CQRS/Saga 分布式建模设计, 如DDD(领域驱动设计, Domain Driven Design)/DDDD(分布式领域驱动设计, Distributed Domain Driven Design)流式处理, High Watermark(高压水印)、Backpressure并非Apache Flink的”独创”、Flink也并非这方面处理的”集大成者”系统集成, 类似于OSGI/Apache Karaf系统集成模块分布式组件二次开发, 大数据热门组件如Flink(依赖Akka Cluster进行内部通信)、Spark(源码使用Akka Actor进行了很多封装处理, 如使用Akka进行RPC调用等)至今仍给人以震撼. If you used to be a user of Akka, you should be familiar with these patterns: Circuit Breaker, Saga, Event Sourcing, CQRS (These patterns are common in Microservices), even with DDD(Domain Driven Design).The whole text should be in Chinese(the offical language of the Dynasty of Heaven (“大天朝”官方语言)), but this language requires EXTREME SIMPLICITY、POINT-STRIKEN . So, all my points were clear in this language. And this’s it, thank you for reading.]]></content>
      <categories>
        <category>Distributed System</category>
        <category>Microservices</category>
      </categories>
      <tags>
        <tag>Microservices</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang大法玩转人脸识别]]></title>
    <url>%2Fgo%2Fface-detection%2F</url>
    <content type="text"><![CDATA[本文要点如下: 首先, 简单介绍下人脸识别相关概念 然后以Golang为例, 对人脸识别相关算法进行编码实战. 常见的人脸识别或人脸检测算法, 经典的有以下几种, 本文将以Golang为例, 教你如何玩转人脸识别 以深度学习神经网络为主的CV算法, 如CNN(卷积神经网络) Viola-Jones算法(VJ算法) PICO 算法 在玩转人脸识别算法前, 首先简单了解下人脸检测的一些基本概念. 人脸检测为了检测面部或识别人脸, 首先要了解人脸是什么, 典型的人脸有两只眼睛,一只鼻子和一张嘴. 但拥有这些特性并不足以定义人脸, 狗也有两只眼睛,一只鼻子和一张嘴. 仔细思考下什么是人脸, 我们本能地知道一张脸是什么, 但真正量化一张脸的构成确实有难度. 我们经常在影视上看到侦探利用数据库中数据进行人脸识别, 通常你会看到用点和线绘制的面孔. 这些点和线主要归功于20世纪60年代Woodrow Bledsoe、Helen Chan和Charles Bisson的成果, 他们是第一批研究自动化人脸检测的人. 人脸的标准特征—面部发际线、眉毛、眼睛、鼻梁、嘴巴等都是动态可定义的, 即这些特征是相对可测量的, 但这使得自动化人脸检测更具挑战性. 他们的解决方案很新颖: 使用设备(这些设备相类似于现在的平板电脑绘图)注释眼睛、鼻子、嘴巴和其他脸部特征位置, 然后将这些注释之间距离作为脸部识别的特征, 除了更加自动化外, 与现在的做法没有什么特别大的区别, Bledsoe、Chan和Bisson在量化像素以及如何构造人脸特征方面付出了很多努力. 人脸检测的难点人脸检测复杂而具有挑战性, 其主要的难点有两方面: 人脸内在变化导致： 人脸具有相当复杂的细节变化,不同外貌如脸形、肤色等,不同表情如眼、嘴的开与闭等 人脸的遮挡,如眼镜、头发和头部饰物以及其他外部物体遮挡等； 外在条件变化所引起： 由于成像角度的不同造成人脸多样性,如平面内旋转、深度旋转以及上下旋转,其中深度旋转影响较大 光照的影响,如图像中的亮度、对比度的变化和阴影等. 图像的成像条件,如摄像设备的焦距、成像距离,图像获得的途径等. VJ人脸检测算法21世纪初, Viola和Jones提出了一种非常快速的物体检测方法, Viola-Jones算法比较通用, 可以检测任何物体, 但主要用于人脸检测. Viola-Jones算法核心在于使用了许多小分类器,以分阶段方式对图像区域进行分类, 这些分类器也称级联分类器. 级联分类器由许多小分类器组成, 每个分类器由多个过滤器组成, 为检测面部, 首先从图像的一小部分(或者可称为窗口)开始, 逐个运行分类器. 如果分类器中所有过滤器的结果总和超过分类器预定义阈值, 则认为它是面部的一部分. 然后, 级联分类器移动到下一个分类器进行迭代, 迭代完所有分类器后, 窗口滑动到下一个像素, 然后重新开始该过程. 如果级联分类器中部分分类器不能对某些区域进行人脸识别, 则抛弃对应区域并滑动窗口. 过滤器通过检测人脸的亮区和暗区进行脸部识别, 如眼睛周围区域通常是凹陷的, 是暗区, 如果对该区域使用过滤器, 只会突显眼睛. 用于眼睛的分类器具有多个过滤器, 鼻子的分类器具有针对于鼻子的多个过滤器. 在级联分类器中, 可以自定义优先度, 如可以将眼睛定义为人脸最重要部分(眼睛是灵魂的重要窗户), 级联分类器首先对眼睛区域进行分类, 如果检测到眼睛, 便接着再寻找鼻子、嘴巴等, 否则滑动窗口. Viola-Jones算法另外一个优势在于可以处理图像金字塔(Image Pyramid). So, What’s the image Pyramid? 假如你有一张图片, 1024x768像素, 图片上有两个不同尺度的人脸—有人离镜头近距, 有人远离镜头,你可能会意识到远离镜头的人脸较小, 问题在于如何检测这俩不同尺度的人脸? 可以设计多个过滤器, 如果多次调整图像大小, 则可以重复使用相同的过滤器, 而非增加过滤器, 用于检测小脸的过滤器不会检测到大脸. 基于分辨率,分类器将检测较小的人脸, 然后调整图像大小以使分辨率变低, 如640 x 480, 使大脸很小, 小脸变单点. 总的来说, 分类器会检测到图像中所有人脸, 因为可以直接调整图像大小, 所以即便是较小图像中的坐标也可以轻易转换成原始图像中的坐标, 便于”小脸”检测直接转换为原始比例的人脸检测. 与卷积神经网络(CNN)有些类似, 在CNN算法中, 可将多个过滤器应用于子区域, 从而产生滤镜图像, 然后将过滤图像传给reduction layer(通过max pooling或其他方法). CNN算法优点在于学习过滤器, 实际上每个CNN第一层学习的过滤器与Viola-Jones方法中使用的过滤器非常相似. Viola-Jones算法与CNN, 对比如下: 主要的相似之处在于Viola-Jones基本上使用滑动窗口且对图像部分运用过滤器, 这与CNN中的卷积相当. CNN优势在于能够学习过滤器, 而Viola-Jones方法中需手动创建过滤器. Viola-Jones算法具有级联分类器的好处: 如果其中一个分类器失败, 可以提前终止搜索对应区域, 以便节省计算资源. 受Viola-Jones算法影响, 有人开始使用多任务级联卷积网络进行联合脸部检测, 如使用三个神经网络以层叠方式识别人脸, 具体可以参考商汤科技张展鹏等人于2016发表的Paper. 将图像金字塔与CNN中池化层等同起来, 想法很前卫, 但并不准确, Viola-Jones算法中多尺度检测不失为一种巧妙的技巧, 但CNN中pooling layer池化层可以学习更高阶特征, 如眼睛、鼻子和嘴巴, 而Viola Jones算法并不能. 那是否意味着CNN算法更佳, CNN通过识别眼睛、鼻子和嘴巴作为特征来检测人脸的方式, 而非基于像素的过滤器模式. 使用Viola-Jones算法的理由在于, 算法本身容易理解且可使用的库和包很多(大多数包在算法优化方面做得很不错), 并且比基于深度学习的模型更快(虽然牺牲了灵活性). 缺点在于: 大多数Viola-Jones模型仅支持正面脸部检测 此外, Viola-Jones算法可能无法检测到旋转脸部 具体使用哪种算法更佳, 取决于具体业务应用逻辑, 有时可能无需用到神经网络算法(如CNN). PICO 算法还有一种算法是基于像素强度(或像素亮度)对比的物体检测(PICO, Pixel Intensity Comparison-based Object detection)算法,最初由Markus,Frljak等人于2014年提出. 该算法运用与Viola-Jones方法相同的广义原则, 仅有一个级联分类器. 它们的区别在于, 首先PICO算法不使用滑动窗口; 其次, PICO算法使用的级联分类器与Viola-Jones的分类器并不相同. Viola-Jones算法通过重复应用过滤器, 然后对分类器结果求和, 而PICO算法使用决策树. 决策树中每个节点都是特征, 且特征分支由阈值决定, 决策树适用于照片中的每个像素. 对于每个像素而言, 将强度与其它位置的另一像素强度进行对比, 这些像素位置服从正态分布, 无需使用滑动窗口. PICO方法分类器能够直接检测图像的脸部, 使得算法非常快. 当然, PICO算法依然可以看到Viola-Jones算法的痕迹: 首先, 分阶段应用分类器. PICO使用更简单的分类器, 有助于消除脸部低概率区域. 其次, 缩小搜索区域并使用更复杂分类器. PICO算法重复该过程直到最后一个Stage, 并保留每个分类器结果以便后用. 你可能会意识到人脸区域被更多的分类器搜索, 也正由于此, PICO算法提出者在分类器中引入了聚类步骤. 规则很简单: 如果分类器搜索区域重叠且重叠百分比大于30％, 则认为它是同一聚类中的一部分. 因此, 即便是很小的变更, 鲁棒性依然不错. 编码实战问题来了, 是PICO算法人脸检测效果好呢, 还是以OpenCV为主的算法人脸检测效果好? 可以做个小测试, 下面对PICO算法(采用PIGO包)和GoCV(OpenCV的Golang封装)算法进行Bechmark测试, 代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package mainimport ( "image" "testing" pigo "github.com/esimov/pigo/core" "gocv.io/x/gocv")func BenchmarkGoCV(b *testing.B) &#123; img := gocv.IMRead("test.png", gocv.IMReadUnchanged) if img.Cols() == 0 || img.Rows() == 0 &#123; b.Fatalf("Unable to read image into file") &#125; classifier := gocv.NewCascadeClassifier() if !classifier.Load(cascadeFile) &#123; b.Fatalf("Error reading cascade file: %v\n", cascadeFile) &#125; var rects []image.Rectangle b.ResetTimer() for i := 0; i &lt; b.N; i++ &#123; rects = classifier.DetectMultiScale(img) &#125; _ = rects&#125;func BenchmarkPIGO(b *testing.B) &#123; img := gocv.IMRead("test.png", gocv.IMReadUnchanged) if img.Cols() == 0 || img.Rows() == 0 &#123; b.Fatalf("Unable to read image into file") &#125; width := img.Cols() height := img.Rows() goImg, grayGoImg, pigoClass, cParams, imgParams := pigoSetup(width, height) var dets []pigo.Detection b.ResetTimer() for i := 0; i &lt; b.N; i++ &#123; grayGoImg = grayScale(grayGoImg, goImg) imgParams.Pixels = grayGoImg dets = pigoClass.RunCascade(imgParams, cParams) dets = pigoClass.ClusterDetections(dets, 0.3) &#125; _ = dets&#125; 效果如下, 从中可以看出, GoCV比PIGO算法慢, 一方面是cgo调用OpenCV影响, 另一方面也表明PICO算法要比最初的VJ算法快. 完整代码, 请参考这里]]></content>
      <categories>
        <category>Deep Learning &amp; Machine Learning</category>
      </categories>
      <tags>
        <tag>Face Detection</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有必要对Java 8中Metaspace进行适当监控吗?]]></title>
    <url>%2Fjvm%2Fmetaspace%2F</url>
    <content type="text"><![CDATA[随着2014年Java 8的发布, JDK 8 HotSpot JVM开始引入Metaspace对类元数据进行内存分配, 这与IBM JVM、Oracle JRockit有些类似.Java 8中Metaspace开始引入了逃逸技术, 以便对JVM更好地进行性能优化. 有关逃逸技术, 本文将不做更多详细介绍, 有兴趣请自行Google或百度. 首先本文将简单介绍下JDK 1.8中Metaspace相关概念, 其次将对比当Java中类元数据对象溢出时Java HotSpot 1.7与1.8在运行时的一些行为差异. MetaspaceJava8引入Metaspace, 意味着持久代空间被完全移除, 若在新版本Java中使用类似于PermSize、MaxPermSize等JVM参数将被忽视并发出警告. Metaspace的引入, 意味着类似于之前持久代空间产生OOM内存溢出问题会相对少些, 但并不能完全排除类或类加载器内存溢出问题. 关于Metaspace内存分配问题, 需要注意的一点是用于描述类元数据的类已被移除. Metaspace容量 默认类元数据内存分配受限于可用Native Memory(影响因素有OS虚拟内存可用性、使用32位JVM还是64位JVM等) 可通过MaxMetaspaceSize参数限制类元数据使用的Native Memory大小, 如果没有指定该参数, Metaspace根据运行时应用需求动态调节 Metaspace 垃圾回收 一旦类的元数据使用达到MaxMetaspaceSize时, 触发对dead classes以及类加载器(Classloader)的垃圾回收 有必要对Metaspace进行适当监控及调优, 以降低GC频率, Metaspace GC频繁可能意味着类或类加载器内存溢出或应用内存不足等 Java堆(Heap)内存影响从旧版Java升级至Java 8时, 可能会注意到Java堆内存明显增大(有部分其它数据被移至Java堆内存所致). 测试下面看个小测试, 模拟Java类元数据内存泄露, 通过以下几个测试用例理解Metaspace在运行时的一些行为特性. Java类元数据内存泄露模拟逻辑如下: 12345678910111213141516171819202122232425262728293031import java.util.Map;import java.util.HashMap;import java.lang.reflect.Proxy;import java.net.URL;import java.net.URLClassLoader;public class ClassMetaDataLeakSimulation &#123; private static Map&lt;String, TestClass&gt; classLeakMap = new HashMap&lt;String, TestClass&gt;(); private final static DEFALUT_ITERATIONS = 5000; public static void main(String[] args) &#123; System.out.println("Class Metadata Leak Simulation"); int numIterations = (args != null &amp;&amp; args.length == 1) ? Integer.parseInt(args[0]) : DEFALUT_ITERATIONS; try &#123; for (int i = 0; i &lt; numIterations; i++) &#123; String classloaderJAR = "file:" + i + ".jar"; URL[] classloaderURL = new URL[] &#123; new URL(classloaderJAR) &#125;; URLClassLoader newClassLoader = new URLClassLoader(classloaderURL); TestClass t = (TestClass) Proxy.newProxyInstance(newClassLoader, new Class&lt;?&gt;[] &#123; TestClass.class &#125;, new TestClassInvocationHandler(new TestClassImpl())); classLeakMap.put(classloaderJAR, t); &#125; &#125; catch (Throwable any) &#123; System.out.println("ERROR: " + any); &#125; System.out.println("Done!"); &#125;&#125; 其中, TestClassInvocationHandler代码如下: 1234567891011121314151617181920212223242526272829import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class TestClassInvocationHandler implements InvocationHandler &#123; private Object testClassImpl; public TestClassInvocationHandler(Object impl) &#123; this.testClassImpl = impl; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if(Object.class == method.getDeclaringClass()) &#123; String name = method.getName(); if("equals".equals(name)) &#123; return proxy == args[0]; &#125; else if("hashCode".equals(name)) &#123; return System.identityHashCode(proxy); &#125; else if("toString".equals(name)) &#123; return proxy.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(proxy)) + ", with InvocationHandler " + this; &#125; else &#123; throw new IllegalStateException(String.valueOf(method)); &#125; &#125; return method.invoke(testClassImpl, args); &#125;&#125; TestClass、TestClassImpl代码如下: 123456789public interface TestClass &#123; void method(String input);&#125;public class TestClassImpl implements TestClass &#123; public void method(String input) &#123; // 什么也不做 &#125;&#125; 测试一 - JDK 1.7 (64位)Test设定: 主程序5万次迭代, 堆内存设置为1G, PermGen内存设置为128MB( -XX:MaxPermSize=128m). JVisualVM截图如下, 在加载3万个类时, PermGen开始亏损. GC日志输出示意图如下: 测试二 - JDK 1.8 (64位), Metaspace动态调整Test设定: 主程序5万次迭代, 堆内存设置为1G, Metaspace默认. GC日志输出如下, 从中可以看到JVM Metaspace从20MB动态调节至328MB, 注意到程序本身有内存溢出, JVM只能动态拓展Metaspace内存空间. 测试三 - JDK 1.8 (64位), Metaspace大小固定Test设定: 主程序5万次迭代, 堆内存设置为1G, Metaspace设置为128MB( -XX:MaxMetaspaceSize=128m). 从下图可以看到, 当加载至3万个类时Metaspace开始出现损耗, 与JDK1.7测试有些类似. GC日志输出如下, 可以看到Metaspace预留内存(此时为246MB)是指定大小(122MB)的两倍左右, 意味着还存在调优空间. 结论有必要对Metaspace进行适当监控及调优, 避免Metaspace GC频繁或OOM(内存溢出)问题.]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>JVM And JVM Languages</tag>
        <tag>Java 8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava中Backpressure处理小结]]></title>
    <url>%2Fjvm%2Frxjava-backpressure%2F</url>
    <content type="text"><![CDATA[RxJava, 作为一高性能异步、非阻塞、响应式框架, 最早由Netflix技术团队推出. 近些年伴随着Reactive(响应式)大热, Event Stream俨然不能解决广大开发者的难题, Reactive Stream开始走向”台前”. RxJava自诞生之日便开始服务于Netflix内部流式处理、后端服务Reactive优化, 经过Netflix内部层层考验, 顺利开源, 服务于广大社区开发者. RxJava支持Reactive Stream, 因而也对Backpressure处理方面有着不错的支持度. Callbacks &amp; ObserveOn当订阅者进行订阅时, 传入的Subscriber一般需实现onNext()、onCompleted()、onError()方法, 点开Subscriber源码, 发现还有一回调方法onStart(), onStart()在任何Event或通知委派至Subscriber前调用, 可以参考下面这段示例代码: 12345678910111213Subscriber&lt;Integer&gt; subscriber = new Subscriber&lt;Integer&gt; &#123; @Override public void onStart() &#123; // 指示上游数据源, 刚开始期望接收的Item数量 request(2); &#125; // onNext, onCompleted, onError 方法实现略&#125;Observable .range(1, 10) .subscribe(subscriber) 其中, 若在onStart()内部调用 request(Long.MAX_VALUE)或跳过调用request方法, 等效于尽可能快地请求事件, 因此在onStart()中尽可能早调用request方法, 否则下游数据开始消费时不能及时变更请求. 假定以Subscriber预先Buffer一定数量的Event, 然后在方便时请求一定的Chunk, Subcriber也可能在接收更多Events时等待一段时间、空闲一会儿(如为减轻下游压力). 但在客户端代码中调用request(N)比较少见, 一般位于Source和最终Subscriber间不同的Operator会充分利用Backpressure机制控制Pipeline中数据流. observeOn()操作符对Backpressure机制友好, 假定observeOn()操作符订阅上游的Observable, 调度接收的Event, 若上游Event生产速率与下游Scheduler及Subscriber消费速率匹配不上, 由于observeOn()操作符创建的Subcriber, 自带Backpressure机制, 仅请求一定数量的值, 而上游的Observable仅在达到一定数量的Events后触发. 当observeOn()发现当前Batch的Event被下游订阅者Subscriber成功处理完成, 会向上游数据源请求更多Events, 通过该种方式, 尽管跨越了线程界限、以及生产者和消费者间异步本质, 消费者并不会因此”泛洪”. ObservableBackpressure机制, 允许订阅者Subscribers及所有临时操作符从生产者请求一定数量的Event, 默认情况下上游的Observable尽可能快地生产Event, 但由于下游请求的出现, 在某种程度上会”拖慢”(Slow down)生产者, 以便生产者生产特定数量Event. 在RxJava中存在某一类操作符(Operator), 如 observeOn(), 使用比较严格, 如果上游Observable由于某些原因推送较多数据, 超出下游消费速率, 可能造成observeOn()内部 buffer溢出. 以下为一段示例代码: 12345678910111213Observable&lt;Integer&gt; customRange(int from, int count) &#123; return Observable.create(subscriber -&gt; &#123; int i = from; while (i &lt; from + count ) &#123; if (!subscriber.isUnsubscribed()) &#123; subscriber.onNext(i++); &#125; else &#123; return; &#125; subscriber.onCompleted(); &#125; &#125;);&#125; 可以通过取消订阅中止上面这段代码, 但现在要求不能取消订阅、可以”降速限流”. 下游操作符可以准确知道想要接收多少Event, 但上游源也可选择忽视请求. 为处理Backpressure问题, 上面的Range实现可改写如下: 12345678910111213141516171819Observable&lt;Integer&gt; customRangeBackPressure(int from, int count) &#123; return Observable.create(new OnSubscribeRange(from, count));&#125;class OnSubscribeRange implements Observable.OnSubscribe&lt;Integer&gt; &#123; // 略去构造器代码 @Override public void call(final Subscriber&lt;? super Integer&gt; child) &#123; child.setProducer(new RangeProducer(child, start, end)); &#125;&#125;// 自定义实现 Producer 具有挑战性 -- 须有状态、线程安全, 而且要快非常快class RangeProducer implements Producer &#123; @Override public void request(long n) &#123; // 在子订阅者上调用 onNext() 方法 &#125;&#125; 实际上, 由range()等其它操作符产生的Observable不再”eagerly”地去推送数据至订阅者Subscribers, 相反会去处理数据请求(如Subscriber内调用的request(N)), 然后开始生产事件, 当然产生的数据量不能远超请求数据量. SyncOnSubscribe通常有多种方式构造Observable支持下游Backpressure请求, 最简单的方式可以使用RxJava自带的工厂方法range() 或 from(Iterable&lt;T&gt;). from(Iterable&lt;T&gt;)方法创建的Iterable自带Backpressure机制, 这意味着Observable不会一次性从Iterable触发所有值. 以下代码, 将具有Backpressure机制的Observable封装JDBC中的ResultSet至一stream, 注意到ResultSet是拉取(Pull)方式, 与Observable有些类似. 123456789101112131415161718192021222324252627public class ResultSetIterator implements Iterator&lt;Object[]&gt; &#123; private final ResultSet rs; public ResultSetIterator(ResultSet rs) &#123; this.rs = rs; &#125; @Override pubic boolean hasNext() &#123; return !rs.isLast(); &#125; @Override public Object[] next() &#123; rs.next(); return toArray(rs); &#125; public static Iterable&lt;Object[]&gt; iterable(final ResultSet rs) &#123; return new Iterable&lt;Object[]&gt;() &#123; @Override public Iterator&lt;Object[]&gt; iterator() &#123; return new ResultSetIterator(rs); &#125; &#125;; &#125;&#125; 使用示例: 123456789101112131415161718Connection connection = // Some DB ConnectionPreparedStatement stm = Connection.prepareStatement("YOUR SQL HERE");stm.setFetchSize(1000);ResultSet rs = stm.executeQuery();Observable&lt;Object[]&gt; result = Observable.from( ResultSetIterator.iterable(rs) ) .doAfterTerminate(() -&gt; &#123; try &#123; rs.close(); statement.close(); connection.close(); &#125; catch (SQLException e) &#123; log.warn("Unable to close", e); &#125; &#125;); 注意到, 支持Backpressure机制Low-level级别可以通过自定义实现生产者(Producer)实现, 可以考虑使用RxJava中的SyncOnSubscribe, 其使用参考如下, 且下面这段代码中Observable.OnSubcribe基于拉取(Pull), 自带Backpressure支持. 12345678import rx.observables.SyncOnSubcribe;Observable.OnSubscribe&lt;Double&gt; onSubscribe = SyncOnSubcribe.createStateless( observer -&gt; observer.onNext(Math.random()) );Observable&lt;Double&gt; rand = Observable.create(onSubscribe); 上面这段代码中rand虽作为一普通的Observable, 但全面支持Backpressure机制, 假如Subscriber或Pipeline中其它Operator请求Events数量有限, Observable准许请求. rand无状态, 如需创建有状态的操作符, 可以参考下面这段代码: 1234567891011// 注意此处状态值不可变, 可以考虑使用BigInteger避免内存溢出Observable.OnSubscribe&lt;Long&gt; onSubscribe = SyncOnSubscribe.createStateful( () -&gt; 0L, (cur, observer) -&gt; &#123; observer.onNext(cur); return cur + 1; &#125; );Observable&lt;Long&gt; naturals = Observable.create(onSubscribe); 但如果想在迭代时使用单个状态变量, 也可以这样做: 1234567891011121314151617181920Observable.onSubscribe&lt;Object[]&gt; onSubscribe = SyncOnSubscribe.createSingleState( () -&gt; resultSet, (rs, observer) -&gt; &#123; try &#123; rs.next(); &#125; catch (SQLException e) &#123; observer.onError(e); &#125; &#125;, rs -&gt; &#123; try &#123; // 关闭Statement, 数据库连接等 rs.close(); statement.close(); connection.close(); &#125; catch (SQLException e) &#123; log.warn("Unable to close", e); &#125; &#125;); 小结 避免Subcriber中分配过多工作量, 可以考虑Off-loading对应的Work至如flatMap()等高阶函数中. 12345678910111213// 如在subscribe()方法中存储Events至数据库中source.subscribe(this::store);// 可以考虑让 Store更加Reactive (如返回存储记录的 Observable&lt;UUID&gt;)// 然后触发订阅并产生副作用source.flatMap(this::store) .subscribe(uuid -&gt; log.debug("Stored: &#123;&#125;", uuid));// 或者考虑使用批量的UUID减少日志输出产生的Overheadsource.flatMap(this::store) .buffer(100) .subscribe( hundredUuids -&gt; log.debug("Stored: &#123;&#125;", hundredUuids) ); 通过避免在subscribe()方法中执行长时间运行的任务, 可以减少Backpressure处理等.]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>JVM And JVM Languages</tag>
        <tag>RxJava</tag>
        <tag>Reactive</tag>
        <tag>Backpressure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漫谈云原生设计模式之熔断器、API网关、Service Mesh]]></title>
    <url>%2Fcloud-native%2Fsrvcmesh%2F</url>
    <content type="text"><![CDATA[云原生设计模式之熔断器、API网关、Service Mesh篇, 本文主要侧重客户端与服务端交互中常用的一些设计模式和技巧. 熔断器本文不打算对熔断器相关概念做详细介绍, 关于Circuit Breaker熔断器模式及相关描述请自行Google或百度. 本部分要点如下: 首先, 通过一个简单的Posts Service服务示例了解下熔断器, 接着通过压测了解下熔断器优点 其次, 通过Fallback方法对比, 小结熔断器性能优化建议 熔断器实现以Post和Connection Service为例, 通过使用熔断器对Post Service进行容错, 先创建一个 PostService 类, Post Controller本身还有其它逻辑在里边, 本例为简化,仅展示 PostsService 类中核心业务逻辑, Controller仍然处理请求解析、生成回复、以及一些基本的身份验证、授权逻辑等. PostsService 无需处理HTTP协议,只需关注服务核心逻辑即可,如数据库查询及生成响应对象等. 123456789101112131415161718192021222324// 通过 `HystrixCommand` 注解使用熔断器@HystrixCommand()public Iterable&lt;Post&gt; getPostsByUserId(String userIds, String secret) throws Exception &#123; logger.info(utils.ipTag() + "Attempting getPostsByUserId"); Iterable&lt;Post&gt; posts; if (userIds == null) &#123; logger.info(utils.ipTag() + "getting all posts"); posts = postRepository.findAll(); return posts; &#125; else &#123; ArrayList&lt;Post&gt; postsForUsers = new ArrayList&lt;Post&gt;(); String userId[] = userIds.split(","); for (int i = 0; i &lt; userId.length; i++) &#123; logger.info(utils.ipTag() + "getting posts for userId " + userId[i]); posts = postRepository.findByUserId(Long.parseLong(userId[i])); posts.forEach(post -&gt; postsForUsers.add(post)); &#125; return postsForUsers; &#125;&#125; 下面进行压测, 主要逻辑如上图所示, 客户端通过”重试风暴”直至接收回复, 在Post主服务中使用熔断器, 如果抛出大量错误立即熔断. 首先创建一个Kubernetes集群, 编写Bash脚本运行MySQL、Redis以及SCCS. 如下图所示, 主要设计部分如下: Connections’ Posts服务, 主要执行”重试风暴” Connnections服务, 标准连接实现, 弹性设计 Posts服务, 服务主逻辑与Controller进行分离, PostService中封装了熔断器 使用Jmeter进行负载测试 1234$ ./deploy-apps.sh ## 先部署再压测$ kubectl create configmap jmeter-config \ --from-file=jmeter_run.jmx=loadTesting/ConnectionsPostsLoad.jmx$ kubectl create -f loadTesting/jmeter-deployment.yaml 查看测试日志 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364$ kubectl logs -f &lt;name of the jmeter pod&gt;Waiting for possible Shutdown/StopTestNow/Heapdump message on port 4445summary + 85 in 00:00:10 = 8.1/s Err: 0 (0.00%) Active: 85summary + 538 in 00:00:30 = 18.0/s Err: 0 (0.00%) Active: 332summary = 623 in 00:00:40 = 15.4/s Err: 0 (0.00%)summary + 1033 in 00:00:30 = 34.5/s Err: 0 (0.00%) Active: 579summary = 1656 in 00:01:10 = 23.5/s Err: 0 (0.00%)summary + 1529 in 00:00:30 = 51.0/s Err: 0 (0.00%) Active: 829summary = 3185 in 00:01:40 = 31.7/s Err: 0 (0.00%)summary + 2029 in 00:00:30 = 67.6/s Err: 0 (0.00%) Active: 1077summary = 5214 in 00:02:10 = 40.0/s Err: 0 (0.00%)summary + 2520 in 00:00:30 = 84.1/s Err: 0 (0.00%) Active: 1325summary = 7734 in 00:02:40 = 48.2/s Err: 0 (0.00%)summary + 2893 in 00:00:30 = 96.4/s Err: 0 (0.00%) Active: 1500summary = 10627 in 00:03:10 = 55.8/s Err: 0 (0.00%)summary + 3055 in 00:00:30 = 101.8/s Err: 0 (0.00%) Active: 1500summary = 13682 in 00:03:40 = 62.1/s Err: 0 (0.00%)summary + 3007 in 00:00:30 = 100.2/s Err: 0 (0.00%) Active: 1500summary = 16689 in 00:04:10 = 66.7/s Err: 0 (0.00%)&lt;time marker 1 – I have broken the network between Posts and MySQL&gt;summary + 2510 in 00:00:30 = 83.6/s Err: 2084 (83.03%) Active: 1500summary = 19199 in 00:04:40 = 68.5/s Err: 2084 (10.85%)summary + 3000 in 00:00:30 = 100.0/s Err: 3000 (100.00%) Active: 1500summary = 22199 in 00:05:10 = 71.5/s Err: 5084 (22.90%)summary + 3000 in 00:00:30 = 100.0/s Err: 3000 (100.00%) Active: 1500summary = 25199 in 00:05:40 = 74.0/s Err: 8084 (32.08%)summary + 2953 in 00:00:30 = 98.4/s Err: 2953 (100.00%) Active: 1500summary = 28152 in 00:06:10 = 76.0/s Err: 11037 (39.21%)summary + 2916 in 00:00:30 = 96.9/s Err: 2916 (100.00%) Active: 1500summary = 31068 in 00:06:40 = 77.6/s Err: 13953 (44.91%)summary + 3046 in 00:00:30 = 101.7/s Err: 3046 (100.00%) Active: 1500summary = 34114 in 00:07:10 = 79.3/s Err: 16999 (49.83%)summary + 3019 in 00:00:30 = 100.7/s Err: 3019 (100.00%) Active: 1500summary = 37133 in 00:07:40 = 80.7/s Err: 20018 (53.91%)&lt;time marker 2 – I have repaired the network between Posts and MySQL&gt;summary + 2980 in 00:00:30 = 99.3/s Err: 2980 (100.00%) Active: 1500summary = 40113 in 00:08:10 = 81.8/s Err: 22998 (57.33%)summary + 3015 in 00:00:30 = 100.5/s Err: 3015 (100.00%) Active: 1500summary = 43128 in 00:08:40 = 82.9/s Err: 26013 (60.32%)summary + 3020 in 00:00:30 = 100.7/s Err: 3020 (100.00%) Active: 1500summary = 46148 in 00:09:10 = 83.8/s Err: 29033 (62.91%)summary + 3075 in 00:00:30 = 102.5/s Err: 3072 (99.90%) Active: 1500summary = 49223 in 00:09:40 = 84.8/s Err: 32105 (65.22%)summary + 3049 in 00:00:30 = 101.6/s Err: 2395 (78.55%) Active: 1500summary = 52272 in 00:10:10 = 85.6/s Err: 34500 (66.00%)summary + 3191 in 00:00:30 = 106.4/s Err: 2263 (70.92%) Active: 1500summary = 55463 in 00:10:40 = 86.6/s Err: 36763 (66.28%)summary + 2995 in 00:00:30 = 99.7/s Err: 1203 (40.17%) Active: 1500summary = 58458 in 00:11:10 = 87.2/s Err: 37966 (64.95%)summary + 3031 in 00:00:30 = 101.1/s Err: 1193 (39.36%) Active: 1500summary = 61489 in 00:11:40 = 87.8/s Err: 39159 (63.68%)summary + 3009 in 00:00:30 = 100.3/s Err: 1182 (39.28%) Active: 1500summary = 64498 in 00:12:10 = 88.3/s Err: 40341 (62.55%)summary + 3083 in 00:00:30 = 102.8/s Err: 859 (27.86%) Active: 1500summary = 67581 in 00:12:40 = 88.9/s Err: 41200 (60.96%)summary + 3110 in 00:00:30 = 103.7/s Err: 597 (19.20%) Active: 1500summary = 70691 in 00:13:10 = 89.4/s Err: 41797 (59.13%)summary + 2999 in 00:00:30 = 99.9/s Err: 0 (0.00%) Active: 1500summary = 73690 in 00:13:40 = 89.8/s Err: 41797 (56.72%)summary + 3001 in 00:00:30 = 100.1/s Err: 0 (0.00%) Active: 1500summary = 76691 in 00:14:10 = 90.2/s Err: 41797 (54.50%) 如图所示, Connections’Posts所有请求均失败, 通过日志输出,可以看到大约1分钟后出现第一个恢复迹象,完全恢复可能需要3到4分钟. 以上是含有熔断器的例子, 下面去掉熔断器, 主要实现和测试逻辑与上面类似, 作为对照组, 实验组和对照组结果对比如下: 组别 初次恢复耗时 完全恢复耗时 无熔断器 9 min 12-13 min 有熔断器 1-2 min 4-5 min Impressive? 但包含熔断器的实验组恢复时间为何这么快? 可以参考下图, 熔断器打开后, 并非每次重试连接都会超时,Connections’ Posts服务可快速收到Posts服务响应,状态码500清楚地表明存在问题. 对于对照组没有熔断器而言, 如果Posts服务面临故障, 客户端白白浪费时间等待回复;对于实验组而言, 当熔断器处于开着状态时, 若Posts服务面临故障, 客户端立即知晓将不会产生回复, 迫使等待时间最小化, 以增加整个系统的健康程度及可用性; 当实验组熔断器处于关闭状态时, 若Posts服务面临故障, 如果没有检测到故障,熔断器在关闭比前可以继续运行, 客户端可能会等待一段时间, 如果这种现象偶尔发生, 对整个系统影响较小, 如果经常发生则对整个系统影响较大. Fallback Or Not ?如下图所示, 很明显Fallback有助于弹性模式设计, 每种Fallback方法的上下文均不同, 如下图所示,对于客户端Connections’ Post服务而言, 多次重试失败可调用Fallback方法; 对于服务端交互而言, 重复多次失败后当熔断器开启时也可调用Fallback方法. 再来做个小测试, Hystrix对于熔断器提供了Fallback支持, 下面对熔断器中是否使用Fallback方法进行压测对比. 在 PostService 中对熔断器中增加Fallback支持, 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Hystrix Fallback方法可以链起来(chained)使用, 例如主方法失败了, 可以调用fallbackMethodOne; * 如果fallbackMethodOne方法失败了, 可以将控制权给fallbackMethodTwo等, 依此类推. * 每次当Hystrix-protected Command返回错误时调用Fallback方法, 即使熔断器已经关闭. */@HystrixCommand(fallbackMethod = "getSponsoredPosts")public Iterable&lt;Post&gt; getPostsByUserId(String userIds, String secret) throws Exception &#123; logger.info(utils.ipTag() + "Attempting getPostsByUserId"); Iterable&lt;Post&gt; posts; if (userIds == null) &#123; logger.info(utils.ipTag() + "getting all posts"); posts = postRepository.findAll(); return posts; &#125; else &#123; ArrayList&lt;Post&gt; postsForUsers = new ArrayList&lt;Post&gt;(); String userId[] = userIds.split(","); for (int i = 0; i &lt; userId.length; i++) &#123; logger.info(utils.ipTag() + "getting posts for userId " + userId[i]); posts = postRepository.findByUserId(Long.parseLong(userId[i])); posts.forEach(post -&gt; postsForUsers.add(post)); &#125; return postsForUsers; &#125;&#125;public Iterable&lt;Post&gt; getSponsoredPosts(String userIds, String secret) &#123; logger.info(utils.ipTag() + "Accessing Hystrix fallback getSponsoredPosts"); ArrayList&lt;Post&gt; posts = new ArrayList&lt;Post&gt;(); posts.add(new Post(999L, "Some catchy title", "Some great sponsored content")); posts.add(new Post(999L, "Another catchy title", "Some more great sponsored content")); return posts;&#125; 重新压测 123$ # 停掉之前运行的压测, 重新部署并进行压测$ kubectl delete deploy jmeter-deployment &amp;&amp; ./deployApps.sh $ kubectl create -f loadTesting/jmeter-deployment.yaml 查看日志 1234567891011121314151617181920212223242526272829303132333435363738$ kubectl logs -f &lt;name of the jmeter pod&gt;Waiting for possible Shutdown/StopTestNow/Heapdump message on port 4445summary + 217 in 00:00:21 = 10.4/s Err: 0 (0.00%) Active: 171summary + 712 in 00:00:30 = 23.7/s Err: 0 (0.00%) Active: 419summary = 929 in 00:00:51 = 18.3/s Err: 0 (0.00%)summary + 1209 in 00:00:30 = 40.3/s Err: 0 (0.00%) Active: 667summary = 2138 in 00:01:21 = 26.4/s Err: 0 (0.00%)summary + 1706 in 00:00:30 = 57.0/s Err: 0 (0.00%) Active: 916summary = 3844 in 00:01:51 = 34.7/s Err: 0 (0.00%)summary + 2205 in 00:00:30 = 73.5/s Err: 0 (0.00%) Active: 1166summary = 6049 in 00:02:21 = 43.0/s Err: 0 (0.00%)summary + 2705 in 00:00:30 = 90.2/s Err: 0 (0.00%) Active: 1415summary = 8754 in 00:02:51 = 51.2/s Err: 0 (0.00%)summary + 2998 in 00:00:30 = 99.9/s Err: 0 (0.00%) Active: 1500summary = 11752 in 00:03:21 = 58.5/s Err: 0 (0.00%)&lt;time marker 1 – I have broken the network between Posts and MySQL&gt;summary + 3004 in 00:00:30 = 100.0/s Err: 0 (0.00%) Active: 1500summary = 14756 in 00:03:51 = 63.9/s Err: 0 (0.00%)summary + 2997 in 00:00:30 = 99.9/s Err: 0 (0.00%) Active: 1500summary = 17753 in 00:04:21 = 68.1/s Err: 0 (0.00%)summary + 3001 in 00:00:30 = 100.1/s Err: 0 (0.00%) Active: 1500summary = 20754 in 00:04:51 = 71.4/s Err: 0 (0.00%)summary + 3000 in 00:00:30 = 100.0/s Err: 0 (0.00%) Active: 1500summary = 23754 in 00:05:21 = 74.0/s Err: 0 (0.00%)summary + 3000 in 00:00:30 = 100.0/s Err: 0 (0.00%) Active: 1500summary = 26754 in 00:05:51 = 76.3/s Err: 0 (0.00%)summary + 3000 in 00:00:30 = 100.0/s Err: 0 (0.00%) Active: 1500summary = 29754 in 00:06:21 = 78.1/s Err: 0 (0.00%)summary + 2995 in 00:00:30 = 99.9/s Err: 0 (0.00%) Active: 1500summary = 32749 in 00:06:51 = 79.7/s Err: 0 (0.00%)&lt;time marker 2 – I have repaired the network between Posts and MySQL&gt;summary + 3005 in 00:00:30 = 100.2/s Err: 0 (0.00%) Active: 1500summary = 35754 in 00:07:21 = 81.1/s Err: 0 (0.00%)summary + 2997 in 00:00:30 = 99.9/s Err: 0 (0.00%) Active: 1500summary = 38751 in 00:07:51 = 82.3/s Err: 0 (0.00%) 其中, Time Marker 1表明了Posts服务与MySQL数据库断开时间, Time Marker 2表示重新连接, 如上所示, 即使在网络中断期间,对Connections’Posts的调用也从未失败过, 主要由于熔断器Fallback方法在Posts服务面临任意故障时的辅助作用. 比较有意思的一点是, 重建网络连接后实时返回内容的时间: 不到5秒.主要由于sleepWindowMilliseconds默认设置是5000,意味着熔断器由Half-Open状态转变为Open状态, 耗时5秒,此时,允许通过Post服务逻辑的试用请求成功,熔断器关闭,应用程序重新变为稳定状态.可以在其中一个Posts服务实例日志输出中看到此类转换: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545520:59:03.084 getting posts for userId 220:59:03.148 Attempting getPostsByUserId20:59:03.148 getting posts for userId 220:59:03.167 Attempting getPostsByUserId20:59:03.167 getting posts for userId 2&lt;time marker 1 – I have broken the network between Posts and MySQL&gt;20:59:03.213 Accessing Hystrix fallback getSponsoredPosts20:59:03.237 Accessing Hystrix fallback getSponsoredPosts20:59:03.243 Accessing Hystrix fallback getSponsoredPosts20:59:03.313 Accessing Hystrix fallback getSponsoredPosts20:59:03.351 Accessing Hystrix fallback getSponsoredPosts20:59:03.357 Accessing Hystrix fallback getSponsoredPosts20:59:03.394 Accessing Hystrix fallback getSponsoredPosts... (there are many more of these log lines)&lt;time marker 2 – I have repaired the network between Posts and MySQL&gt;... (another 5 seconds or so of Hystrix mentioning messages)(then, ...)21:02:33.705 Accessing Hystrix fallback getSponsoredPosts21:02:33.717 Accessing Hystrix fallback getSponsoredPosts21:02:33.717 Accessing Hystrix fallback getSponsoredPosts21:02:33.898 getting posts for userId 321:02:33.898 getting posts for userId 321:02:33.899 getting posts for userId 321:02:33.899 getting posts for userId 321:02:33.900 getting posts for userId 321:02:33.905 Accessing Hystrix fallback getSponsoredPosts21:02:33.911 Accessing Hystrix fallback getSponsoredPosts21:02:33.943 Accessing Hystrix fallback getSponsoredPosts21:02:34.080 Accessing Hystrix fallback getSponsoredPosts21:02:34.100 Accessing Hystrix fallback getSponsoredPosts21:02:34.113 Accessing Hystrix fallback getSponsoredPosts21:02:34.216 Accessing Hystrix fallback getSponsoredPosts21:02:34.225 Accessing Hystrix fallback getSponsoredPosts21:02:34.300 Accessing Hystrix fallback getSponsoredPosts21:02:34.368 Accessing Hystrix fallback getSponsoredPosts21:02:34.398 Attempting getPostsByUserId21:02:34.398 getting posts for userId 221:02:34.400 getting posts for userId 321:02:34.433 Attempting getPostsByUserId21:02:34.433 getting posts for userId 221:02:34.434 Attempting getPostsByUserId21:02:34.434 getting posts for userId 221:02:34.435 getting posts for userId 321:02:34.437 getting posts for userId 321:02:34.472 Attempting getPostsByUserId21:02:34.472 getting posts for userId 221:02:34.475 getting posts for userId 321:02:34.556 Attempting getPostsByUserId21:02:34.556 getting posts for userId 221:02:34.559 getting posts for userId 321:02:34.622 Attempting getPostsByUserId(and operation has returned to normal) 测试结果如下: 组别 初次恢复耗时 完全恢复耗时 网络中断时错误率 熔断器不含Fallback方法 1-2 min 4-5 min 100% 熔断器含Fallback方法 N/A—即使网络中断仍无故障 &lt;5s 0% 结论: “人生苦短”, 能用Fallback方法时尽量别犹豫, 毕竟在熔断器中多加层容错性保证, 有何不可. API网关开源以及商业API网关可用性早于微服务和云计算架构, 如早期Apigee(被谷歌收购)和Mashery(被英特尔收购后再出售给TIBCO)等公司均专注于API网关.API网关在软件架构设计上可以减少一些不必要的应用耦合, 提升开发效率, 以便开发人员可以更好地专注于业务逻辑. 另一方面, API网关在设计上, 便于中心化、统一管理, 便于维护. API网关可通过与其他服务交互执行具体职责, 如API网关本身无需存储需要进行身份验证和授权的用户, 但取决于身份识别、访问管理及ID存储等服务. 通常API网关设计上包含的服务有: 身份验证和授权, 通过API网关控制对服务的访问, 访问控制机制有多种, 如基于秘钥: 通过使用密码或Token信令; 或基于网络, 如服务集成或实现了防火墙. 数据加密, API网关可以处理解密,管理认证. 防止服务过载, 如果配置合理, 客户端只能通过API网关访问服务, 当然也可以通过节流进行保护 日志访问, 由于所有客户端请求均需通过API网关访问服务, 因此可以记录所有访问,便于后续日志排查、审计等. 如图, 该业务场景下的API网关包含验证授权、身份识别访问管理以及日志审计,客户端与服务通过API网关进行交互, 所有访问及政策变更可通过API网关记录, 以便进行验证、审计等. 云原生下API网关面临挑战虽然API网关已有多年历史, 但云原生架构的发展对API网关提出了新的要求, 如: 首先微服务数量级剧增, 如当拥有成千上万个服务实例时, 很难管理. 在突发事故以及定期升级时对服务实例进行频繁变更,在没有其他辅助软件帮助下, 很难对事件进行追踪并处理. 高度分布式系统中弹性模式应用,如重试机制,可能带来不同的服务负载,有些负载可能难以预测, 此时需要避免服务受一些极端请求影响或产生意外, 如可以通过熔断器进行容错等. 如云原生架构中基于计费的服务消费业务, API网关须支持必要的计量工作,有时还可能需要节流. 并行部署, 通过API网关可以很方便地实现路由逻辑, 对于后续安全升级具有重大影响 API网关部署拓扑一个中心化的网关在云原生有点反模式. 以前API网关通常进行中心化、集群化、组件式部署,但在云原生架构中已经发生了改变. 比如API网关分布式实现问题, 如下图所示, 由于管理需要,可以将网关视为单个逻辑实体. 注意到图中具有更多的服务实例, 倘若使用中心化API网关, 意味着所有服务交互均需通过API网关进行, 意味着可能需要处理流量过载问题; 若通过分布式处理,每个网关实例单独处理其服务负载, 便于追踪和排查. 常见的开源API网关, 如Netflix Zuul, 官方描述为”提供动态路由、监控、弹性、安全等服务.” Zuul可与Netflix微服务框架中其他组件结合使用, 如Hystrix(熔断器),Ribbon(负载平衡),Turbine(指标)等. Zuul,主要由Java编写, 常见配置项如URL配置等, 如为Posts服务配置网关, 需指定URL和端口等: 12zuul.routes.connectionPosts.url = http://localhost:8090/connectionPostsserver.port = 8080 如何在API网关拓扑中使用Zuul, 通常部署方式如下: 高度分布式环境中,建议部署方式如下: 实际上Spring Cloud为Zuul提供了一种嵌入服务的方式,类似于嵌入熔断器一样, 便于实现如上图所示的拓扑部署. 将网关嵌入到服务中具有一些明显的优点:网关和服务本身之间没有网络跳跃, 配置中可以不需要主机名,只需提供路径即可, 没有跨域资源共享问题(Cross Origin Resource Sharing, CORS)等. 但也存在一些缺点,如: 首先,灵活性问题, 比如配置文件application.properties中更改配置需要重新编译, 当然属性值也可以通过后续环境变量注入, 但仍需重启JVM(或至少刷新下应用上下文); 其次, 如果应用中需嵌入Java组件, 服务实现语言必须使用Java或其它JVM语言, 当然具体使用何种语言实现, 取决于项目团队及具体业务逻辑等; 最后, API网关模式的目的之一是将服务开发人员与运维人员的侧重点分离, 如为运维人员或运营人员提供控服务管理等, 嵌入意味着耦合. Service Mesh由于服务交互跨进程,甚至跨越网络边界,因此在分布式、云部署环境中需利用各种模式提供更加鲁棒性的软件实现, 以适应不断地需求变更. 常见措施有: 客户端重试及服务端熔断器实现,当然熔断器实现也可概括为网关模式, 值得注意的是,服务网格(Service Mesh)的兴起, 俨然成为了运行云原生应用程序平台中的重要组成部分. Service Mesh原语之Sidecar如何在分布式环境中实现API网关功能, 并避免嵌入Java组件带来的缺点, 解决方案可以考虑引入Sidecar(边车). 简而言之, 边车可与主要服务一起运行.网关服务可与其它服务一起运行, 但不一定是嵌入服务中,为了避免其被编译到二进制文件中, 网关边车须运行于另一独立进程中, 与运行的主服务进程分离. Kubernetes提供了一种抽象Kubernetes Pod, Pod是Kubernetes中最小部署单元, 可以包含一个或多个容器. 可以将主服务托管在一个容器中, 将网关服务托管在另一个容器中, 两者均运行于同一Pod中. 如图, 对于每项服务而言, 分布式网关作为边车运行, 在Kubernetes中一般通过在同一个pod中运行两个容器来实现, 一个运行主服务, 另一个运行网关边车. 每个容器均有自己的运行时环境, 因此主服务可以在JVM中运行, 而网关边车可以由C++实现. 但现在网关和主服务之间通信是进程间通信,甚至是跨容器通信, 这意味着网络跃点. 值得注意的一点是, 在Kubernetes Pod中运行的所有服务都托管于同一IP地址, 这意味着它们可以通过localhost寻址,因此网络跃点很小. 目前比较流行的Sidecar边车框架有Envoy, Envoy最初由Lyft公司开发,采用C语言编写, 分布式代理非常高效, 可以在各种部署拓扑中使用. 这里将Envoy描述为代理,而非网关, 因为Envoy不仅可以充当网关, 也可以充当客户端代理. 通过Sidecar编程交互, Envoy在交互实现了提供了很多便利, 如重试、熔断器、限流、负载平衡、服务发现、服务观测等. Control Plane如下图所示, Envoy代理通交互的通道相连, 看起来像一个网格,Service Mesh由此得名, 服务网格(Service Mesh)包含一系列互连的Sidebar,并由控制平面(Control Plane)管理这些代理. 目前Service Mesh使用广泛的框架有Istio,该项目由谷歌,IBM和Lyft孵化并开源, 对Kubernetes组件进行了拓展,使用pod原语作为Envoy Sidecars的部署机制. Istio自标”连接、安全、控制及观测服务”,通过支持自动边车注入并提供支持Envoy代理配置、验证处理及策略实施组件.]]></content>
      <categories>
        <category>Cloud Native</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>Containers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rust大法试水NLP之命名实体识别]]></title>
    <url>%2Frust%2Fcrf-ner%2F</url>
    <content type="text"><![CDATA[命名实体识别作为自然语言处理(NLP)中重要一环, 有助于后续语义感知与语义知识库构建. 实体存在于文本中, 可以基于预定义范畴(通常这些范畴基于上下文语境或特定场景)进行分类. 目前比较流行的NLP相关算法思想, 主要分为以下两大流派:概率图模型(基于概率论和图论)基于人工神经网络的深度学习算法理论常见的概率图模型主要有:朴素贝叶斯模型隐式马科夫模型条件随机场模型最大熵模型 CRF(条件随机场, Conditional Random Fields)算法, 作为概率图模型中的一种, 可用于NLP语言模型设计, CRF算法也可用于命名实体识别. CRF算法基于历史标签的上下文信息进行分类, 标签中上文信息越丰富, 预测效果越佳. 有关CRF算法理论部分, 请自行谷歌或百度, 本文不再展开讨论. 为提高CRF算法效率, 通常需要对输入文本进行词性标注, 如将语句中的名词、动词、副词、介词等短语进行序列化标注, 这些序列化标注工作以前全靠人工手动标注, 但伴随着深度学习大热, 开始涌现一批自动化文本标注工具. 常见的开源文本标注工具, 参考如下: GATE, General Architecture and Text Engineering(通用架构与文本引擎), 老牌文本标注工具, 免费且开源 Brat, 基于在线环境的快速标注工具, 支持协作式文本标注 Anafora，免费, 开源, 基于Web的文本标注工具 准备数据集本文将使用Kaggle网站提供的一实体标记语料数据集进行CFR算法训练与预测, 该数据集包含以下等25项字段(由于字段太多, 仅挑出几个说明): lemma, 语句词元或词根 next-lemma, 语句下一词元 next-next-lemma, 基于上一词元接着出现的词元 word, 也称Token, 单词 tag, 当前Token的IOB标注 该实体标记语料数据样本参考如下: 代码实战代码主逻辑参考如下: 123456789101112131415161718pub fn main() &#123; let args: Vec&lt;String&gt; = env::args().collect(); let data_path = &amp;args[1]; // 首先, 进行数据解析与抽取 let data = extract_data(&amp;data_path).unwrap(); // 然后, 按照经典的Cross Validation思想进行迭代训练, // 对语料数据集进行分割, 主要分割为训练集与测试集 // 指定特征矩阵以及标签向量 let (test_data, train_data) = dataset_splitter(&amp;data, 0.2); let (xseq_train, yseq_train) = create_xseq_yseq(&amp;train_data); let (xseq_test, yseq_test) = create_xseq_yseq(&amp;test_data); // 进行CRF算法训练与预测, 并输出该算法主要评估指标--准确率 crfmodel_training(xseq_train, yseq_train, "model.crfsuite").unwrap(); let preds = model_prediction(xseq_test, "model.crfsuite").unwrap(); check_accuracy(&amp;preds, &amp;yseq_test);&#125; 完整代码, 请参考这里. 下面细分步骤进行说明, 对代码进行分解. 添加依赖首先新建一Rust项目, 参考指令如下: 1$ cargo new crf-named-entity-recognition --bin 进入该项目主目录, 在Cargo.toml中添加以下依赖: 123456[dependencies]csv = "1.0.7"serde = "1"serde_derive = "1"rand = "0.6.5"crfsuite = "0.2.6" 以上Crates中, crfsuite主要用于CRF算法训练与预测, serde与serde_derive处理数据序列化与反序列化, csv用于抽取语料样本数据, rand主要用于数据混排. 数据抽取由于语料数据集为CSV格式, 数据抽取方法参考如下: 123456789101112131415161718192021// 定义结构体`NER`, 该ADT(抽象数据类型或代数数据类型)主要用于描述语料数据集上每一行需要抽取的数据// 包括: 词根(或词元), 下一词元, 单词, 标签 (可以选取更多特征, 本文为了说明仅选用较少特征)#[derive(Debug, Deserialize, Clone)]pub struct NER &#123; //命名实体识别(Named Entity Recognition, NER) lemma: String, #[serde(rename="next-lemma")] next_lemma: String, word: String, tag: String&#125;fn extract_data(path: &amp;String) -&gt; Result&lt;Vec&lt;NER&gt;, Box&lt;Error&gt;&gt; &#123; let mut rdr = csv::Reader::from_path(path)?; let mut data = Vec::new(); for result in rdr.deserialize() &#123; let r: NER = result?; data.push(r); &#125; data.shuffle(&amp;mut thread_rng()); Ok(data)&#125; 数据集切分语料数据抽取完毕, 下面进行数据集分割, 主要分为语料训练集与语料测试集(在训练集上算法训练, 在测试集上进行算法预测), 代码参考如下: 123456fn dataset_splitter(data: &amp;[NER], test_size: f32) -&gt; (Vec&lt;NER&gt;, Vec&lt;NER&gt;) &#123; let test_size: f32 = data.len() as f32 * test_size; let test_size = test_size.round() as usize; let (test_data, train_data) = data.split_at(test_size); (test_data.to_vec(), train_data.to_vec())&#125; 指定CFR算法训练的Attribute(本例为词元及下一词元)矩阵与预测标签(本例为语料中的Tag, 标注字段)向量, 代码参考如下: 12345678910111213use crfsuite::Attribute;fn create_xseq_yseq(data: &amp;[NER]) -&gt; (Vec&lt;Vec&lt;Attribute&gt;&gt;, Vec&lt;String&gt;) &#123; let mut xseq = vec![]; let mut yseq = vec![]; for item in data &#123; let seq = vec![Attribute::new(item.lemma.clone(), 1.0), Attribute::new(item.next_lemma.clone(), 0.5)]; xseq.push(seq); yseq.push(item.tag.clone()); &#125; (xseq, yseq) &#125; 算法训练进行CRF算法训练, 代码参考如下: 123456789101112131415use crfsuite::&#123;Attribute, CrfError&#125;;use crfsuite::&#123;Trainer, Algorithm, GraphicalModel&#125;;fn crfmodel_training(xseq: Vec&lt;Vec&lt;Attribute&gt;&gt;, yseq: Vec&lt;String&gt;, model_name: &amp;str) -&gt; Result&lt;(), Box&lt;CrfError&gt;&gt;&#123; let mut trainer = Trainer::new(true); // AROW(权重向量自适应归一化, Adaptive Regularization of Weight Vector) trainer.select(Algorithm::AROW, GraphicalModel::CRF1D)?; trainer.append(&amp;xseq, &amp;yseq, 0i32)?; trainer.train(model_name, -1i32)?; Ok(())&#125; 上述方法中, 对权重向量使用Adaptive regularization(自适应归一化)算法, 除了该算法外, 其它备选算法参考如下: 基于L-BFGS方法的梯度下降算法, 可用于查找对象函数局部最小值, 充分利用对象函数值及梯度值 基于L2系数归一化的SGD, 结合了梯度下降及拥有L2系数的损失函数, 可避免数据过拟合 感知机均值法(Averaged Perceptron), 二分类方法, 使用包含权重均值及Bias的标准感知机算法 Passive Aggressive, 防止分类错误导致权重变更(Aggressive风格) 算法预测CRF算法预测, 参考代码如下: 123456789use crfsuite::&#123;Model, Attribute, CrfError&#125;;fn model_prediction(xtest: Vec&lt;Vec&lt;Attribute&gt;&gt;, model_name: &amp;str) -&gt; Result&lt;Vec&lt;String&gt;, Box&lt;CrfError&gt;&gt;&#123; let model = Model::from_file(model_name)?; let mut tagger = model.tagger()?; let preds = tagger.tag(&amp;xtest)?; Ok(preds) &#125; 算法评估算法评估, 打印准确率: 123456789101112131415161718fn check_accuracy(predicted: &amp;[String], actual: &amp;[String]) &#123; let mut hits = 0; let mut correct_hits = 0; for (pred, actl) in predicted.iter().zip(actual) &#123; if actl != "0" &#123; if pred == actl &amp;&amp; actl != "0" &#123; correct_hits += 1; &#125; hits += 1; &#125; &#125; println!("accuracy=&#123;&#125; (&#123;&#125;/&#123;&#125;) correct", correct_hits as f32 / hits as f32, correct_hits, hits);&#125; 效果检测运行上面代码, 进行CRF算法训练与预测, 迭代效果如下: 可以看到算法准确率为80.9%, 该算法还存在改进空间, 由于本例训练的数据集较小(大概1-2千项Record, 为了算法选型目的最开始使用小批量数据查看效果), 后续可以适当增大数据集, 改善算法质量.]]></content>
      <categories>
        <category>Deep Learning &amp; Machine Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning &amp; Machine Learning</tag>
        <tag>Rust</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rust大法试水NLP之语义推断引擎构建篇]]></title>
    <url>%2Frust%2Finference%2F</url>
    <content type="text"><![CDATA[自然语言处理(NLP, Natural Language Processing)中, 意图识别与意图推断, 是语义识别模型训练中的重要一环. 本文将使用Rust语言构建一意图推断(语义推断)引擎, 考虑到迭代原因, 本文将使用Python进行意图模型训练, 然后通过Rust构建引擎, 调用训练好的模型进行意图推断. 意图模型为避免对已安装好的Python环境造成影响, 建议使用Python虚拟环境. 创建Python虚拟环境, 参考指令如下: 123$ virtualenv --python=python3 engine_env$ # 启用Python虚拟环境$ source engine_env/bin/activate 安装包依赖本文将使用snips-nlu包进行意图训练, 该依赖包安装指令参考如下: 1(engine_env) $ pip install snips-nlu 准备数据集下载对应的自然语言包(本文仅以英语为例)进行训练: 123(engine_env) $ snips_nlu download en(engine_env) $ # 或者下载所有支持的自然语言包(engine_env) $ python -m snips_nlu download en 准备语料样本(即样本语句与包含实体和意图的语义环境), 本文将以家居环境中灯控与温控为例, 进行意图训练与推断. 以下语料样本包含房间实体、灯控(开关灯)意图、温控(温度控制)意图及相关语句样本: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 开灯意图---type: intentname: TurnLightOnslots: - name: room entity: roomutterances: - Turn on the lights in the [room](kitchen) - give me some light in the [room](bathroom) please - Can you light up the [room](living room) ? - switch the [room](bedroom)'s lights on please# 关灯意图---type: intentname: TurnLightOffslots: - name: room entity: roomutterances: - Turn off the lights in the [room](entrance) - turn the [room](bathroom)'s light out please - switch off the light the [room](kitchen), will you? - Switch the [room](bedroom)'s lights off please# 温控意图---type: intentname: SetTemperatureslots: - name: room entity: room - name: roomTemperature entity: snips/temperatureutterances: - Set the temperature to [roomTemperature](19 degrees) in the [room](bedroom) - please set the [room](living room)'s temperature to [roomTemperature](twenty two degrees celsius) - I want [roomTemperature](75 degrees fahrenheit) in the [room](bathroom) please - Can you increase the temperature to [roomTemperature](22 degrees) ?# 家居(房间)实体---type: entityname: roomautomatically_extensible: novalues:- bedroom- [living room, main room, lounge]- [garden, yard, backyard] 假定上面的语料样本名为sample.yaml, 下面进行意图模型训练: 12(engine_env) $ # 生成训练数据集, 并适当转换数据格式(engine_env) $ snips-nlu generate-dataset en sample.yaml &gt;dataset-inference.json 模型训练进行意图模型训练, 参考指令如下: 1(engine_env) $ snips-nlu train dataset-inference.json snips.model -v 模型训练日志输出参考如下: 123456Create and train the engine...[INFO][23:16:51.091]][snips_nlu.intent_parser.deterministic_intent_parser]: Fitting deterministic parser......[INFO][23:16:57.294][snips_nlu.nlu_engine.nlu_engine]: Fitted NLU engine in 0:00:07.315197Persisting the engine...Saved the trained engine 构建引擎本节将使用Rust构建意图推断引擎, 可以通过snips-nlu-lib进行意图解析, 然后调用上文中已训练好的模型, 基于给定的语句输入进行意图推断. 本文将使用Rocket进行接口封装, 基于输入语句, 进行意图判定与预测并返回相关置信度. 添加依赖首先新建一Rust项目, 指令参考如下: 1$ cargo new reference_engine --bin 进入该项目主目录(reference_engine目录), 在Cargo.toml中添加以下依赖: 1234567[dependencies]snips-nlu-lib = &#123; git = "https://github.com/snipsco/snips-nlu-rs", branch = "master" &#125;rocket = "0.4.0"rocket_contrib = "0.4.0"serde = "1.0"serde_json = "1.0"serde_derive = "1.0" 接口封装本文接口调用的返回结果为JSON文本, 代码主逻辑参考如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// reference_engine/main.rs#![feature(proc_macro_hygiene, decl_macro)]#[macro_use] extern crate rocket;#[macro_use] extern crate rocket_contrib;#[macro_use] extern crate serde_derive;extern crate snips_nlu_lib;use std::sync::Mutex;use snips_nlu_lib::SnipsNluEngine;use rocket::&#123;Rocket, State&#125;;use rocket_contrib::json::Json;#[derive(Serialize, Deserialize)]struct Message &#123; contents: Stirng&#125;type Engine = Mutex&lt;SnipsNluEngine&gt;;fn main() &#123; rocket().launch();&#125;fn rocket() -&gt; Rocket &#123; let engine = init_engine(); rocket::ignite() .manage(Mutex::new(engine)) .mount("/", reoutes![bonjour, infer]);&#125;fn init_engine() -&gt; SnipsNluEngine &#123; let engine_path = "/path/to/snips.model"; println!("\nLoading The NLU Model..."); let engine = SnipsNluEngine::from_path(engine_path).unwrap(); engine&#125;#[post("/infer", format="json", data="&lt;message&gt;")]fn infer(message: Json&lt;Message&gt;, engine: State&lt;Engine&gt;) -&gt; String &#123; let query = message.0.contents; let engine = engine.lock().unwrap(); let result = engine.get_intents(query.trim()).unwrap(); let result_json = serder_json::to_string_pretty(&amp;result).unwrap(); result_json;&#125;#[get("/")]fn bonjour() -&gt; &amp;'static str &#123; "Bonjour, From Snips Model Inference!"&#125; 效果测试运行上面的Rust代码, 指令参考如下: 123456789101112$ cd reference_engine &amp;&amp; cargo run --release Compiling reference_engine v1.1.0 (...) Finished dev [optimized + debuginfo] target(s) in 39s Running `target/debug/reference_engine` Loading the nlu engine... ... Mounting /: =&gt; GET / (bonjour) =&gt; POST /infer application/json (infer) Rocket has launched from http://localhost:8000 接口测试: 12345$ curl --header "Content-Type: application/json" \ --request POST \ --data '&#123;"contents": "Please set the temperature to 25 degrees in the bedroom"&#125;' \ localhost:8000/infer$ 返回: 123456789101112131415161718[ &#123; "intentName": "SetTemperature", "confidenceScore": 1.0 &#125;, &#123; "intentName": "TurnLightOn", "confidenceScore": 0.08828778 &#125;, &#123; "intentName": "TurnLightOff", "confidenceScore": 0.070788406 &#125;, &#123; "intentName": null, "confidenceScore": 0.291604 &#125;,] 意图推断正常.]]></content>
      <categories>
        <category>Deep Learning &amp; Machine Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning &amp; Machine Learning</tag>
        <tag>Rust</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rust大法试水NLP之语句分类与预测]]></title>
    <url>%2Frust%2Ffasttext%2F</url>
    <content type="text"><![CDATA[本文将使用Rust进行语句分类与预测. 准备数据集本文将使用Kaggle网站提供的惊悚小说作者鉴定文本数据集, 该数据集包含三大文豪(爱伦坡-Edgar Allan Poe-简称EAP, 洛夫克拉夫特-HP Lovecraft-简称HPL, 玛丽·雪莱-Mary W. Shelley-简称MWS)所著恐怖小说文本, 其中待训练数据集样本参考如下, 字段为: ID,文本及对应作者. 代码实战本节将使用Facebook开源的FastText进行模型模型训练与预测, FastText可用于学习语句分类与单词表征. 有关FastText安装, 请参考官方文档. 本文代码主逻辑参考如下: 12345678910111213141516171819202122232425262728293031// TRAIN_FILE: 训练集路径, 字符串常量// TEST_FILE: 测试集路径, 字符串常量// MODEL: 算法模型保存路径, 字符串常量// 以上参数也可考虑作为程序运行的传入参数传入const TRAIN_FILE: &amp;str = "./dataset/train.data";const TEST_FILE: &amp;str = "./dataset/test.data";const MODEL: &amp;str = "./dataset/model.bin";fn main() -&gt; Result&lt;(), Box&lt;Error&gt;&gt; &#123; let args: Vec&lt;String&gt; = env::args().collect(); // 数据集输入路径 let path = &amp;args[1]; // 首先, 进行数据解析与抽取 let data = extract_data(&amp;path).unwrap(); // 然后, 按照经典的Cross Validation思想进行迭代训练 // 对数据集进行分割, 主要分割为训练集与测试集 let (test_data, train_data) = data_splitter(&amp;data, 0.2); // 建议将训练集与测试集写文件(或者使用缓存), 一为容错, 二是方便后续迭代 write_training_data(&amp;train_data.to_owned(), TRAIN_FILE)?; write_test_data(&amp;test_data.to_owned(), TEST_FILE)?; // 利用FastText进行算法训练 let mut ftxt_model = FastText::new(); model_training(TRAIN_FILE, &amp;mut ftxt_model); // 算法效果评估, 打印准确率(主要评估指标) check_accuracy(&amp;test_data, &amp;ftxt_model); ftxt_model.save_model(MODEL)?; Ok(())&#125; 完整代码, 请参考这里. 下面细分步骤进行说明, 对代码进行分解. 添加依赖首先新建一Rust项目, 参考指令如下: 1$ cargo new fbtext --bin 进入该项目主目录, 在Cargo.toml中添加以下依赖: 12345678910[dependencies]csv = "1.0.7"serde = "1"serde_derive = "1"rand = "0.6.5"fasttext = "0.4.1"stopwords = "0.1.0"vtext = "0.1.0-alpha.1"rust-stemmers = "1.1.0"itertools = "0.8.0" 以上Crates中, fasttext为Facebook开源FastText的Rust封装, serde与serde_derive处理数据序列化与反序列化, csv用于解析文本数据集, rand主要用于数据混排, vtext用于进行分词, stopwords主要用于移除停词(Stop Words), rust-stemmers主要用于对单词进行Stemming. 数据抽取数据解析与抽取代码, 参考如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465fn extract_data(path: &amp;String) -&gt; Result&lt;Vec&lt;SpookyAuthor&gt;, Box&lt;Error&gt;&gt; &#123; let mut rdr = csv::Reader::from_path(path)?; let mut data = Vec::new(); for record in rdr.deserialize() &#123; let rec: SpookyAuthor = record?; data.push(rec); &#125; // 对数据进行混排 data.shuffle(&amp;mut thread_rng()); Ok(data)&#125;//定义结构体`SpookyAuthor`, 该ADT(抽象数据类型或代数数据类型)主要对待训练数据集进行封装// 字段包括: ID, 文本, 对应小说作者#[derive(Debug, Deserialize, Clone)]struct SpookyAuthor &#123; id: String, text: String, author: String&#125;impl SpookyAuthor &#123; // 抽取标签(本例为对应小说作者) fn extract_labels(&amp;self) -&gt; String &#123; match self.author.as_str() &#123; "EAP" =&gt; "__label__EAP".to_owned(), "HPL" =&gt; "__label__HPL".to_owned(), "MWS" =&gt; "__label__MWS".to_owned(), l =&gt; panic!( "Not able to parse the target string. \ Got something else: &#123;:?&#125;", l) &#125; &#125; // 抽取Token文本, 即对文本进行分词、Stem、移除停词 pub fn extract_tokens(&amp;self) -&gt; String &#123; let text_lowercase = self.text.to_lowercase(); // Tokenize 分词 let tokenizer = VTextTokenizerParams::default().lang("en").build().unwrap(); let tokens: Vec&lt;&amp;str&gt; = tokenizer.tokenize(text_lowercase.as_str()) .collect(); // Stemming let stemmer = Stemmer::create(Algorithm::English); let tokens: Vec&lt;String&gt; = tokens.iter() .map(|tok| stemmer.stem(tok).into_owned()) .collect(); let mut tokens: Vec&lt;&amp;str&gt; = tokens.iter() .map(|tok| tok.as_str()) .collect(); // 移除停词(Stop Words) let stop_words: HashSet&lt;_&gt; = Spark::stopwords(Language::English) .unwrap() .iter() .collect(); tokens.retain(|tok| !stop_words.contains(tok)); tokens.iter().join(" ") &#125;&#125; 数据集切分数据抽取完毕, 下面进行数据集分割, 主要分为训练集与测试集,代码参考如下: 1234567fn data_splitter(data: &amp;[SpookyAuthor], test_size: f32) -&gt; (Vec&lt;SpookyAuthor&gt;, Vec&lt;SpookyAuthor&gt;) &#123; let test_size: f32 = data.len() as f32 * test_size; let test_size = test_size.round() as usize; let (test_data, train_data) = data.split_at(test_size); (test_data.to_vec(), train_data.to_vec())&#125; 将训练集与测试集写文件(或者使用缓存), 主要有两点: 一是为了容错, 二是方便后续迭代训练, 代码参考如下: 12345678910111213141516171819// 将标签和文本写入训练集fn write_training_data(train_data: &amp;[SpookyAuthor], file_name: &amp;str) -&gt; Result&lt;(), Box&lt;Error&gt;&gt; &#123; let mut file = File::create(file_name)?; for item in train_data &#123; writeln!(file, "&#123;&#125; &#123;&#125;", item.extract_labels(), item.extract_tokens())?; &#125; Ok(())&#125;// 将文本写入测试集fn write_test_data(test_data: &amp;[SpookyAuthor], file_name: &amp;str) -&gt; Result&lt;(), Box&lt;Error&gt;&gt; &#123; let mut file = File::create(file_name)?; for item in test_data &#123; writeln!(file, "&#123;&#125;", item.extract_tokens())?; &#125; Ok(())&#125; 训练集, 样本数据参考如下: 测试集, 样本数据参考如下: 模型训练利用FastText进行模型训练, 用于语句分类, 代码主逻辑参考如下: 12345678910fn model_training(train_file: &amp;str, ftxt_model: &amp;mut FastText) &#123; // 算法参数设置 let mut args = Args::new(); args.set_input(train_file); args.set_model(ModelName::SUP); // 设置损失函数, 本例为Softmax args.set_loss(LossName::SOFTMAX); // 算法训练 ftxt_model.train(&amp;args).unwrap();&#125; 算法评估对训练模型进行算法评估, 打印出准确率(主要评估指标), 代码参考如下: 123456789101112131415161718192021222324252627fn check_accuracy(data: &amp;[SpookyAuthor], model: &amp;FastText) &#123; let total_hits = data.len(); let mut predictions = vec![]; let mut labels = vec![]; for td in data &#123; let label = td.extract_labels(); let pred: Result&lt;Vec&lt;Prediction&gt;, String&gt; = model.predict(td.text.as_str(), 1, 0.0); predictions.push(pred.unwrap()); labels.push(label); &#125; let mut hits = 0; let mut correct_hits = 0; for (pred, lbl) in predictions.iter().zip(labels) &#123; let pred = &amp;pred[0]; if pred.clone().label == lbl &#123; correct_hits += 1; &#125; hits += 1; &#125; println!("accuracy=&#123;&#125; (&#123;&#125;/&#123;&#125;) correct", correct_hits as f32 / hits as f32, correct_hits, total_hits );&#125; 效果检测运行上面代码, 效果参考如下: 可以看到算法准确率为仅为50%左右, 存在改进空间, 主要原因在于数据集太小(整项数据集才4-5MB左右), 可学习的特征太少. 可以考虑扩充数据集, 适当增加文本特征, 提高算法质量. 下面查看下预测效果, 利用训练好的模型, 基于输入文本预测作者. (注意下面的Binary fasttext, 需编译安装, 具体步骤, 请参考Facebook FastText官方文档) 123$ ./fasttext predict ./dataset/model.bin - $ # 进入交互式文本输入, 文本输入完成后, 回车, 于下一行返回预测作者$ # 效果如下图所示, 基本预测准确]]></content>
      <categories>
        <category>Deep Learning &amp; Machine Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning &amp; Machine Learning</tag>
        <tag>Rust</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lightweight Rust Microservices Framework]]></title>
    <url>%2Frust%2Fmicrosrv%2F</url>
    <content type="text"><![CDATA[轻量级Rust微服务框架介绍与小结. Hyper Crate在Rust开发中比较常见, 特别是Rust微服务开发中, 本文将介绍以下几种轻量级的Rust微服务Crates: Rouille Nickle Rocket Gotham 其中, Rouille、Nickel和Rocket均为同步框架, Gotham为异步微服务框架, 常见的异步微服务Crates有: Hyper Actix/Actix-web Gotham (内部使用Hyper和Tokio俩大Crate进行开发) Gotham简单看个例子, 使用Gotham创建一个简单的HTTP Route服务, 首先看下HTTP句柄Handler, 主逻辑如下: 123456789101112131415161718192021222324252627282930use gotham::handler::IntoResponse;use gotham::state::State;macro_rules! generic_handler &#123; ($($t:ident),*) =&gt; &#123; $( pub fn $t(state: State) -&gt; (State, impl IntoResponse) &#123; (state, stringify!($t)) &#125; )+ &#125;&#125;generic_handler!(index);pub mod products &#123; use super::*; generic_handler!(index);&#125;pub mod bag &#123; use super::*; generic_handler!(index);&#125;pub mod checkout &#123; use super::*; pub mod address &#123; use super::*; generic_handler!(create, update, delete); &#125;&#125; HTTP Route主逻辑如下: 12345678910111213141516171819202122232425262728// HTTP对应Route// / --&gt; GET, HEAD// products --&gt; GET, HEAD// bag --&gt; GET// checkout/address --&gt; POST, PUT, PATCH, DELETEfn router() -&gt; Router &#123; build_simple_router(|route| &#123; route .request(vec![Method::GET, Method::HEAD], "/") .to(index); route.get_or_head("/products").to(products::index); route.get("/bag").to(bag::index); route .post("/checkout/address") .to(checkout::address::create); route.put("/checkout/address").to(checkout::address::update); route .patch("/checkout/address") .to(checkout::address::update); route .delete("/checkout/address") .to(checkout::address::delete); &#125;)&#125; 开启Route服务: 12345pub fn main() &#123; let addr = "127.0.0.1:7878"; println!("Listening for requests at http://&#123;&#125;", addr); gotham::start(addr, router())&#125; 服务效果检测如下: RouilleRouille框架主要围绕router!该Macros构建, 路径和方法声明简单、实用, 其Routing声明与Hyper有些类似, 但更加简洁. Routile本身提够了很多实用的同步API, 每个请求均由线程池中线程处理. 同样看个简单例子, 编写一个简单的WebSocket服务, 将用户输入打印并在服务端记录, 代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#[macro_use]extern crate rouille;use std::thread;use rouille::websocket;use rouille::Response;fn main() &#123; println!("Now listening on localhost:8000"); rouille::start_server("localhost:8000", move |request| &#123; router!(request, (GET) (/) =&gt; &#123; // 本例仅为示例代码, 实际生产环境中需自行设计好Render页面逻辑 Response::html("&lt;script type=\"text/javascript\"&gt; var socket = new WebSocket(\"ws://localhost:8000/ws\", \"echo\"); function send(data) &#123;&#123; socket.send(data); &#125;&#125; socket.onmessage = function(event) &#123;&#123; document.getElementById('result').innerHTML += event.data + '&lt;br /&gt;'; &#125;&#125; &lt;/script&gt; &lt;p&gt;This example sends back everything you send to the server.&lt;/p&gt; &lt;p&gt;&lt;form onsubmit=\"send(document.getElementById('msg').value); return false;\"&gt; &lt;input type=\"text\" id=\"msg\" /&gt; &lt;button type=\"submit\"&gt;Send&lt;/button&gt; &lt;/form&gt;&lt;/p&gt; &lt;p&gt;Received: &lt;/p&gt; &lt;p id=\"result\"&gt;&lt;/p&gt;") &#125;, (GET) (/ws) =&gt; &#123; let (response, websocket) = try_or_400!(websocket::start(&amp;request, Some("echo"))); thread::spawn(move || &#123; let ws = websocket.recv().unwrap(); websocket_handling_thread(ws); &#125;); response &#125;, _ =&gt; rouille::Response::empty_404() ) &#125;);&#125;fn websocket_handling_thread(mut websocket: websocket::Websocket) &#123; while let Some(message) = websocket.next() &#123; match message &#123; websocket::Message::Text(txt) =&gt; &#123; println!("received &#123;:?&#125; from a websocket", txt); websocket.send_text(&amp;txt).unwrap(); &#125;, websocket::Message::Binary(_) =&gt; &#123; println!("received binary from a websocket"); &#125;, &#125; &#125;&#125; 服务效果检测如下: NickelNickel使用简单, 该框架主要受JS框架Express的影响, 非异步框架. 看个简单例子, 使用Nickel构建一个简单的模板渲染服务, 假定需要Rendering的模板如下: 1234567&lt;html&gt; &lt;body&gt; &lt;h1&gt; Bonjour &#123;&#123; name &#125;&#125;! &lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; Rendering服务逻辑如下: 1234567891011121314151617#[macro_use] extern crate nickel;use std::collections::HashMap;use nickel::&#123;Nickel, HttpRouter&#125;;fn main() &#123; let mut server = Nickel::new(); server.get("/", middleware! &#123; |_, response| let mut data = HashMap::new(); data.insert("name", "Deep Insight"); return response.render("assets/template.tpl", &amp;data); &#125;); server.listen("127.0.0.1:6767");&#125; 服务效果检测如下: RocketRocket充分利用Nightly Rust编译器特性, 将一系列Rust函数转变为一个完备的Web服务框架. Rocket通过环境变量和日志充当应用配置, 好处在于下次迭代时可以免去日志和配置代码编写, 坏处在于使后期调优和维护变得困难. Rocket在Rust社区曝光度较高, 以下是一段有关Rocket中MsgPack使用的示例代码: 1234567891011121314151617181920212223242526272829303132#![feature(proc_macro_hygiene)]#[macro_use] extern crate rocket;#[macro_use] extern crate serde_derive;#[cfg(test)] mod tests;use rocket_contrib::msgpack::MsgPack;#[derive(Serialize, Deserialize)]struct Message&lt;'r&gt; &#123; id: usize, contents: &amp;'r str&#125;#[get("/&lt;id&gt;", format = "msgpack")]fn get(id: usize) -&gt; MsgPack&lt;Message&lt;'static&gt;&gt; &#123; MsgPack(Message &#123; id: id, contents: "Hello, world!", &#125;)&#125;#[post("/", data = "&lt;data&gt;", format = "msgpack")]fn create(data: MsgPack&lt;Message&lt;'_&gt;&gt;) -&gt; String &#123; data.contents.to_string()&#125;fn rocket() -&gt; rocket::Rocket &#123; rocket::ignite().mount("/message", routes![get, create])&#125;fn main() &#123; rocket().launch();&#125; 测试代码如下: 12345678910111213141516171819202122232425262728293031323334use crate::rocket;use rocket::local::Client;use rocket::http::&#123;Status, ContentType&#125;;#[derive(Serialize, Deserialize)]struct Message &#123; id: usize, contents: String&#125;#[test]fn msgpack_get() &#123; let client = Client::new(rocket()).unwrap(); let mut res = client.get("/message/1").header(ContentType::MsgPack).dispatch(); assert_eq!(res.status(), Status::Ok); assert_eq!(res.content_type(), Some(ContentType::MsgPack)); // 消息为 `[1, "Hello, world!"]` assert_eq!(&amp;res.body_bytes().unwrap(), &amp;[146, 1, 173, 72, 101, 108, 108, 111, 44, 32, 119, 111, 114, 108, 100, 33]);&#125;#[test]fn msgpack_post() &#123; // 消息为 `[2, "Goodbye, world!"]`. let client = Client::new(rocket()).unwrap(); let mut res = client.post("/message") .header(ContentType::MsgPack) .body(&amp;[146, 2, 175, 71, 111, 111, 100, 98, 121, 101, 44, 32, 119, 111, 114, 108, 100, 33]) .dispatch(); assert_eq!(res.status(), Status::Ok); assert_eq!(res.body_string(), Some("Goodbye, world!".into()));&#125; 如下图所示, 测试通过:]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Microservices</tag>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Rust语言对Python加速]]></title>
    <url>%2Frust%2Fpyo3%2F</url>
    <content type="text"><![CDATA[本文将教你如何使用Rust语言对Python加速. 一直以来, Python都是LLVM生态的重度依赖者, 比如高性能的Numpy、OpenCV、甚至是Tensorflow等, 底层实现为均为C或C++, Python Binding在手, 代码”瞬间溜得飞起”. Why Rust问题来了, 为何不Pythonic点, 使用C或C++语言对Python加速即可. 而且Python本身有个CPython版本, 再不济也可考虑使用CPython, 当然也可考虑Pypy. 但是, CPython存在GIL(全局解释锁), 在并行性实现方面存在困难; Pypy虽好, 但生态方面比不及CPython, 有些Python包可能需要重写, 并不能直接使用. 至于C或C++语言加Python binding, 很不错, 毕竟Python社区也是这么过来的. 话说, 有没有考虑过以下几点: 系统安全性问题, Unsafe一直是C或C++语言”广为诟病”的问题, 毕竟有很多底层漏洞就是由于C或C++语言Unsafe导致 内存管理, C或C++语言没有自动垃圾回收机制, 需要手动进行内存管理, 作为C++或C语言开发者, 无疑是件很痛苦的事儿 面向过程、指令式思考, 面向过程思考问题很痛苦, 所以才有了OOP面向对象的兴起, 虽然C++也有OOP, 但C++复杂的语法一直”令人诟病” Rust语言, 类型安全、效率高, 一直是不少攻城狮心中完美的”C++”. So, Why not Rust ? PyO3简介PyO3开始作为rust-cpython的fork出现, 后来由于rust-cpython缺乏维护, PyO3开始在Rust社区流行, 现在PyO3与rust-cpython差别逐步扩大. 通过PyO3, 可以使用Rust语言对Python加速, 或者说可自行开发高性能的Rust程序, 然后通过PyO3导出, 以包的形式与其他Python代码交互, 由于导出包使用Rust语言开发, 在运行效率及性能上基本”完爆”同等Python实现模块. PyO3实战小测试下面, 看个小例子, 假定有这样一个需求: 有一堆字符串(假定可以逗号分割, 如”Letter,Kelly,Hope”等), 从中找出与给定前缀(如”Le”)匹配的单词列表. 很简单, 对不? 几行Python就可以搞定: 1234567def find_prefix_matched_words(text, prefix): ret = [] for w in text.split(","): w = w.strip() if w.startswith(prefix): ret.append(w) return ret 添加依赖以此为例, 说明如何使用PyO3. 首先, 新建测试项目并创建Python虚拟环境(建议使用Python虚拟环境, 对正常开发的Python环境影响少; 或者将Rust源码编译后的.so包放到Python模块中) 123456$ # 新建Rust测试项目$ cargo new prefix_case --lib$ # 创建Python虚拟环境$ virtualenv -p /usr/bin/python3.6 prefix_test$ # 启用Python虚拟环境$ source prefix_test/bin/activate 添加PyO3依赖, 在测试项目目录下的Cargo.toml中添加以下代码(PyO3版本可自行选择, lib中name可随意): 1234567[dependencies.pyo3]version = "0.8.1"features = ["extension-module"][lib]name = "words_prefix"crate-type = ["cdylib"] Rust编码实战对prefix_case/src/lib.rs进行Rust编码, 实现上面需求主逻辑: 12345678910111213141516171819202122232425262728use pyo3::prelude::*;use pyo3::wrap_pyfunction;#[pymodule]fn words_prefix(_py: Python, module: &amp;PyModule) -&gt; PyResult&lt;()&gt; &#123; module.add_wrapped(wrap_pyfunction!(find_prefix))?; Ok(())&#125;#[pyfunction]fn find_prefix(src: &amp;str, prefix: &amp;str) -&gt; PyResult&lt;Vec&lt;String&gt;&gt; &#123; let mut v = vec![]; let matched = src.split(",").filter_map(|s| &#123; let trimmed = s.trim(); if trimmed.starts_with(&amp;prefix) &#123; Some(trimmed.to_owned()) &#125; else &#123; None &#125; &#125;); for s in matched &#123; v.push(s); &#125; Ok(v) &#125; 逻辑很简单, 接下来要做的是将上述Rust代码导出为Python模块. 导出这里使用Maturin(旧称为pyo3-pack, 可以将PyO3、rust-cpython、CFFI binding或者含Rust binary的Crates编译打包并发布为Python包), 利用该工具将编译好的Rust代码发布至PyPI(Python Package Index), 安装Maturin命令如下: 1$ cargo install maturin 使用Maturin将上述Rust源码编译导出为Python模块, 1$ cd prefix_case &amp;&amp; maturin develop 脚本测试现在可以使用 words_prefix 模块了, 可在prefix_case目录下新建一个Python测试脚本, 测试脚本内容如下: 12345678910import words_prefix as pdef main(): words = "Letter,Kelly,Let,Hope,Leisly,Lopez" prefix = "Le" words_matched = p.find_prefix(words, prefix) print('The list of words: &#123;&#125; match the prefix - &#123;&#125;'.format(words_matched, prefix))if __name__ == '__main__': main() 效果 测试脚本运行无误, 导出模块能与Python代码正常交互.]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Rust</tag>
        <tag>PyO3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二十行代码轻松搞定人脸识别]]></title>
    <url>%2Fdl%2Ffrecg%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <categories>
        <category>Deep Learning &amp; Machine Learning</category>
      </categories>
      <tags>
        <tag>Computer Vision</tag>
        <tag>Python</tag>
        <tag>Face Recognition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang构造器注入初体验]]></title>
    <url>%2Fgo%2Fdependency-injection%2F</url>
    <content type="text"><![CDATA[依赖注入的目的是为了更好地进行解耦, 减少各模块间的耦合. 构造器注入作为依赖注入的一种表现方式, 有助于提升Golang代码的简洁性. 本文将简单介绍Golang中的构造器注入. 构造器注入问题来了, 什么是构造器注入? 假定存在以下一段业务代码: 123456789101112131415161718192021222324type WelcomeSender struct &#123; mailer *Mailer&#125;func (w *WelcomeSender) Send(to string) error &#123; body := w.buildMessage() return w.mailer.Send(to, body)&#125;func NewWelcomeSender(in *Mailer) (*WelcomeSender, error) &#123; if in = nil &#123; return nil, errors.New("We've encountered an error: mailer must be provided") &#125; sender := &amp;WelcomeSender&#123; mailer: in, &#125; return sender, nil&#125;func NewWelcomeSenderNoGuard(in *Mailer) *WelcomeSender &#123; return &amp;WelcomeSender&#123; mailer: in, &#125;&#125; 现在使用依赖注入进行解耦, 代码参考如下: 12345678910111213141516type Mailer struct &#123; Host string Port string Username string Password string&#125;func (m *Mailer) Send(to string, body string) error &#123; // Do Some Work Here return nil&#125;func (m *Mailer) Receive(address string) (string, error) &#123; // Do Some Work Here return "", nil&#125; 或者使用接口封装 1234567891011121314type MailerInterface interface &#123; Send(to string, body string) error Receive(address string) (string, error)&#125;// 如果只需发送邮件, 可以封装为发送接口type Sender interface &#123; Send(to string, body string) error&#125;func NewWelcomeSenderVersionTwo(in Sender) *WelcomeSenderVersionTwo &#123; return &amp;WelcomeSenderVersionTwo &#123; sender: in, &#125;&#125; 这样做的好处有: 代码自包含, 意味着如果代码存在任何Bug或其他变更仅影响该包 不再绑定于Mailer结构, 如果想更改Welcome Email为SMS, 只需将输入参数改为不同的Sender即可 方便测试, 无需工作邮箱服务器进行测试 结构类型Golang可支持鸭子类型(Duck Type), 但也存在以下几点问题: 对于鸭子类型(Duck Type), Runtime的兼容性是确定的; 但Golang在编译时进行检测. 对于鸭子类型(Duck Type)而言, 适用性基于被访问对象. 对于Golang而言, 这种类似于Duck Typing的注入也称结构类型(比如Scala, JavaScript等语言均支持结构类型). 结构类型作为一种动态类型系统, 基于类型结构在编译时确定适用性. 构造器注入好处 简洁可预测, 通过将依赖分配移到构造器, 可确保依赖在方法中可用. 比如将守卫(Guard)放到构造器中, 如果没有构造器, 每项方法不得不包含守卫(Guard), 否则将抛出空指针异常, 比如下面这段代码 123456789101112131415161718192021type Vehicle struct &#123; Engine Engine&#125;func (v *Vehicle) Run() error &#123; if v.Engine == nil &#123; return errors.New("Engine must be supplied") &#125; v.Engine.Start() v.Engine.MaximizePower() return nil&#125;func (v *Vehicle) Stop() error &#123; if v.Engine == nil &#123; return errors.New("Engine must be supplied") &#125; v.Engine.MinimizePower() v.Engine.Stop() return nil&#125; 将守卫(Guard)置于构造器中, 代码更简洁 123456789101112131415161718192021222324type Vehicle struct &#123; engine Engine&#125;func NewVehicle(engine Engine) (*Vehicle, error) &#123; if engine == nil &#123; return nil, errors.New("No Engine Supplied") &#125; return &amp;Vehicle&#123; engine: engine &#125;, nil&#125;func (v *Vehicle) Run() error &#123; v.Engine.Start() v.Engine.MaximizePower() return nil&#125;func (v *Vehicle) Stop() error &#123; v.Engine.MinimizePower() v.Engine.Stop() return nil&#125; 此外, 还有一个好处在于访问构造器依赖时没有数据争用(Data Race)问题. 因为构造器在构造阶段已经设定好,并不会变更. 封装, 简单举个例子, 假定存在以下方法 12345678// 不使用构造器注入, 实现机车加油方法func (v *Vehicle) FillIn(engine Engine) error &#123; if engine.IsRunning() &#123; return errors.New("Can't fill the tank while the engine is running") &#125; // 具体加油逻辑 return v.fill()&#125; 该方法暴露了实现细节, 如要求提供Engine参数. 可以通过构造器依赖进行封装 1234567func (v *Vehicle) FillIn() error &#123; if v.engine.IsRunning() &#123; return errors.New("Can't fill the tank while the engine is running") &#125; // 具体加油逻辑 return v.fill()&#125; 解耦, 有助于模块解耦 有助于进行代码质量检测, 根据单一责任链原则, 宜将对象或接口分解成足够细小部分. 如果单个对象或接口的依赖或责任链太多, 代码日趋复杂, 假定构造器中依赖过多, 容易产生代码质量问题. 易于实现]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>Dependency Injection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang负载测试手札]]></title>
    <url>%2Fgo%2Fprofile%2F</url>
    <content type="text"><![CDATA[本文将使用pprof及开源的Benchmark工具Apache Bench对Golang进行Http服务负载测试. 工具包安装测试前需安装Apache Bench, 安装指令, 参考如下: 1$ apt-get install apache2-utils 测试代码Http服务负载测试代码, 参考如下: 12345678910111213141516171819202122232425// 假定源代码名为 prof.goimport ( "fmt" "io" "net/http" _ "net/http/pprof" "time")func main() &#123; Handler := func(w http.ResponseWriter, req *http.Request) &#123; waitForSomeWork(5) waitForSomeWork(10) io.WriteString(w, "Memory Management Test") &#125; http.HandleFunc("/", Handler) http.ListenAndServe(":1234", nil)&#125;func waitForSomeWork(timeDuration int) &#123; // 以休眠模拟需要等待的业务逻辑 time.Sleep(time.Duration(timeDuration) * time.Millisecond) fmt.Println("Sleep for ", timeDuration, "Milliseconds")&#125; 运行首先, 运行代码: 12$ # 假定以上代码, 文件名为 prof.go$ go run prof.go &amp; 生成Profile所需的Dump文件 1$ curl -s "localhost:1234/debug/pprof/profile?seconds=10" &gt; out.dump 使用Apache Bench进行负载测试(5000次请求, 并发度为10) 1ab -n 5000 -c 10 http://localhost:1234/ 利用生成的Dump文件, 进行Profile 12345$ go tool pprof out.dump$ # pprof(pprof) top10 # 查看TopN 样本(pprof) top10 -cum # 以累计值降序(pprof) ## 更多指令略]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSD与ResNet大法实战人脸检测]]></title>
    <url>%2Fdl%2Ffdtct%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <categories>
        <category>Deep Learning &amp; Machine Learning</category>
      </categories>
      <tags>
        <tag>Face Detection</tag>
        <tag>Computer Vision</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSD大法实战车辆检测]]></title>
    <url>%2Fdl%2Fvdtct%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <categories>
        <category>Deep Learning &amp; Machine Learning</category>
      </categories>
      <tags>
        <tag>Computer Vision</tag>
        <tag>Python</tag>
        <tag>Vehicle Detection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes API初探(二)]]></title>
    <url>%2Fcontainer%2Fk8s%2Fapisrv%2F</url>
    <content type="text"><![CDATA[Kubernetes API初探, Kubernetes API相关概念、API Server内部工作机制、如何通过命令行与API进行交互等. API Server如下图所示, Kubernetes主要由不同节点、不同角色组成: 主节点控制平面包含API Server、控制管理器及调度器, API Server作为控制管理实体, 可与分布式存储组件etcd直接交互. API Server主要负责Kubernetes API状态变更、读取, 如处理Worker节点、Kubernetes Native应用或外部客户端状态请求等; API Server也可充当集群代理组件, 如充当Kubernetes Dashboard、流式日志、服务端口代理或服务kubectl exec回话等. 通常, 状态通过etcd进行持久化, API Server充当Kubernetes核心部分. HTTP 接口API Server通过JSON或Protobuf暴露RESTFUL HTTP服务, JSON或Protobuf主要进行集群内部通信, 可通过以下HTTP谓词查询或修改Kubernetes资源: HTTP GET, 获取特定资源(如特定Pod)数据或资源列表集(如某个命令空间下的所有Pod) HTTP POST, 创建资源, 如部署服务 HTTP PUT, 更新已有资源, 如改变Pod容器镜像 HTTP DELETE, 销毁资源, 不可恢复 HTTP PATCH, 部分更新已有资源 示例如下: 12$ kubectl -n NAMESPACE get pods ## NAMESPACE替换具体命名空间$ GET /api/v1/namespaces/&#123;YOUR-NAMESPACE&#125;/pods ## 与上面指令等效, 注意替换YOUR-NAMESPACE为具体命名空间 Kubernetes API版本控制Kubernetes支持API多版本控制, 以不同API路径形式如/api/v1 或/apis/extensions/v1beta2等, 便于拓展, 不同的API版本意味着不同级别的稳定性支持: Alpha级别, (如v1alpha2), 默认禁用, 适用于短期测试群集中使用, 适用于可能在任意时候删除的特征 Beta级别, (如v2beta3), 默认启用, 意味着代码经过了充分测试, 但对象的语义可能会在后续版本中发生改变, 可能会出现不兼容情况 Stable级别, (如v1), 存在于后续发布的软件版本 当然, API Server也存在其它类型的HTTP路径, 如非资源对齐的路径：群集范围实体, 如/metrics,/logs或/healthz. 此外, API Server支持监视, 如可以通过在某些请求中添加?watch=true将API Server改为监视模式, 而非按设定时间间隔进行资源轮询. 声明式状态管理大多数API对象区分了所需的资源状态规范和当前时对象的状态,状态规范是对资源期望状态的完整描述,且通常持久于稳定存储如etcd中. 值得注意的一点是, 某些Kubernetes发行版产品,如k3s或微软的AKS,已经取代了etcd或考虑使用其他存储替换etcd. 下面简单聊下Kubernetes声明式状态管理—即声明期望状态, 并让Kubernetes处理其余一切(Handle the rest). 状态规范描述了期望的资源状态,可通过命令行工具(如kubectl)或通过Golang代码实现.Status描述了资源的观测状态或实际状态,并由控制平面管理,可由核心组件(如控制器管理器)或自定义控制器管理.例如,在部署中,指定期望运行20个应用程序副本.部署控制器作为控制平面中控制器管理器的一部分,可读取部署规范并创建一个副本集,然后负责管理副本：通过创建相应数量的Pod,最终(通过kubelet)在工作节点上启动容器.如果任一副本失败,部署控制器反馈状态. API Terminology回顾下上篇博文, Kubernetes API Server上下文Context经常看到Kind、API Group、版本Version及Resources资源等相关数据, 下面简单聊下这些Context数据. 如下图所示, Resources通常作为GroupVersionResouce(GVR)中的一部分, 集群范围资源如节点或命名空间本身路径中没有$NAMESPACE部分, 如节点(nodes)GVR: /api/v1/nodes; 与GVR类似, Kind存在于每项API Group,是GroupVersionKind(GVK)中的一部分. GVK与GVR存在关联, GVK通过GVR标识的HTTP路径进行识别, 通过REST映射将GVK映射成GVR. Kind实体类型, Kind对应于Golang中type, 每个对象都有一个字段Kind(JSON中的小写,Golang中大写),该字段代表一个Pod.Kind有以下三种: 系统中持久实体对象,如Pod或Endpoints端点, 这些对象具有名称,存在于命名空间中. 一种或多种实体集合列表, 这些列表具有有限的公共元数据集. 示例如PodLists或NodeLists. 对对象和非持久实体(如/binding或/scale)进行特定操作的特殊目的类型. 如Kubernetes使用APIGroup和APIResource进行Discovery; 对于错误结果, 使用Status. 同名的Kind不仅可以在不同版本中共存,还可以在不同的API Group中共存, 如Deployment, 刚开始在扩展组中为alpha kind,最终在apps.k8s.io组中升级为稳定版本, 这种现象称之为同居(Cohabitation). 虽然在Kubernetes中不常见,但也存在, 如: extensions和networking.k8s.io中的Ingress和NetworkPolicy apps和extensions中的DaemonSet,ReplicaSet 核心组和events.k8s.io中的Event API GroupKinds集合通常逻辑相关, 所有batch对象如Job或ScheduledJob均存在于Batch API组中. Version每个API组可以存在多个版本,如一组API首先存在于v1alpha1,然后v1beta1,最后v1, 可以在每个支持的版本中检索在给定版本中创建的对象. API Server执行无损转换并返回所请求版本中的对象. 从集群用户的角度来看,版本只是相同对象的不同表示. Resources通常由一系列HTTP端点(或路径)暴露CRUD(Create/Read/Update/Delete)操作语义, 通常路径包含: root, 如…/pods, 列出该类型的所有实例 各个命名资源的路径,例如…/pods/nginx 通常,这些端点中的每一个都返回并接收一Kind(第一种情况下为PodList,第二种情况下为Pod).但在其他情况下(如errors),将返回Status Kind.除了具有完整CRUD语义外,资源还可以由其他端点来执行特定操作(如…/pod/nginx/port-forward, …/pod/nginx/exec, 或…/pod/nginx/logs).这些也称子资源,通常实现自定义协议而非REST, 如通过WebSockets或指令式API进行流式连接等. Resources(资源)与Kinds(类别)区别如下: Resources对应HTTP路径 Kinds通常由端点或etcd中返回或接收的类型对象 API SPACE]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>Kubernetes API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes API初探(一)]]></title>
    <url>%2Fcontainer%2Fk8s%2Fapi-intro%2F</url>
    <content type="text"><![CDATA[Kubernetes API初探, Kubernetes API相关概念、API Server内部工作机制、如何通过命令行与API进行交互等. 命令行初探一般从接触Kubernetes开始, 最先上手的毫无疑问, CLI命令行工具, 从最初的Docker CLI到Kubernetes CLI, “键入指令, 字符跳动”. 1234567891011121314151617181920212223$ # 获取 CoreDNS相关状态信息$ kubectl -n kube-system get deploy/coredns -o=yamlapiVersion: apps/v1kind: Deploymentmetadata: name: coredns namespace: kube-system # 其它细节略spec: # 容器镜像等特性 template: spec: containers: - name: coredns image: SPECIFIC-ECR-HOST.amazonaws.com/PATH-NAME/coredns:VERSION-NUMBER # 其它细节略status: replicas: 2 # 并行运行副本数 conditions: - type: Available status: "True" lastUpdateTime: "2016-01-21T20:42:10Z" # 其它细节略 以下CLI在本机8080端口开启代理并处理验证, 允许通过HTTP直接发出请求并接收返回的JSON负载 12345678910111213141516171819202122232425262728293031323334353637383940414243$ kubectl proxy --port=8080Starting to serve on 127.0.0.1:8080$ # 开启另一终端, 键入以下指令 或 kubectl get --raw /apis/batch/v1$ curl http://127.0.0.1:8080/apis/batch/v1# 返回Kind、API版本、Group版本及Resources&#123; "kind": "APIResourceList", "apiVersion": "v1", "groupVersion": "batch/v1", "resources": [ &#123; "name": "jobs", "singularName": "", "namespaced": true, "kind": "Job", "verbs": [ "create", "delete", "deletecollection", "get", "list", "patch", "update", "watch" ], "categories": [ "all" ] &#125;, &#123; "name": "jobs/status", "singularName": "", "namespaced": true, "kind": "Job", "verbs": [ "get", "patch", "update" ] &#125; ]&#125; 查看集群支持的API资源, 如Kind、命令空间、API组别、缩略(ShortNames)等, 如下: 1234567891011121314151617181920212223$ kubectl api-resourcesNAME SHORTNAMES APIGROUP NAMESPACED KINDbindings true Bindingcomponentstatuses cs false ComponentStatusconfigmaps cm true ConfigMapendpoints ep true Endpointsevents ev true Eventlimitranges limits true LimitRangenamespaces ns false Namespacenodes no false Nodepersistentvolumeclaims pvc true PersistentVolumeClaimpersistentvolumes pv false PersistentVolumepods po true Podpodtemplates true PodTemplatereplicationcontrollers rc true ReplicationControllerresourcequotas quota true ResourceQuotasecrets true Secretserviceaccounts sa true ServiceAccountservices svc true Servicecontrollerrevisions apps true ControllerRevisiondaemonsets ds apps true DaemonSetdeployments deploy apps true Deployment 查看集群中不同资源版本 123456789101112131415161718192021222324252627282930313233$ kubectl api-versionsadmissionregistration.k8s.io/v1beta1apiextensions.k8s.io/v1beta1apiregistration.k8s.io/v1apiregistration.k8s.io/v1beta1appmesh.k8s.aws/v1alpha1appmesh.k8s.aws/v1beta1apps/v1apps/v1beta1apps/v1beta2authentication.k8s.io/v1authentication.k8s.io/v1beta1authorization.k8s.io/v1authorization.k8s.io/v1beta1autoscaling/v1autoscaling/v2beta1autoscaling/v2beta2batch/v1batch/v1beta1certificates.k8s.io/v1beta1coordination.k8s.io/v1beta1crd.k8s.amazonaws.com/v1alpha1events.k8s.io/v1beta1extensions/v1beta1networking.k8s.io/v1policy/v1beta1rbac.authorization.k8s.io/v1rbac.authorization.k8s.io/v1beta1scheduling.k8s.io/v1beta1storage.k8s.io/v1storage.k8s.io/v1beta1v1 API Server内部工作机制如下图所示, Kubernetes API Server处理请求过程如下: 首先, HTTP请求由一些列Filter处理, 这些Filter均向DefalutBuildHandlerChain()注册, 这些链起来的Filter详见k8s.io/apiserver/pkg/server/config.go. 对给定请求一些列Filter操作, 若请求通过则绑定对应上下文信息, 如ctx.RequestInfo; 若没通过Filter, 返回HTTP响应码表明原因 然后, 基于HTTP路径, 由k8s.io/apiserver/pkg/server/handler.go路由HTTP请求至对应的HTTP句柄(Handler) HTTP句柄Handler向API Group注册(详见k8s.io/apiserver/pkg/endpoints/groupversion.go及k8s.io/apiserver/pkg/endpoints/installer.go),需传入HTTP请求及上下文参数,从ectd存储中获取并传递请求对象. 传递通用的Handler Chain后, 开始处理实际请求, 执行请求句柄语义: 直接处理, 如处理/apis, /version, /healthz等其它非REST请求 REST资源请求, 传递给请求管道, 请求管道包含: 准入逻辑, 传入对象需经过admission chain, 该准入链允许存在多个准入插件, 每个准入插件既可以包含上图中的Mutating更改阶段, 也可以包含验证Validating阶段, 或俩者均有. 对于Mutating阶段, 可以改变传入的请求负载, 如基于准入配置图片拉取策略可以设置为Always、IfNotPresent或Never; 验证阶段, 如Pod安全验证、命令空间是否存在等. 验证逻辑, 检测传入对象, 如检测字符串格式是否符合服务命名规范, pod中容器名是否唯一等. 基于ectd的CRUD逻辑, 如更新逻辑: 从etcd读取对象, 检测到没有其它用户更改对象时, 执行写入请求对象至etcd. 源码剖析, DefalutBuildHandlerChain()中Filter Chain如下: 123456789101112131415func DefaultBuildHandlerChain(apiHandler http.Handler, c *Config) http.Handler &#123; h := WithAuthorization(apiHandler, c.Authorization.Authorizer, c.Serializer) h = WithMaxInFlightLimit(h, c.MaxRequestsInFlight, c.MaxMutatingRequestsInFlight, c.LongRunningFunc) h = WithImpersonation(h, c.Authorization.Authorizer, c.Serializer) h = WithAudit(h, c.AuditBackend, c.AuditPolicyChecker, LongRunningFunc) // 略去部分实现 ... h = WithAuthentication(h, c.Authentication.Authenticator, failed, ...) h = WithCORS(h, c.CorsAllowedOriginList, nil, nil, nil, "true") h = WithTimeoutForNonLongRunningRequests(h, LongRunningFunc, RequestTimeout) h = WithWaitGroup(h, c.LongRunningFunc, c.HandlerChainWaitGroup) h = WithRequestInfo(h, c.RequestInfoResolver) h = WithPanicRecovery(h) return h&#125; 所有相关包代码, 详见k8s.io/apiserver/pkg 方法 描述 WithPanicRecovery() 处理恢复及日志Panic, 详见server/filters/wrap.go WithRequestInfo() 绑定RequestInfo至Context, 详见endpoints/filters/requestinfo.go WithWaitGroup() Graceful shutdown, 增加非长时间运行请求至等待组, 详见server/filters/waitgroup.go WithCORS() 提供CORS跨域资源共享实现, 详见server/filters/cors.go WithAudit() 对所有传入请求进行日志审计,封装Handler, 审计日志包含请求源IP、用户操作调用、命令空间等, 详见admission/audit.go WithMaxInFlightLimit() In-flight Requests数量限制, 详见server/filters/maxinflight.go WithImpersonation() 通过检测请求处理用户假冒, 详见endpoints/filters/impersonation.go WithTimeoutForNonLongRunningRequests() 对于非长时间运行请求(如GET,PUT,POST,DELETE等请求)超时, 详见server/filters/timeout.go WithAuthentication() 验证用户请求并存储用户信息, 若验证成功移除Authorization HTTP头部, 若验证失败防护404HTTP状态码, 详见endpoints/filters/authentication.go WithAuthorization() 调用验证模块检测并将所有授权请求传递给多路复用器, 若用户权限不够返回403HTTP状态码, 详见endpoints/filters/authorization.go, 当然Kubernetes现在基于角色进行访问控制(Role-based Access Control)]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>Kubernetes API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于CSP与Actor的几点思考]]></title>
    <url>%2Flife%2Fcsp-actor%2F</url>
    <content type="text"><![CDATA[个人关于CSP和Actor的几点感想. Disclaimer 2019 - Update: 写这篇博文的初衷在于记录曾经的点滴感想, 本文的主要目的并非让你铭记”四大并行原语”, 也不是让你得出”问题解决方案的多样性, 答案并不唯一”(或许你上小学时就明白这个哲理)这种”无聊”的结论; 只是希望你看完后, 你能Get到:CSP与Actor模型的异同点Actor模型与CSP对比有何优点为何Golang语言可以绕过CSP的某些短板 (参考方式不限于文中所提三点, 比如某些Golang老手会告诉你Linux中的cgroup是个好东西) 四大并行原语, Actor与CSP的”前世今生”以下四大并行原语基本源自数学推导 π Calculus Actor原语 Join Calculus Ambient Calculus 具体可以参考这本书: π Calculus应用模型有CSP(顺序化通信进程, 本质上是个数学抽象, 表示多进程或单进程中多线程间通过消息传递进行通信), Actor原语对应Actor模型、Join Calculus对应Join算子模型. 目前, 这三大并行模型(CSP、Actor模型、Join算子模型)中, CSP是工业界最实用、最成功的模型(虽然CSP设计并不完美, 至少相对于Actor而言); Actor模型比较小众, Join算子模型(目前比较常见的实现语言有JoCaml, JoCaml是OCaml语言的一种方言, 从名称上可以看出其特点 Join Calculus + OCaml)、Ambient Calculus逐步边缘化. CSP模型常见于如Golang中的Go协程、管道Channel, Clojure语言中的core.async; Actor模型常见于如Erlang Pid/Process、JVM生态如Akka Actor等. Actor模型与CSP对比鉴于Join算子模型和Ambient Calculus已经边缘化, 仅对Actor模型和CSP模型进行对比, 如下: 相同点: 异步非阻塞、支持消息传递不同点: CSP中进行通信的进程或线程并不需要完全知晓对方, 意味着发送方和接收方解耦、但通过传递的值进行耦合. 消息传递方式存在区别, CSP中消息发送方和接收方对于消息什么时候发送、什么时候接收存在一种共识, 而非通过堆积消息队列进行读取方式. 这种消息通信方式也称Rendezvous Messaging, 消息聚会或会合消息. 与Actor相比, CSP容错性不佳. Actor具有灵活的Supervise监督机制、容错性好, 而CSP需要开发人员手动添加容错处理逻辑. 与Actor相比, CSP分布式拓展能力不强. 由于CSP使用Rendezvous Messaging, 意味着接收消息需要在Process间同步, 也正由于此限制了CSP的分布式拓展能力. CSP存在推断(Reasoning)难点，由于每个阶段, 每个线程(或进程)均有可能与其他线程(或进程)进行交互, 存在诊断难点; 而Actor模型存在Supervisor Tree(监督树), 诊断性、侦测性相对容易. Actor优点 分布式拓展能力佳，举个简单例子, Facebook的WhatsApp内核源码主要由Erlang Actor实现，而这款App日活已经过亿，由于Actor本身的拓展能力出色，该App后端核心服务运行于集群多个节点，轻松运行无压力. 具体可以参考WhatsApp核心开发人员在Youtube上做的技术分享. 高可用, 分布式系统本身涉及的问题复杂, 比如如何保证多节点数据一致性、如何进行异构节点通信、如何避免单点故障等. 而Actor模型天然的高可用特性使分布式设计变得简单, 比如工业界有关Erlang Actor大名鼎鼎的99.9999%(六个九)高可用定论. Actor模型高可用特性本质在于Actor本身比较灵活的Supervise监督机制, 当一个Actor Crash(崩溃)时, 可推选出一个新的Actor继续进行未完成的任务. 容错性好，在分布式系统中故障不可避免，当分布式应用Crash时，首先要解决的问题是恢复上线，其次才是进行日志排查、问题定位. Actor模型允许当其中一个Actor奔溃时自定义解决方案, 如禁止故障Escalate(扩散)呢, 还是推选新的Actor继续执行任务. 这一点有别于主流编程语言中的try-catch异常处理机制, 因为发生问题时应该考虑的是服务可用性而非打印出一堆异常日志. 增量迭代、持续交付性好, 你可能不希望更改一个产品功能时停止服务直到新代码部署成功, 这样很影响用户体验. 好的解决方案是服务解耦, 你希望这种迭代变化对用户的影响最小化. Actor模型允许你这样做, 老版本代码继续运行，直到新的服务代码成功部署, 而这种增量迭代对用户不明显,因为服务一直在运行没有中断过. 开发友好, Actor模型允许你以开发单机代码方式进行分布式系统开发, 大大降低了分布式系统开发难度. 与线程、同步、锁等Low-level并发模型相比, 更容易上手、便于理解. 生态, Rabbit MQ、CouchBase、Redis内核代码基本基于Erlang Actor, JVM生态方面如Apache Flink、Spark底层代码采用了Actor模型封装(这两大大数据组件均基于Akka进行二次开发, 如Flink依赖Akka Cluster进行通信、Spark利用Akka Actor进行主要逻辑抽象封装. Akka在JVM Actor模型应用方面一直做得很不错). 2018 - Update: Spark 2.X系列由于兼容性问题正式移除了Akka Actor依赖. Anyway, Spark也曾站在Akka的肩膀上”眺望过”. 成功==不完美?CSP大获成功, 意味着什么? 这个问题耐人寻味, 是因为CSP实用吗? 还是因为早期Actor模型(如Erlang Actor)与FP(函数式编程)深度捆绑, 从而限制了推广? 是工业早期硬件架构(如CPU设计)特别适合π Calculus与线程建模, 还是Actor原语本身比较超前? 工业生产与技术理论革新, 对立与统一, 很难评判哪个在前、哪个在后. Golang的成功, 有其本身语言特性(如比C简单、容易上手, 支持GC垃圾回收等)的因素, 也有CSP的功劳(如大大简化了Golang的并发编程). 至于CSP的分布式拓展痛点, 在Golang中已变得不再明显, 主要原因在于Docker(使用Golang开发)、Kubernetes等容器化技术的兴起. 可以换一种角度解读这种现象, 原本用于资源隔离、提高资源利用率的容器化技术, 俨然成为了一种分布式环境或云环境下的一种基础设施服务、一种”标配”, 如果这种基础设施不能解决分布式拓展问题, 分布式系统的意义在哪? 请勿曲解我的观点, 并不是说Golang应用无法分布式拓展, 但Golang仅靠CSP是无法成功的. 离开了类似于cgo等Golang与其它LLVM语言交互工具、仅靠Golang CSP是无法做到”成千上万”节点拓展(CSP分布式拓展能力不佳是不争的事实). 但, 这又怎样? 对Golang的流行有什么影响吗, 或者对Golang的分布式开发有什么影响吗? 没什么影响, 喜欢Golang的人照样喜欢, 特别是那些被C++虐惨的攻城狮. So, What’s The Point? 成功等于不完美? 问题解决方案的多样性, 特别是对于开发人员而言, 答案并不唯一. 不完美的CSP并没有限制Golang的流行, 相反, 正是由于CSP的简单实用, 大大助推了Golang的流行. 至于CSP分布式拓展能力不佳, 解决方案有多种: 第一, 可以通过Docker、Kubernetes等容器化技术, 充当基础设施服务, 转化问题; 第二, 与LLVM生态交互, 毕竟”再造轮子”是件痛苦的事情, 特别是面临快速开发迭代时; 第三, 自主开发, 如果操作系统底层开发经验丰富, CSP这点问题还是有解决方案的. 再比如Apache Storm, 主要核心代码采用Clojure开发, 早期的Storm吞吐量不高(与Spark等对比), 有人认为受限于Clojure函数式编程等一些特性, 其实主要原因还是受限于Clojure中的CSP模型. 后期, Nathan Marz(Storm作者), 采取了折中方式—采用JVM生态中大名鼎鼎的Disruptor框架提高吞吐量, 好处在于吞吐量确实上去了、缺点在于要牺牲一半内核提高吞吐. 阿里巴巴攻城狮们用Java重写了遍Storm源码, 于是才有了JStorm—国产Micro Batch微批流式处理组件. Clojure并不完美, 但JVM多年工业生态可以弥补其些许不足, 至少Apache Storm是个鲜活的例子. 换种角度看问题, 你将收获整个世界!]]></content>
      <categories>
        <category>Distributed System</category>
      </categories>
      <tags>
        <tag>CSP</tag>
        <tag>Actor</tag>
        <tag>Join Calculus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reptile算法初探]]></title>
    <url>%2Fdl%2Frptl%2F</url>
    <content type="text"><![CDATA[本文主要介绍Reptile相关概念及算法原理. Reptile算法简介OpenAI团队为改进MAML(Model Agnostic Meta Learning)算法,进而提出了Reptile算法, 与MAML算法相比, 该算法易于实现. 在MAML算法中,需求二阶导, 即梯度的梯度, 但这样一来的话任务计算效率很低, 为改进MAML算法, OpenAI团队提出了Reptile算法, 该算法对N个任务进行采样,并在每个采样任务上运行随机梯度下降(SGD)算法减少迭代次数,然后按照所有任务共有的方向更新模型参数.由于对每个任务执行的SGD迭代次数较少,因此不会直接计算损失的二阶导数. Reptile算法思想大体如下, 从满足分布 $T$ ~ $p(T)$ 任务中取样, 如T1、T2, 给定随机初始化参数 $\theta$ , 首先在任务T1上执行SGD算法、迭代n次得到最优参$\theta_1^{‘}$ , 在任务T2上同样执行SGD算法、迭代n次得到优化参数 $\theta_2^{‘}$ , 此时得到优化参数集: \theta^{'} = \{ \theta_1^{'}, \theta_2^{'} \} , 现在只需将模型参数 $\theta$ 朝着接近这些优化参数的方向移动即可, 如下: 具体做法, 首先计算随机初始化模型参数 $\theta$ 与优化参数集 $\theta^{'}$ 间距离 $D$ (该距离可使用欧式距离或其它距离指标), 求距离最小值或求解距离最小化问题: $Minimize_{\theta}E[\frac{1}{2} D(\theta, \theta^{'})^2]$ . 如何距离最小化, 可以考虑在距离 $\nabla_{\theta} E[\frac{1}{2} D(\theta, \theta^{'})^2]$ 上计算梯度, 即: $\theta = \theta - \epsilon \nabla_{\theta} E[\frac{1}{2} D(\theta, \theta^{'})^2]$ 计算完梯度后, 最终等式变成: $\theta = \theta + \epsilon (\theta^{'} - \theta) $ 小结下该算法, 首先在采样任务上执行SGD算法、迭代n次得到优化参数集$\theta^{'}$, 然后利用上面等式更新模型参数. MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], displayMath: [ ['$$','$$'], ["\\[","\\]"] ], processEscapes: true } }); Reptile算法原理Reptile算法可以线性化形式实现, 也可以以Batch形式实现, 对于线性化版本, 只需从任务分布中采样一个任务即可; 对于Batch版本而言, 需对批量任务采样以便找到最优参数. Reptile算法线性版本原理如下: 1. 给定任务T满足分布 $T$ ~ $p(T)$, 随机初始化模型参数 $\theta$ 2. 从满足分布的 $T$ ~ $p(T)$ 任务中进行取样 3. 对任务T取样K个数据点作为数据集D, 即 $D = \{ (x_1, y_1), (x_2, y_2)......(x_k, y_k) \}$, 注意D中包含 $x$ 个特征、$y$ 个标签; 然后在数据集上运行SGD(随机梯度下降)算法, 迭代n次以减小损失, 假定此时得到的最优参数为 $\theta^{'}$ 4. 以靠近最优参数 $\theta^{'}$ 方向更新初随机始化参数 $\theta$ : $\theta = \theta + \epsilon (\theta^{'} - \theta) $ 5. 重复步骤2至步骤4, 直到最大迭代次数 MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], displayMath: [ ['$$','$$'], ["\\[","\\]"] ], processEscapes: true } });]]></content>
      <categories>
        <category>Deep Learning &amp; Machine Learning</category>
      </categories>
      <tags>
        <tag>Reptile</tag>
        <tag>MAML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漫谈Golang软件架构 (三) -- 数据建模]]></title>
    <url>%2Fgo%2Fdata-modeling%2F</url>
    <content type="text"><![CDATA[Golang软件架构漫谈之数据建模篇, 本文将对后端数据建模进行阐述. 实体与关系在需求早期阶段, 实体和关系处于概念层面, 伴随开发过程不断推进, 实体与关系建模逐渐转变为使用特定存储引擎的数据库、运用不同模式及多种数据结构等. 随着业务逻辑的频繁变更, 最初的数据设计也面临频繁迭代, 如: 实体建模层面, 构建数据实体层次结构, 描述各种相关实体 规范化层面, 如删除建模实体中的冗余数据等 非规范化层面, 如利用数据副本进行拓展等 约束层面或业务规则方面, 实体属性及实体之间关系治理 对象关系映射(ORM)层面, 对象与久存化实体间关系映射 关系型数据建模 第一范式 第二范式 第三范式 Boyce-Codd范式 第四范式 数据拓展性能模式分片(Sharding)单例数据库虽然很强大,但在存储空间和计算资源方面存在局限性.单个服务器在可用性方面不佳, 有些NoSQL数据库, 如Cassandra通过非透明方式进行数据分区以分发数据.但是,大多数据库系统(如大多数RDBMS数据库)不会在内部对数据进行分区.解决方案可以考虑分片, 通过将数据存储划分为一系列水平分区或分片集.每个分片都具有相同的Shema,但拥有一系列不同的数据行.每个分片本身相当于一个数据库, 应用程序将特定数据的请求路由到某些分片, 优点如下： 拓展性好, 可以通过添加额外的分片/节点方式拓展系统 分片之间负载均衡,可减少资源争用 数据访问高效, 可以利用智能安置策略定位或逼近计算所需数据 特别是在云计算环境下,可以将物理上离用户近的分片数据返回, 加快用户数据访问, 改善用户体验. 分片技术的运用, 在存储和访问大量数据时可扩展性强.数据分发方面,挑战在于拓扑发生变化时数据的重新定位,解决该问题主要有以下三种方式: 运用一致性哈希算法 基于客户端路由, 客户端查找映射,确定哪个分片(节点)承载特定密钥(哈希).每当拓扑发生变化时,客户端及时更新并获取最新映射. 典型例子, 如Redis Cluster以该种方式进行分片. 基于代理路由, 存在一中心服务接收IO请求并根据具体拓扑路由到合适的分片. 典型例子, 如MongoDB中的Sharding(分片)遵循该方式 事件溯源 和 物化视图当多计数器进行并发读取, 对读性能有什么影响? 通过更新多个非规范化表, 会使写入事务更加臃肿,增加开销, 影响性能. 此外, 数据所需的计数器或视图可能面临业务逻辑的频繁变更. 若更新所有视图, 有悖于责任分离原则. 处理这种问题,可以考虑的一种模式是事件溯源(Event Sourcing)以及物化视图.在事件溯源中,具体业务服务在执行过程中会触发事件变更, 通过回溯或追踪这一些列事件变更, Voilà, 你得到了不同版本的事件. Event Sourcing, 事件溯源, 本质上是分布式环境中对不同事件的”版本控制系统”. 物化视图, 利用事件进行视图聚合或固化,为特定用例提供必要支持, 换句话说,数据以特定的最佳视图方式进行物化.比如在预订系统中,获取计费的常见方式可以通过调用单独的计费API或视图,并根据预订事件为每个经销商计算费用, 假如有新的需求,如获取过去10分钟内完成的预订单, 可以通过使用相同的Booking预定事件实现新的API.物化视图与非规范化之间的考量在于最终一致性,当然,好处在于解决方案可扩展. 反规范化 (Denormalization)规范化过程旨在消除数据建模中的冗余, 使数据更新更加高效, 如写入无需在多个地方进行数据更新以保持数据一致性和数据完整性. 但也存在限制, 如存在性能瓶颈, 比如读取特定数据时可能需要执行多项数据库操作(连接、扫描等), 容易造成计算瓶颈. 以旅行网站上代理商数据为例, 用户预订旅游服务时, 预订数据建模如下： Bookings (预订数据表): BookingId (预定ID) Date (日期) SKU (标准产品单位) ResellerId (代理商ID) Amount (数量) Fee (费用) Resellers (代理商数据表): ResellerId (代理商ID) Name (代理商名称) Address (代理商联系地址) 其中预订表Bookings中的ResellerID作为外键关联Resellers表.无论何时进行预订, ResellerId及对应费用均由预订DB交易填充. 现在,新增需求—计算代理商当月营收, 可以通过在Bookings表上以ResellerID进行分组, 对日期月份进行筛选, 然后对费用进行求和. 但这种设计在多任务计算密集型环境中容易造成性能瓶颈, 解决思路之一, 可以在Resellers表中保留当前月份的费用计数(新增字段), 如下: ResellerId Name Address Fees due (新增字段) 每次进行预订时, 交易数据库将当前预订费用添加到费用计数列中; 获取当前费用直接通过简单查询即可, 无需每次对全表进行聚合, 缺点在于维护该聚合纬度数据时存在写入开销, 但这种以”IO换CPU”做法可行. 没有最完美的数据建模设计模式, 只有最适合的数据模型设计方式. 非规范化设计, 还有一点在于方便维护变更历史, 规范化模式仅保留系统的当前状态, 无法做到对历史状态进行Tracking回溯. 数据一致性保证 ACID, 关系型数据库中ACID(Atomicity原子性, Consistency一致性, Isolation隔离性, Durability持久性)语义 BASE理论, Basically Available(基本可用)、Soft state(软状态) 及 Eventual Consistency(最终一致性) 三个短语缩略. 其核心思想是即使无法做到强一致性(Strong Consistency,CAP的一致性就是强一致性), 但应用可以采用适合的方式达到最终一致性(Eventual Consitency). 数据存储KV键值对数据存储在分布式系统中应用广泛, 如Redis、ES、Hbase、Cassandra、Scylladb、Codis、Pika等 列式数据存储列式数据存储, 每个数据块Block拥有相似类型数据, 数据压缩更加高效, 从而减少IO及磁盘存储, 其它特性如Predicate Pushdown谓词下压, 可以减少部分无必要数据读取, 加速数据访问. 常见列式存储NoSQL数据库有 Apache HBase Apache Cassandra Apache Accumulo Apache Druid Apache Kudu Clickhouse (已开源, 由俄罗斯搜索引擎巨头Yandex推出) 百度Palo]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>Software Architecture</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[领域驱动设计之CQRS实战篇]]></title>
    <url>%2Fmicrosrvc%2Faxon-cqrs%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <categories>
        <category>Distributed System</category>
        <category>Microservices</category>
      </categories>
      <tags>
        <tag>Microservices</tag>
        <tag>CQRS</tag>
        <tag>JVM</tag>
        <tag>Distributed System</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Bahmani Sketch Algorithm]]></title>
    <url>%2Fbigdata%2Fmahout%2Fdata-sketch%2F</url>
    <content type="text"><![CDATA[Data Sketches技巧, 常用于获取某种特定问题的低解析度表征, 或为获取更好地稳定性在某些非确定算法进行Seed操作. 本文中Bahmani Sketch算法实际上由Bahmani等人于2012年提出的”K-Means II(k, l)初始化”算法II, 该算法相对简单, 但在分布式环境中实现存在一定难度, 本文将探究该算法的分布式实现. 算法原理 Bahmani Sketch算法, 可以视为通过采样方式逼近K-Means算法. 在分布式环境中, 采样算法相对容易实现. 假定输入数据集 $D = \{ x_i \in R^n : i=1, ...m \}$, Data Sketch尺寸为$k$, 其中 $\phi_D$ 计算方式为: $\phi_D(c) = \sum_{x \in D} min_{c \in C} ||x - c||_2^2$ 其中, 数据集 $C = \{ c_i \in R^n : i=1, ...k \}$, $\phi_D(C)$ 表示数据集$D$中每个数据点与另一数据集$C$中最近数据点的距离平方和, Bahmani论文中简化距离公式为: $d(y, C) = min_{c \in C} ||y -c||_2$ 因此, $\phi_D(C)$ 可以变得更加简单 $\phi_D(C) = \sum_{x \in D} d^2(x, C)$ . 假定数据集$C$与$C^{'}$是有序的, 随着时间变化、更新, 对这两数据集做并集时也可保证有序性. Bahmani Sketch算法主要原理, 可概括为以下伪代码: MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], displayMath: [ ['$$','$$'], ["\\[","\\]"] ], processEscapes: true } }); 给定数据集 $ D = \{ x_i \in R^n : i=1, …m \} $, 过采样参数 $l$, 假定算法逼近数据sketch尺寸为$k$, $k \ll m$ $C \leftarrow $从数据集 $D$ 中随机采样(假定采样符合随机正态分布) $ \psi \leftarrow \phi_x (C) $ for $O(log\psi)$ 次 do a) $C^{‘} \leftarrow $ 对 $x \in D$ 数据点进行独立采样, 且概率满足: $p_x = \frac{l * d^2(x, C)}{\phi_D(C)} $ b) 更新 $C \leftarrow C \cup C^{‘}$end-for 对于$c_i \in C$, 假定$D$ 中数据点 $w_i$ 为最靠近 $c_i$的数据点 对$C$ 中权重点进行重聚类至$k$个聚类 $C^{n}$ 返回 $C^{n}$ MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], displayMath: [ ['$$','$$'], ["\\[","\\]"] ], processEscapes: true } }); 代码实战算法实现要求给定$n$纬空间中$m$个数据点, 获取$k$个数据点, 其中$k \ll N$, 在满足给定数据集统计需求情况下, 尽可能做到CPU和内存代价不比$O(m)$差. 本文Bahmani Sketch算法将采用Mahout进行编码实现. Why Mahout ?随着2014年Yann LeCun博士等人在深度学习方面研究成果的重大突破, 深度学习、GPU、TPU开始大热. 或许你会问Why Mahout, Why not Tensorflow? 首先, GPU虽然并行计算能力较强, 但GPU分布式节点拓展能力暂时还没方法和Hadoop等生态组件比拟. 成本问题, 目前高性能计算GPU还比较昂贵, 而Hadoop等分布式组件可以部署在廉价服务器上. (并非所有厂商都能用得上GPU, 某些中小厂商算法团队能用上一两台GPU机器已算是欣慰了) 关于Mahout, 自2014年Mahout PMC开始全面拥抱Spark和Flink, 采用Scala重写Mahout源码, 计算引擎由原来的MapReduce替换为Spark和Flink(也支持H2O). 这意味着Mahout迭代训练速度大大提升, 之前MapReduce任务漫长的等待时日”一去不复返”. 代码遗留问题, Mahout推出时间较早, 国内多数早期采用Hadoop生态组件的厂商在分布式算法迭代训练组件选型时多少会接触到Mahout. 当然, 除了Mahout组件外, 其它分布式机器学习、深度学习组件参考如下: Spark MLlib/ML H2O, 硅谷初创公司H2O.AI推出, 支持分布式迭代、训练, 支持部分深度学习算法 Deeplearning4J, 由SkyMind团队推出, 充分利用Spark、Hadoop等生态组件进行分布式迭代训练, 支持多数深度学习算法 Tensorflow on Spark(即TensorFrame) 采样算法并行化 由数据集$D$引入矩阵$X$, 即 $X_i* \triangleq x_i$, 对于Cardinality而言, $|D| = m$. 由于 $\sum_{x \in D} \frac{d^2(x, C)}{\phi_D(c)} = 1$, 对于新采样数据点而言, 期望值满足 $E(|C^{'}|) = l$, 通常参数$l$选取为 $l$ ~ $0.5k...2k$, 最终 $E(|C|) \ll m$ . Bahmani算法分布式采样算法如下, 给定迭代次数$I$, 由数据集$D$引入输入矩阵$X$, 最终Sketch大小$k$, 采样伪代码如下: 假定 $l \leftarrow 2I/k$, 初始化 $Y \leftarrow cbind(0, +Inf, X)$, 采样$C$, 正态分布逼近$l$个数据点, 然后更新 $Y(0, C)$ MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], displayMath: [ ['$$','$$'], ["\\[","\\]"] ], processEscapes: true } }); 其中, 更新$Y(C, C^{‘})$算法主要步骤如下: 给定采样数据集$C^{‘}$, 矩阵$Y$, 距离均方矩阵$D$计算方式: $D_{ij} = || c^{r(i)} - c^{r(j)} ||_2^2 $, 其中 $c^{r(i)} \in C^{‘}, c^{r(j)} \in C{‘} $ MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], displayMath: [ ['$$','$$'], ["\\[","\\]"] ], processEscapes: true } }); 分布式采样代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344def dSample[K: ClassTag](drmA: DrmLike[K], sketchSize: Int, iterations: Int, seed: Int = Random.nextInt()): (Maxtrix, DrmLike[K]) = &#123; implicit val ctx = drmA.context val l = sketchSize * 2 / iterations + 1 max 1 val n = drmA.ncol var drmY = drmAToY(drmA).checkpoint() var mxC = drmSampleKRows(drmY, 1) mxC = mxC(::, 2 until n + 2) drmY = updateY(drmY, mxC, cStart=0).checkpoint() for (iter &lt;- 0 until (iterations -1 max 1)) &#123; val innerN = n val innerL = 1 val phi = drmY(::, 1 to l).colSum()(0) val subseed = seed + iter val mxCPrime = drmY.allreduceBlock( &#123; case (keys, yblock) =&gt; if (yblock.nrow &gt; 0) &#123; val vDSq = yblock(::, 1) val ablock = yblock(::, 2 until innerN + 2) val rnd = new Random(subseed * keys(0).hashCode()) val selected = new mutable.ArrayBuffer[Int](200) for (r &lt;- 0 until ablock.nrow) &#123; val p = innerL * vDSq(r) / phi if (rnd.nextDouble &lt;= p) selected += r &#125; val cPrimeBlock: Matrix = yblock.like(selected.size, innerN) selected.zipWithIndex.foreach &#123; case (idx, i) =&gt; cPrimeBlock(i, ::) = ablock(idx, ::) &#125; cPrimeBlock &#125; else &#123; new DenseMatrix(0, innerN) &#125; &#125;, _ rbind _ ) drmY = updateY(drmY, mxCPrime, mxC.nrow).checkpoint() mxC = mxC rbind mxCPrime &#125; mxC -&gt; drmY&#125; 其中, 矩阵更新函数updateY代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243private def updateY[K: ClassTag](drmY: DrmLike[K], mxC: Matrix, cStart: Int): DrmLike[K] = &#123; implicit val ctx = drmY.context val mxCBcast = drmBroadcast(mxC) drmY.mapBlock() &#123; case (keys, yblock) =&gt; updateYBlock(yblock, mxCBcast, cStart) keys -&gt; yblock &#125;&#125;private def updateYBlock(mxY: Matrix, mxC: Matrix, cStart: Int): Unit = &#123; val n = mxY.ncol - 2 val k = mxC.nrow val mxA = mxY(::, 2 until n + 2) val vLabels = mxY(::, 0) val vSqD = mxY(::, 1) val mxCDsq = dist(mxC) /= 4 for (row &lt;- mxA) &#123; var minC = 0 var minCDsq = (row - mxC(minC, ::)) ^= 2 sum for (c&lt;- 1 until k) &#123; if (mxCDsq(minC, c) &lt;= minCDsq &amp;&amp; sqr(mxC(c, ::).norm(2) - row.norm(2)) &lt;= minCDsq) &#123; val dSq = (row - mxC(c, ::)) ^= 2 sum if (dSq &lt; minCDsq) &#123; minC = c minCDsq = dSq &#125; &#125; &#125; if (cStart == 0 || minCDsq &lt; vSqD(row.index)) &#123; vLabels(row.index) = minC + cStart vSqD(row.index) = minCDsq &#125; &#125;&#125; 其中, 矩阵$Y$ 构造代码示意如下: 1234567private def drmAToY[K: ClassTag] (drmA: DrmLike[K]): DrmLike[K] = &#123; drmA.mapBlock(drmA.ncol + 2) &#123; case (keys, block) =&gt; val yBlock = new DenseMatrix(block.nrow, 2) cbind block keys -&gt; yBlock &#125;&#125; 计算采样点权重参考代码如下: 123456789101112def computePointWeights[K: ClassTag] (drmY: DrmLike[K], nC: Int): Vector = &#123; val vWeights = drmY.allreduceBlock(&#123; case (keys, yblock) =&gt; val wvec = new DenseVector(nC) val labels = yblock(::, 0).all .foreach &#123;sgm =&gt; wvec(sgm.toInt) += 1&#125; dense(wvec) &#125;)(0, ::) val s = vWeights.sum vWeithts /= s&#125;]]></content>
      <categories>
        <category>Distributed System</category>
      </categories>
      <tags>
        <tag>Big Data</tag>
        <tag>Machine Learning</tag>
        <tag>Distributed Algorithm</tag>
        <tag>Apache Mahout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin高性能实战 (二) -- Kotlin Property优化 (Part Two)]]></title>
    <url>%2Fkt%2Fprops-inspct%2F</url>
    <content type="text"><![CDATA[之所以想写这个系列的Kotlin笔记, 主要原因在于Kotlin协程丰富了JVM生态. 有人说Kotlin语法像Scala, 但个人感觉Kotlin比Java更像C++, 比如Kotlin在闭包上使用了大量的内联(inline)技巧进行性能优化. 尽管Java也有一些协程相关的包可以用, 但远不如Kotlin协程优雅, 更具表现力. 尽管你可以使用:Akka Actor (或者类似的Actor包)RxJava (或类似的Reactive响应式框架, 比如Vert.x)开发高性能高并发应用程序, 以上抽象均为Message Driven或Event Driven(消息驱动或事件驱动), 但有些业务场景如果考虑使用Event-Driven建模, 未免过于重量级, 于是你需要更加轻量级的替代方案, 比如Future/Promise (异步非阻塞, 本质为占位符(Placeholder), 仅适用于单个值), 比如轻量级线程—协程. 尽管Kotlin协程本质上也是使用JVM线程池进行封装, 但Kotlin协程在JVM生态同等实现中表现出色! 最重要的是, 作为JVM语言, 不仅Java可以使用Kotlin协程, Scala/Groovy/Clojure照样也可使用Kotlin协程. 本博文将对Kotlin Property使用过程中遇到的”坑点”进行梳理汇总, 欢迎入”坑”, 逆风成长! 本博文要点如下: 首先, 简单介绍下Kotlin内部类对Property访问限制问题 然后, 对Kotlin伴生对象优化问题进行剖析 接着, 对Kotlin中lateinit 延迟初始化问题进行探讨 最后, 对Kotlin编译时常量提供使用建议 内部类中Property访问先来看下内部类相关的一段简单代码: 12345678class Main &#123; inner class Inner &#123; fun printValue() &#123; println(value) &#125; &#125; private var value = "Value"&#125; 上面这段代码字节码反编译成Java源码如下, 可以看到编译器将类Main和Inner作为俩个单独的类, 并且生成特定的方法保证内部类能访问外部类的私有成员. 123456789101112131415public final class Main &#123; private String value = "Value"; // $FF: synthetic method public static final void access$setValue$p(Main $this, @NotNull String var1) &#123; $this.value = var1; &#125; public final class Inner &#123; public final void printValue() &#123; String var1 = Main.this.value; System.out.println(var1); &#125; &#125;&#125; 如果细看字节码, 你会发现内部类的printValue()方法实际调用了外部类的静态方法access$setValue$p 12345678910111213141516171819public final printValue()VL0LINENUMBER 84 L0ALOAD 0GETFIELD Main$Inner.this$0 : LMain;INVOKESTATIC Main.access$getValue$p (LMain;)Ljava/lang/String;ASTORE 1L1GETSTATIC java/lang/System.out : Ljava/io/PrintStream;ALOAD 1INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/Object;)VL2L3LINENUMBER 85 L3RETURNL4LOCALVARIABLE this LMain$Inner; L0 L4 0MAXSTACK = 2MAXLOCALS = 2 如果想让内部类Inner直接访问外部类Main的成员value该怎么做? 给value加public限定符吗? 这种方法肯定不行, 因为编译器依然会为外部类成员value生成setter和setter, 内部类仍通过value的getter和setter对其进行访问. 回顾上篇博文, 可以使用@JvmField解决这个问题. 对value添加注解@JvmField后, 对应字节码反编译成Java源码如下: 123456789101112public final class Main &#123; @JvmField @NotNull public String value = "Value"; public final class Inner &#123; public final void printValue() &#123; String var1 = Main.this.value; System.out.println(var1); &#125; &#125;&#125; 伴生对象的问题Kotlin中没有静态对象,没有静态方法, 但可以通过伴生对象的方式实现类似目的. 对于Kotlin伴生对象而言, 当一个类被加载至内存时才会创建对应的伴生对象. 先来看段代码, 这段代码比较简单: 12345678910111213class Main private constructor() &#123; private var id: Int? = null companion object &#123; var prevId = -1 fun newInstance(): Main &#123; val main = Main() main.id = ++prevId return main &#125; &#125;&#125; 你能看出这段代码的性能呢问题吗? 不急, 可以先看下字节码, 类Main中包含了方法&lt;clinit&gt;,该方法在类加载和初始化伴生对象时被调用. 12345678910111213static &lt;clinit&gt;()VNEW Main$CompanionDUPACONST_NULLINVOKESPECIAL Main$Companion.&lt;init&gt; (Lkotlin/jvm/internal/DefaultConstructorMarker;)VPUTSTATIC Main.Companion : LMain$Companion;L0LINENUMBER 94 L0ICONST_M1PUTSTATIC Main.id : IRETURNMAXSTACK = 3MAXLOCALS = 0 方法&lt;clinit&gt;调用一个非默认构造器, 该构造器是编译器为伴生对象生成的特殊构造器: 1234567891011public synthetic &lt;init&gt;(Lkotlin/jvm/internal/DefaultConstructorMarker;)VL0LINENUMBER 92 L0ALOAD 0INVOKESPECIAL Main$Companion.&lt;init&gt; ()VRETURNL1LOCALVARIABLE this LMain$Companion; L0 L1 0LOCALVARIABLE $constructor_marker Lkotlin/jvm/internal/DefaultConstructorMarker; L0 L1 1MAXSTACK = 1MAXLOCALS = 2 生成的Main$Companion类包含一对为prevId生成的gettter和setter: 123456789101112131415161718192021public final getPrevId()IL0LINENUMBER 96 L0INVOKESTATIC Main.access$getPrevId$cp ()IIRETURNL1LOCALVARIABLE this LMain$Companion; L0 L1 0MAXSTACK = 1MAXLOCALS = 1public final setPrevId(I)VL0LINENUMBER 96 L0ILOAD 1INVOKESTATIC Main.access$setPrevId$cp (I)VRETURNL1LOCALVARIABLE this LMain$Companion; L0 L1 0LOCALVARIABLE &lt;set-?&gt; I L0 L1 1MAXSTACK = 1MAXLOCALS = 2 这些方法调用其他生成方法, 以便访问类Main中静态变量prevId: 1234567891011121314151617181920public final static synthetic access$getPrevId$cp()I L0 LINENUMBER 90 L0 GETSTATIC Main.prevId : I IRETURN L1 MAXSTACK = 1 MAXLOCALS = 0 // access flags 0x1019 public final static synthetic access$setPrevId$cp(I)V L0 LINENUMBER 90 L0 ILOAD 0 PUTSTATIC Main.prevId : I RETURN L1 LOCALVARIABLE &lt;set-?&gt; I L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 类Main当然也包含了对id变量访问的其他生成方法: 12345678910111213141516171819202122232425public final static synthetic access$getId$p(LMain;)Ljava/lang/Integer;@Lorg/jetbrains/annotations/Nullable;() // invisibleL0LINENUMBER 90 L0ALOAD 0GETFIELD Main.id : Ljava/lang/Integer;ARETURNL1LOCALVARIABLE $this LMain; L0 L1 0MAXSTACK = 1MAXLOCALS = 1public final static synthetic access$setId$p(LMain;Ljava/lang/Integer;)V@Lorg/jetbrains/annotations/Nullable;() // invisible, parameter 1L0LINENUMBER 90 L0ALOAD 0ALOAD 1PUTFIELD Main.id : Ljava/lang/Integer;RETURNL1LOCALVARIABLE $this LMain; L0 L1 0LOCALVARIABLE &lt;set-?&gt; Ljava/lang/Integer; L0 L1 1MAXSTACK = 2MAXLOCALS = 2 从上面这一堆字节码, 可以看出什么东西? 实际上类Main生成了一堆不需要的函数和方法. 有更好地解决方案吗? 有, 可以重构代码如下: 1234567891011121314151617@file:JvmName("Main")@JvmFieldvar prevId = -1class Main private constructor() &#123; private var id: Int? = null companion object &#123; @JvmStatic fun newInstance(): Main &#123; val main = Main() main.id = ++prevId return main &#125; &#125;&#125; 其中, @file:JvmName(Main)注解告诉编译器所有的顶层成员必须包含在Main类中, @JvmStatic注解告诉编译器newInstance()方法作为静态方法生成. 现在只有一个额外方法生成, 对应字节码如下: 1234567891011public synthetic &lt;init&gt;(Lkotlin/jvm/internal/DefaultConstructorMarker;)V L0 LINENUMBER 21 L0 ALOAD 0 INVOKESPECIAL io/xavier/property/Main$Companion.&lt;init&gt; ()V RETURN L1 LOCALVARIABLE this Lio/xavier/property/Main$Companion; L0 L1 0 LOCALVARIABLE $constructor_marker Lkotlin/jvm/internal/DefaultConstructorMarker; L0 L1 1 MAXSTACK = 1 MAXLOCALS = 2 lateinit 延迟初始化问题有时我们需要在类初始化后初始化一些Properties, 且不希望创建一nullable类型, 通常我们会使用主构造器, 避免创建的实例Property没有初始化, 如下: 123class CoffeeShop @Inject constructor(val coffee: Coffee) &#123; // 省略具体实现代码&#125; 但是在Android开发中存在一个问题, 比如Activity或Service类构造器直接由操作系统调用, 而我们并不能重写这些构造器. 一种解决方式是通过使用setter进行初始化, 如下: 1234private var coffee: Coffee? = null @Inject set(value) &#123; field = value &#125; 还有一种方式是通过使用lateinit关键字并将修饰的字段放到onCreate()方法中, 如下: 123456class Main &#123; private lateinit var name: String fun onCreate() &#123; name = "Jack" &#125;&#125; 字节码如下,可以看到类Main被编译成拥有正常field的Java类: 12345678910111213141516171819202122232425262728public final class Main &#123; private Ljava/lang/String; name public final onCreate()V L0 LINENUMBER 12 L0 ALOAD 0 LDC "Jack" PUTFIELD Main.name : Ljava/lang/String; L1 LINENUMBER 13 L1 RETURN L2 LOCALVARIABLE this LMain; L0 L2 0 MAXSTACK = 2 MAXLOCALS = 1 public &lt;init&gt;()V L0 LINENUMBER 7 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V RETURN L1 LOCALVARIABLE this LMain; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1&#125; 在上面的onCreate()方法中加点东西, 如: 12345fun onCreate() &#123; name = "Jack" println(name)&#125; 对应字节码如下: 12345678910111213141516171819202122232425262728public final onCreate()VL0LINENUMBER 84 L0ALOAD 0LDC "Jack"PUTFIELD Main.name : Ljava/lang/String;L1LINENUMBER 86 L1ALOAD 0GETFIELD Main.name : Ljava/lang/String;DUPIFNONNULL L2LDC "name"INVOKESTATIC kotlin/jvm/internal/Intrinsics.throwUninitializedPropertyAccessException (Ljava/lang/String;)VL2ASTORE 1L3GETSTATIC java/lang/System.out : Ljava/io/PrintStream;ALOAD 1INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/Object;)VL4L5LINENUMBER 87 L5RETURNL6LOCALVARIABLE this LMain; L0 L6 0MAXSTACK = 2MAXLOCALS = 2 其中, 访问name并获取该值, 会调用额外一层检测: 123IFNONNULL L2LDC "name"INVOKESTATIC kotlin/jvm/internal/Intrinsics.throwUninitializedPropertyAccessException (Ljava/lang/String;)V 所以从被lateinit关键字修饰的字段获取值时, 最好将值放到临时变量中: 123456fun onCreate() &#123; name = "Jack" val name = this.name println(name)&#125; 这样的话, 只会调用一次检测Intrinsics.throwUninitializedPropertyAccessException, 上面这段代码的字节码如下 12345678910111213141516171819202122232425262728293031public final onCreate()VL0LINENUMBER 90 L0ALOAD 0LDC "Jack"PUTFIELD Main.name : Ljava/lang/String;L1LINENUMBER 92 L1ALOAD 0GETFIELD Main.name : Ljava/lang/String;DUPIFNONNULL L2LDC "name"INVOKESTATIC kotlin/jvm/internal/Intrinsics.throwUninitializedPropertyAccessException (Ljava/lang/String;)VL2ASTORE 1L3LINENUMBER 93 L3L4GETSTATIC java/lang/System.out : Ljava/io/PrintStream;ALOAD 1INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/Object;)VL5L6LINENUMBER 94 L6RETURNL7LOCALVARIABLE name Ljava/lang/String; L3 L7 1LOCALVARIABLE this LMain; L0 L7 0MAXSTACK = 2MAXLOCALS = 2 或者可以使用其他函数, 如also()函数, also函数是一个内联函数, 所以不会有太大的性能损耗. 1234567fun onCreate() &#123; name = "Jack" name.also &#123; println(it) &#125;&#125; 编译时常量使用建议编译时常量(Complie-time Constant)作为只读变量在编译时进行初始化, 编译时常量一般满足以下几个要求: 必须在顶层声明或作为对象成员 不能有 getter 或 setter 必须使用原始类型或字符串值进行初始化 为更好地理解编译时常量,可以做个小测试 123val point = Point()const val compileTime: Int = 5fun compileTimeFunction() = compileTime + compileTime 字节码如下, 可以看到编译器生成了特殊的初始化方法&lt;clinit&gt;对point进行初始化, point使用private访问限定符修饰, 意味着使用getter或setter访问. 123456789101112131415161718192021222324252627282930313233343536public final class MainKt &#123; private final static Ljava/awt/Point; point @Lorg/jetbrains/annotations/NotNull;() // invisible public final static getPoint()Ljava/awt/Point; @Lorg/jetbrains/annotations/NotNull;() // invisible L0 LINENUMBER 77 L0 GETSTATIC MainKt.point : Ljava/awt/Point; ARETURN L1 MAXSTACK = 1 MAXLOCALS = 0 public final static I compileTime = 5 public final static compileTimeFunction()I L0 LINENUMBER 81 L0 BIPUSH 10 IRETURN L1 MAXSTACK = 1 MAXLOCALS = 0 static &lt;clinit&gt;()V L0 LINENUMBER 77 L0 NEW java/awt/Point DUP INVOKESPECIAL java/awt/Point.&lt;init&gt; ()V PUTSTATIC MainKt.point : Ljava/awt/Point; RETURN MAXSTACK = 2 MAXLOCALS = 0&#125; 为避免point生成getter和setter, 回顾上篇博文, 可以考虑使用@JvmField注解: 12345@JvmFieldval point = Point()const val compileTime: Int = 5fun compileTimeFunction() = compileTime + compileTime 字节码如下, 可以看到&lt;clinit&gt;方法依然存在: 12345678910111213141516171819202122232425262728public final class MainKt &#123; public final static Ljava/awt/Point; point @Lkotlin/jvm/JvmField;() // invisible @Lorg/jetbrains/annotations/NotNull;() // invisible public final static I compileTime = 5 public final static compileTimeFunction()I L0 LINENUMBER 82 L0 BIPUSH 10 IRETURN L1 MAXSTACK = 1 MAXLOCALS = 0 static &lt;clinit&gt;()V L0 LINENUMBER 78 L0 NEW java/awt/Point DUP INVOKESPECIAL java/awt/Point.&lt;init&gt; ()V PUTSTATIC MainKt.point : Ljava/awt/Point; RETURN MAXSTACK = 2 MAXLOCALS = 0 &#125; 结论: 尽量避免使用非编译时常量作为顶级成员.]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>JVM And JVM Languages</tag>
        <tag>Kotlin</tag>
        <tag>High Performance Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin高性能实战 (四) -- Kotlin Delegate (Part Two)]]></title>
    <url>%2Fkt%2Fdlgt-props%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>JVM And JVM Languages</tag>
        <tag>Kotlin</tag>
        <tag>High Performance Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin高性能实战 (三) -- Kotlin协程]]></title>
    <url>%2Fkt%2Fcoroutines%2F</url>
    <content type="text"><![CDATA[之所以想写这个系列的Kotlin笔记, 主要原因在于Kotlin协程丰富了JVM生态. 有人说Kotlin语法像Scala, 但个人感觉Kotlin比Java更像C++, 比如Kotlin在闭包上使用了大量的内联(inline)技巧进行性能优化. 尽管Java也有一些协程相关的包可以用, 但远不如Kotlin协程优雅, 更具表现力. 尽管你可以使用:Akka Actor (或者类似的Actor包)RxJava (或类似的Reactive响应式框架, 比如Vert.x)开发高性能高并发应用程序, 以上抽象均为Message Driven或Event Driven(消息驱动或事件驱动), 但有些业务场景如果考虑使用Event-Driven建模, 未免过于重量级, 于是你需要更加轻量级的替代方案, 比如Future/Promise (异步非阻塞, 本质为占位符(Placeholder), 仅适用于单个值), 比如轻量级线程—协程. 尽管Kotlin协程本质上也是使用JVM线程池进行封装, 但Kotlin协程在JVM生态同等实现中表现出色! 最重要的是, 作为JVM语言, 不仅Java可以使用Kotlin协程, Scala/Groovy/Clojure照样也可使用Kotlin协程. Kotlin协程允许开发者以顺序化的方式编写异步代码, Kotlin协程概念主要基于Suspended Computation, 但并不阻塞线程. Kotlin协程实现主要基于以下三点: 语言级别支持 (如suspend关键字) Kotlin标准库Low-level核心API (如线程) 高级API (如CoroutineContext) 本博文主要关于Kotlin协程常见方法源码剖析以及应用实战. 添加依赖Maven工程, 增加以下Maven依赖: 12345&lt;dependency&gt; &lt;groupId&gt;org.jetbrains.kotlinx&lt;/groupId&gt; &lt;artifactId&gt;kotlinx-coroutines-core&lt;/artifactId&gt; &lt;version&gt;YOUR-VERSION-HERE&lt;/version&gt;&lt;/dependency&gt; Grade项目, 增加依赖如下: 123dependencies &#123; implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:THE-VERSION-YOU-CHOOSE'&#125; Android项目, 增加以下依赖模块: 1implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:THE-VERSION-YOU-CHOOSE' Kotlin协程常见方法Kotlin常见方法有: lauch async buildSequence lauchlauch函数可以这样使用: 1234567val job = lauch &#123; val suspendLambda = suspend &#123; delay(1, TimeUnit.SECONDS) println("Hi from suspend lambda") &#125; suspendLambda()&#125; suspend关键字用于指明被调用函数可以挂起,且只能被另一协程调用. delay将使协程停止一段时间, 常用于调试.lauch函数可用于调用suspend lambda, 其源码如下: 1234567891011121314151617181920212223242526public actual fun launch( context: CoroutineContext = DefaultDispatcher, start: CoroutineStart = CoroutineStart.DEFAULT, parent: Job? = null, block: suspend CoroutineScope.() -&gt; Unit): Job &#123; val newContext = newCoroutineContext(context, parent) val coroutine = if (start.isLazy) LazyStandaloneCoroutine(newContext, block) else StandaloneCoroutine(newContext, active = true) coroutine.initParentJob(newContext[Job]) start(block, coroutine, coroutine) return coroutine&#125;// 简化版 `Job` 源码如下public actual interface Job : CoroutineContext.Element &#123; public actual val isActive: Boolean public actual val isCompleted: Boolean public actual val isCancelled: Boolean public actual fun start(): Boolean public actual fun cancel(cause: Throwable? = null): Boolean public actual suspend fun join()&#125; Job类代表一可以取消的Task,具有一定生命周期且可拥有子任务.在其生命周期内, Job存在以下状态: 新建 (New) 活跃 (Active) 正在完成 (Completing) 已经完成 (Completed) 正在取消 (Canceling) 已经取消 (Canceled) Job类中join方法挂起(Suspend)协程直到Job结束, 其方法签名如下: 1public actual suspend fun join() 当然, 你也可以从返回CoroutineContext实例的方法(如lauch方法)中调用join方法. 值得注意的是, 上面代码中suspendLambda将在另一独立线程中调用, 因此主线程会等待,直到suspendLambda完成. 12345678910111213141516171819202122232425262728// 使用`runBlocking` 迫使主线程main等待`suspendLambda`完成fun main(args: Array&lt;String&gt;) = runBlocking &#123; val job = launch &#123; val suspendLambda = suspend &#123; delay(1, TimeUnit.SECONDS) println("Hello from suspend lambda") &#125; suspendLambda() &#125; job.join()&#125;// `runningBlock`可以调用`suspend` lambda或其他函数, 调用时会阻塞线程, 源码如下public fun &lt;T&gt; runBlocking(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope.() -&gt; T): T &#123; val currentThread = Thread.currentThread() val eventLoop = if (context[ContinuationInterceptor] == null) BlockingEventLoop(currentThread) else null val newContext = newCoroutineContext(context + (eventLoop ?: EmptyCoroutineContext)) val coroutine = BlockingCoroutine&lt;T&gt;(newContext, currentThread, privateEventLoop = eventLoop != null) coroutine.initParentJob(newContext[Job]) block.startCoroutine(coroutine, coroutine) return coroutine.joinBlocking()&#125; async12345678910111213141516171819202122232425262728293031323334public actual fun &lt;T&gt; async( context: CoroutineContext = DefaultDispatcher, start: CoroutineStart = CoroutineStart.DEFAULT, parent: Job? = null, block: suspend CoroutineScope.() -&gt; T): Deferred&lt;T&gt; &#123; val newContext = newCoroutineContext(context, parent) val coroutine = if (start.isLazy) LazyDeferredCoroutine(newContext, block) else DeferredCoroutine&lt;T&gt;(newContext, active = true) coroutine.initParentJob(newContext[Job]) start(block, coroutine, coroutine) return coroutine&#125;// `Deferred`源码如下,该接口代表着协程执行的future resultpublic actual interface Deferred&lt;out T&gt; : Job &#123; public actual val isCompletedExceptionally: Boolean public actual suspend fun await(): T public val onAwait: SelectClause1&lt;T&gt; public actual fun getCompleted(): T public actual fun getCompletionExceptionOrNull(): Throwable? @Deprecated(message = "Use `isActive`", replaceWith = ReplaceWith("isActive")) public val isComputing: Boolean get() = isActive&#125; 来看一段示例代码: 1234567891011121314// `Bakery`中方法, 通过使用`async`异步烘烤给定数量蛋糕suspend fun coroutinesOrder(amountOfCakes: Int): List&lt;Cake&gt; &#123; //烤炉实例化, 烤炉及烘烤方法具体实现暂略 val baker = Baker() return (0 until amountOfCakes) .map &#123; async &#123; baker.bake() &#125; &#125; // 调用`await`方法获取列表中每项deferred值 .map &#123; it.await()&#125;&#125;fun main(args: Array&lt;String&gt;) = runBlocking &#123; val cakes = Bakery().coroutinesOrder(10) println("Number of cakes: $&#123;cakes.size&#125;")&#125; buildSequence1234567891011// `buildSequence` 源码public fun &lt;T&gt; buildSequence(builderAction: suspend SequenceBuilder&lt;T&gt;.() -&gt; Unit): Sequence&lt;T&gt; = Sequence &#123; buildIterator(builderAction) &#125;// `buildItertor` 源码如下public fun &lt;T&gt; buildIterator(builderAction: suspend SequenceBuilder&lt;T&gt;.() -&gt; Unit): Iterator&lt;T&gt; &#123; val iterator = SequenceBuilderIterator&lt;T&gt;() iterator.nextStep = builderAction.createCoroutineUnchecked(receiver = iterator, completion = iterator) return iterator&#125;]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>JVM And JVM Languages</tag>
        <tag>Kotlin</tag>
        <tag>High Performance Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin高性能实战 (二) -- Kotlin Property优化(Part One)]]></title>
    <url>%2Fkt%2Foptmz-props%2F</url>
    <content type="text"><![CDATA[之所以想写这个系列的Kotlin笔记, 主要原因在于Kotlin协程丰富了JVM生态. 有人说Kotlin语法像Scala, 但个人感觉Kotlin比Java更像C++, 比如Kotlin在闭包上使用了大量的内联(inline)技巧进行性能优化. 尽管Java也有一些协程相关的包可以用, 但远不如Kotlin协程优雅, 更具表现力. 尽管你可以使用:Akka Actor (或者类似的Actor包)RxJava (或类似的Reactive响应式框架, 比如Vert.x)开发高性能高并发应用程序, 以上抽象均为Message Driven或Event Driven(消息驱动或事件驱动), 但有些业务场景如果考虑使用Event-Driven建模, 未免过于重量级, 于是你需要更加轻量级的替代方案, 比如Future/Promise (异步非阻塞, 本质为占位符(Placeholder), 仅适用于单个值), 比如轻量级线程—协程. 尽管Kotlin协程本质上也是使用JVM线程池进行封装, 但Kotlin协程在JVM生态同等实现中表现出色! 最重要的是, 作为JVM语言, 不仅Java可以使用Kotlin协程, Scala/Groovy/Clojure照样也可使用Kotlin协程. Kotlin中Property使用, 与Java相比, 还是有些区别, 本博文将介绍Kotlin中Property使用及注意事项, 并给出对应性能优化建议. Property 初探先来看段示例代码, 如下: 12345678// 简单定义一个`Button`类, 属性有文本内容、背景颜色、点击监听器// 注意 `TODO()` 方法在Kotlin标准库中有定义, 是标准库中一方法, // 可以用于方法,表明不想立即实现该方法;也可用于类,对类建模时不想立即实现特定的类成员class Button &#123; var text: String = TODO() var backgroundColor: Int = TODO() var onClickListener: ((Button) -&gt; Unit)? = null&#125; 将上面这段代码的字节码反编译成Java源码如下: 12345678910111213141516171819202122232425262728293031323334353637383940public final class Button &#123; @NotNull private String text; private int backgroundColor; @Nullable private Function1 onClickListener; @NotNull public final String getText() &#123; return this.text; &#125; public final void setText(@NotNull String var1) &#123; Intrinsics.checkParameterIsNotNull(var1, "&lt;set-?&gt;"); this.text = var1; &#125; public final int getBackgroundColor() &#123; return this.backgroundColor; &#125; public final void setBackgroundColor(int var1) &#123; this.backgroundColor = var1; &#125; @Nullable public final Function1 getOnClickListener() &#123; return this.onClickListener; &#125; public final void setOnClickListener(@Nullable Function1 var1) &#123; this.onClickListener = var1; &#125; public Button() &#123; throw (Throwable) ( new NotImplementedError((String)null, 1, (DefaultConstructorMarker)null) ); &#125;&#125; Kotlin为这三个类属性分别加上了getter和setter方法.值得注意的是text属性加上了NotNull注解, 并且在类构造器中抛出异常, Why? 点开TODO()源码, 该方法返回类型为Noting, 具体实现为抛出NotImplementedError异常. Button类中三个类属性, onClickListener初始化为null, 其它俩个属性均使用TODO()方法初始化, 现在可以理解构造器本质上抛出的NotImplementedError. 还有一个小细节, 虽然text和backgroundColor属性均使用TODO()方法初始化,但在构造器中text属性参数为null,而backgroundColor属性参数为1? 出现这种现象主要在于俩属性的类型不同导致,text属性为字符串类型, backgroundColor类型为Int, 在Java/Kotlin中字符串默认初始化参数为空, 而整型Int存在默认初始化参数. 1234567// `TODO()` 方法源码@kotlin.internal.InlineOnlypublic inline fun TODO(): Nothing = throw NotImplementedError()@kotlin.internal.InlineOnlypublic inline fun TODO(reason: String): Nothing = throw NotImplementedError("An operation is not implemented: $reason") Backing Property 初探现在对Button类进行重构如下:1234567891011121314151617181920class Button &#123; var text: String? = null //自定义 getters和setters 方法 set(value) &#123; println(value) text = value &#125; get() &#123; return field + field &#125; var backgroundColor: Int? = null var onClickListener: ((Button) -&gt; Unit)? = null&#125;// 测试 `Button`类fun main(args: Array&lt;String&gt;) &#123; Button().text = "Generating a simple Button"&#125; 试着运行这段代码,很不幸,打印几个”Generating a simple Button”后立即抛出StackOverflowError, What’s wrong? 别急, 先从字节码上找原因, Button类字节码如下, 可以看到setText方法调用自身, 导致栈内存溢出. 1234567891011121314151617181920212223// access flags 0x11public final setText(Ljava/lang/String;)V@Lorg/jetbrains/annotations/Nullable;() // invisible, parameter 0L0LINENUMBER 21 L0L1GETSTATIC java/lang/System.out : Ljava/io/PrintStream;ALOAD 1INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/Object;)VL2L3LINENUMBER 22 L3ALOAD 0ALOAD 1INVOKEVIRTUAL Button.setText (Ljava/lang/String;)VL4LINENUMBER 23 L4RETURNL5LOCALVARIABLE this LButton; L0 L5 0LOCALVARIABLE value Ljava/lang/String; L0 L5 1MAXSTACK = 2MAXLOCALS = 2 通常使用getters和setters访问类成员(fields), 以便编译器内联并直接引用. 但在某种情况下, 比如Android开发过程中, 有时使用getters和setters未必性能最优, 理由如下: Android 4.4及以下版本使用Dalvik虚拟机, Dalvik基于JIT(及时)编译, 意味着每次运行App时, Dalvik将字节码编译成机器码 Android 4.4及以上版本使用功ART(Android Runtime)技术, ART基于AOT(运行前)编译, 意味着App在安装时由字节码编译成机器码 Android 4.4既支持Dalvik, 也支持ART 根据安卓官方性能优化建议, 直接访问fields比在ART中调用getters和setters快三倍, 比在Dalvik中调用getters和setters快7倍. Backing Property与Private限定符可以使用Backing Properties直接访问类成员. 现在重构Button类如下: 12345678910111213141516171819class Button &#123; private var _text: String? = null var text: String set(value) &#123; println(value) _text = value &#125; get() &#123; return _text + _text &#125; var backgroundColor: Int? = null var onClickListener: ((Button) -&gt; Unit)? = null fun printText() &#123; println(_text) &#125;&#125; 将上面这段代码反编译成Java源码如下, 注意到Kotlin为_text属性生成getters和setters方法, 而text没有. 1234567891011121314151617181920212223242526272829303132333435363738394041public final class Button &#123; private String _text; @Nullable private Integer backgroundColor; @Nullable private Function1 onClickListener; @NotNull public final String getText() &#123; return Intrinsics.stringPlus(this._text, this._text); &#125; public final void setText(@NotNull String value) &#123; Intrinsics.checkParameterIsNotNull(value, "value"); System.out.println(value); this._text = value; &#125; @Nullable public final Integer getBackgroundColor() &#123; return this.backgroundColor; &#125; public final void setBackgroundColor(@Nullable Integer var1) &#123; this.backgroundColor = var1; &#125; @Nullable public final Function1 getOnClickListener() &#123; return this.onClickListener; &#125; public final void setOnClickListener(@Nullable Function1 var1) &#123; this.onClickListener = var1; &#125; public final void printText() &#123; String var1 = this._text; System.out.println(var1); &#125;&#125; printText()方法字节码如下, 可以看到printText方法直接引用_text属性. 这也表明Backing Property可以允许你完全访问fields. 123456789101112131415161718public final printText()VL0LINENUMBER 30 L0ALOAD 0GETFIELD Button._text : Ljava/lang/String;ASTORE 1L1GETSTATIC java/lang/System.out : Ljava/io/PrintStream;ALOAD 1INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/Object;)VL2L3LINENUMBER 31 L3RETURNL4LOCALVARIABLE this LButton; L0 L4 0MAXSTACK = 2MAXLOCALS = 2 如果去掉_text前的private关键字, 如下, 猜猜看会发生什么? 123456789101112131415161718class Button &#123; var _text: String? = null var text: String set(value) &#123; println(value) _text = value &#125; get() &#123; return _text + _text &#125; var backgroundColor: Int? = null var onClickListener: ((Button) -&gt; Unit)? = null fun printText() &#123; println(_text) &#125;&#125; 可以通过反编译后的Java源码来验证下, Ops……., Kotlin为_text生成了一对无用的getter和setter— get_text()和set_text方法. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public final class Button &#123; @Nullable private String _text; @Nullable private Integer backgroundColor; @Nullable private Function1 onClickListener; @Nullable public final String get_text() &#123; return this._text; &#125; public final void set_text(@Nullable String var1) &#123; this._text = var1; &#125; @NotNull public final String getText() &#123; return Intrinsics.stringPlus(this._text, this._text); &#125; public final void setText(@NotNull String value) &#123; Intrinsics.checkParameterIsNotNull(value, "value"); System.out.println(value); this._text = value; &#125; @Nullable public final Integer getBackgroundColor() &#123; return this.backgroundColor; &#125; public final void setBackgroundColor(@Nullable Integer var1) &#123; this.backgroundColor = var1; &#125; @Nullable public final Function1 getOnClickListener() &#123; return this.onClickListener; &#125; public final void setOnClickListener(@Nullable Function1 var1) &#123; this.onClickListener = var1; &#125; public final void printText() &#123; String var1 = this._text; System.out.println(var1); &#125;&#125; @JvmField 注解先来看段示例代码, 如下, 使用Kotlin中data class定义一个简单的Point类, 给定俩参数, 坐标x和y 1data class Point(var x: Int, var y: Int) 这段代码反编译成Java源码如下, Kotlin除了为Point类中x,y生成getters和setters外, 还自动生成了copy()、equals()、hashcode() toString()四个方法. 注意到生成的x和y限定符为private, 每次访问x或y时, 实际上分别调用它们的setter和getter方法. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public final class Point &#123; private int x; private int y; public final int getX() &#123; return this.x; &#125; public final void setX(int var1) &#123; this.x = var1; &#125; public final int getY() &#123; return this.y; &#125; public final void setY(int var1) &#123; this.y = var1; &#125; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125; public final int component1() &#123; return this.x; &#125; public final int component2() &#123; return this.y; &#125; @NotNull public final Point copy(int x, int y) &#123; return new Point(x, y); &#125; public String toString() &#123; return "Point(x=" + this.x + ", y=" + this.y + ")"; &#125; public int hashCode() &#123; return this.x * 31 + this.y; &#125; public boolean equals(Object var1) &#123; if (this != var1) &#123; if (var1 instanceof Point) &#123; Point var2 = (Point)var1; if (this.x == var2.x &amp;&amp; this.y == var2.y) &#123; return true; &#125; &#125; return false; &#125; else &#123; return true; &#125; &#125;&#125; 为解决这个问题, 可以使用@JvmField声明, 对Point类重构如下 1data class Point(@JvmField var x: Int, @JvmField var y: Int) 来看下字节码反编译后的Java源码, 可以看到x和y被public关键字修饰, 意味着没有必要为它们生成 getters 和 setters方法. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public final class Point &#123; @JvmField public int x; @JvmField public int y; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125; public final int component1() &#123; return this.x; &#125; public final int component2() &#123; return this.y; &#125; @NotNull public final Point copy(int x, int y) &#123; return new Point(x, y); &#125; public String toString() &#123; return "Point(x=" + this.x + ", y=" + this.y + ")"; &#125; public int hashCode() &#123; return this.x * 31 + this.y; &#125; public boolean equals(Object var1) &#123; if (this != var1) &#123; if (var1 instanceof Point) &#123; Point var2 = (Point)var1; if (this.x == var2.x &amp;&amp; this.y == var2.y) &#123; return true; &#125; &#125; return false; &#125; else &#123; return true; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>JVM And JVM Languages</tag>
        <tag>Kotlin</tag>
        <tag>High Performance Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin高性能实战 (一) -- Kotlin Range]]></title>
    <url>%2Fkt%2Frange%2F</url>
    <content type="text"><![CDATA[之所以想写这个系列的Kotlin笔记, 主要原因在于Kotlin协程丰富了JVM生态. 有人说Kotlin语法像Scala, 但个人感觉Kotlin比Java更像C++, 比如Kotlin在闭包上使用了大量的内联(inline)技巧进行性能优化. 尽管Java也有一些协程相关的包可以用, 但远不如Kotlin协程优雅, 更具表现力. 尽管你可以使用:Akka Actor (或者类似的Actor包)RxJava (或类似的Reactive响应式框架, 比如Vert.x)开发高性能高并发应用程序, 以上抽象均为Message Driven或Event Driven(消息驱动或事件驱动), 但有些业务场景如果考虑使用Event-Driven建模, 未免过于重量级, 于是你需要更加轻量级的替代方案, 比如Future/Promise (异步非阻塞, 本质为占位符(Placeholder), 仅适用于单个值), 比如轻量级线程—协程. 尽管Kotlin协程本质上也是使用JVM线程池进行封装, 但Kotlin协程在JVM生态同等实现中表现出色! 最重要的是, 作为JVM语言, 不仅Java可以使用Kotlin协程, Scala/Groovy/Clojure照样也可使用Kotlin协程. Kotlin Range性能优化建议: 对Range进行遍历时, 尽量避免传入该Range引用进行迭代, 请直接对该Range进行遍历 (见常用方法小节) 使用Range时注意保持类型一致并避免使用nullable(可为空)类型变量 (见性能优化小节) 同样的容器遍历逻辑, 在Range和数组都能实现的情况下, 尽量使用Range (见Benchmark小节) Kotlin RangeKotlin中创建一个range比较简单, 可以使用rangeTo函数 或使用..操作符创建. 这里先给出Kotlin Range的类图, 便于后续源码剖析, 需要指出的是IntProgression中的迭代器方法iterator()虽返回IntIterator, 但其具体实现却由IntIterator的子类IntProgressionIterator实现,在Kotlin源码中IntProgressionIterator为一内部类. LongProgression、CharProgression 与之类似. Kotlin Range常用方法常见方法有: step(), reversed(), rangeTo()等, 如 12345678// `step` for (i in (0..10).step(2)) &#123; println(i)&#125;// `reversed`for (i in 0.rangeTo(10).reversed) &#123; println(i)&#125; 对Range进行遍历时, 避免传入该Range引用, 直接对该Range进行迭代即可, 这样做的话编译器会对字节码进行优化. 123456fun main(args: Array&lt;String&gt;) &#123; val value = args[0] if (value in 0.rangeTo(10)) &#123; print(value) &#125;&#125; 字节码反编译成Java源码如下 12345678910public static final void main(@NotNull String[] args) &#123; Intrinsics.checkParameterIsNotNull(args, "args"); String var2 = args[0]; int value = Integer.parseInt(var2); if (0 &lt;= value) &#123; if (10 &gt;= value) &#123; System.out.println(value); &#125; &#125;&#125; 但如果遍历时传入该range引用, 如下, 将会创建无必要的IntRange对象(或LongRange/CharRange等) 12345678910111213val range = 0..100if (value in range) &#123; print(value)&#125;// JVM字节码对应Java源码/** byte var3 = 0; IntRange range = new IntRange(var3, 100); if (range.contains(value)) &#123; System.out.println(value); &#125; */ Range 性能优化Range可以在when中使用, 如下: 12345678val httpResponseCode: Int = HttpService.responseCodeStr().toIntwhen (httpResponseCode) &#123; in 100..200 -&gt; println("Informational responses") in 200..300 -&gt; println("Success") in 300..400 -&gt; println("Redirection") in 400..500 -&gt; println("Client error") in 500..600 -&gt; println("Server error")&#125; 字节码反编译成Java源码如下, 可以看出整段代码利用if语句对HTTP响应码的Range进行判断, 没有太大性能问题. 123456789101112131415161718192021222324252627282930313233343536373839404142String var2 = HttpService.responseCodeStr();int value = Integer.parseInt(var2);String var3;if (100 &lt;= value) &#123; if (200 &gt;= value) &#123; var3 = "Informational responses"; System.out.println(var3); return; &#125;&#125;if (200 &lt;= value) &#123; if (300 &gt;= value) &#123; var3 = "Success"; System.out.println(var3); return; &#125;&#125;if (300 &lt;= value) &#123; if (400 &gt;= value) &#123; var3 = "Redirection"; System.out.println(var3); return; &#125;&#125;if (400 &lt;= value) &#123; if (500 &gt;= value) &#123; var3 = "Client error"; System.out.println(var3); return; &#125;&#125;if (500 &lt;= value) &#123; if (600 &gt;= value) &#123; var3 = "Server error"; System.out.println(var3); &#125;&#125; 如果改变httpResponseCode类型, 如下: 123456val httpResponseCode: Int? = HttpService.responseCodeStr().toIntOrNull()when (httpResponseCode) &#123; in 100..200 -&gt; println("Informational responses") in 200..300 -&gt; println("Success") // 与上面Kotlin代码一样, 如上&#125; 此时字节码反编译成Java源码如下, IntRange源码后面会覆盖(包括CollectionsKt.contains()等), 现在主要关注代码主逻辑 1234567891011121314151617181920212223242526272829303132Integer value = StringsKt.toIntOrNull(HttpService.responseCodeStr());byte var3 = 100;String var4;if (CollectionsKt.contains((Iterable)(new IntRange(var3, 200)), value)) &#123; var4 = "Informational responses"; System.out.println(var4);&#125; else &#123; short var5 = 200; if (CollectionsKt.contains((Iterable)(new IntRange(var5, 300)), value)) &#123; var4 = "Success"; System.out.println(var4); &#125; else &#123; var5 = 300; if (CollectionsKt.contains((Iterable)(new IntRange(var5, 400)), value)) &#123; var4 = "Redirection"; System.out.println(var4); &#125; else &#123; var5 = 400; if (CollectionsKt.contains((Iterable)(new IntRange(var5, 500)), value)) &#123; var4 = "Client error"; System.out.println(var4); &#125; else &#123; var5 = 500; if (CollectionsKt.contains((Iterable)(new IntRange(var5, 600)), value)) &#123; var4 = "Server error"; System.out.println(var4); &#125; &#125; &#125; &#125;&#125; 可以看到上面这段代码封装了很多东西, 先是将HTTP响应码范围封装成IntRange, 然后强制类型转换成Iterable容器类型, 再调用Kotlin库中CollectionsKt.contains()方法进行判断, 注意到整段逻辑采用大量嵌套的if-else语句实现. 对比上面俩段Java源码, 明显第一段Java代码更加简洁高效. 中间我们做了什么, 不过将一个变量类型由Int改成了Int?. 如果将httpResponseCode转变成Double类型会怎样? 123456val httpResponseCode: Double = HttpService.responseCodeStr().toDouble()when (httpResponseCode) &#123; in 100..200 -&gt; println("Informational responses") in 200..300 -&gt; println("Success") // 与上面Kotlin代码一样, 如上&#125; 字节码反编译成Java源码如下, 和上面改成Int?类型的Java源码类似, 同样面临性能损耗 123456789101112131415161718192021222324252627282930313233String var3 = HttpService.responseCodeStr();double value = Double.parseDouble(var3);byte var5 = 100;String var6;if (RangesKt.intRangeContains((ClosedRange)(new IntRange(var5, 200)), value)) &#123; var6 = "Informational responses"; System.out.println(var6);&#125; else &#123; short var7 = 200; if (RangesKt.intRangeContains((ClosedRange)(new IntRange(var7, 300)), value)) &#123; var6 = "Success"; System.out.println(var6); &#125; else &#123; var7 = 300; if (RangesKt.intRangeContains((ClosedRange)(new IntRange(var7, 400)), value)) &#123; var6 = "Redirection"; System.out.println(var6); &#125; else &#123; var7 = 400; if (RangesKt.intRangeContains((ClosedRange)(new IntRange(var7, 500)), value)) &#123; var6 = "Client error"; System.out.println(var6); &#125; else &#123; var7 = 500; if (RangesKt.intRangeContains((ClosedRange)(new IntRange(var7, 600)), value)) &#123; var6 = "Server error"; System.out.println(var6); &#125; &#125; &#125; &#125;&#125; 解决方式, 在when语句中将Http响应码同样转成Double类型即可, 如下: 12345678val httpResponseCode = HttpService.responseCodeStr().toDouble()when(httpResponseCode) &#123; in 100.0..200.0 -&gt; println("Informational responses") in 200.0..300.0 -&gt; println("Success") in 300.0..400.0 -&gt; println("Redirection") in 400.0..500.0 -&gt; println("Client error") in 500.0..600.0 -&gt; println("Server error")&#125; 对应字节码反编译成Java源码如下: 1234567891011121314151617181920String var3 = HttpService.responseCodeStr();double value = Double.parseDouble(var3);String var5;if (value &gt;= 100.0D &amp;&amp; value &lt;= 200.0D) &#123; var5 = "Informational responses"; System.out.println(var5);&#125; else if (value &gt;= 200.0D &amp;&amp; value &lt;= 300.0D) &#123; var5 = "Success"; System.out.println(var5);&#125; else if (value &gt;= 300.0D &amp;&amp; value &lt;= 400.0D) &#123; var5 = "Redirection"; System.out.println(var5);&#125; else if (value &gt;= 400.0D &amp;&amp; value &lt;= 500.0D) &#123; var5 = "Client error"; System.out.println(var5);&#125; else if (value &gt;= 500.0D &amp;&amp; value &lt;= 600.0D) &#123; var5 = "Server error"; System.out.println(var5);&#125; 结论: 使用Range时注意保持类型一致并避免使用nullable类型变量. Range 源码剖析首先来看段示例代码: 123456fun main(args: Array&lt;String&gt;) &#123; var int = args[0].toInt() if (int in 0..10) &#123; println(int) &#125;&#125; 上面这段代码字节码反编译成Java源码如下, 可以看到这里的range逻辑主要由if语句实现, 对起始值和结束值进行判断. 123456789101112public static final void main(@NotNull String[] args) &#123; // Kotlin会对传入参数进行判断,检测传入入参是否为空 Intrinsics.checkParameterIsNotNull(args, "args"); String var2 = args[0]; int value = Integer.parseInt(var2); if (0 &lt;= value) &#123; if (10 &gt;= value) &#123; System.out.println(value); &#125; &#125;&#125; 假如将传入的命令行参数改成可选, 会怎样? 如下: 123456fun main(args: Array&lt;String&gt;) &#123; val value = args[0].toIntOrNull() if (value in 0..10) &#123; println(value) &#125;&#125; 对应Java源码如下: 123456789public static final void main(@NotNull String[] args) &#123; Intrinsics.checkParameterIsNotNull(args, "args"); Integer value = StringsKt.toIntOrNull(args[0]); byte var2 = 0; if (CollectionsKt.contains((Iterable) (new IntRange(var2, 10)), value)) &#123; System.out.println(value); &#125;&#125; 先对上面代码中contains函数进行源码剖析, 再来看IntRange源码 1234567891011121314151617public operator fun &lt;@kotlin.internal.OnlyInputTypes T&gt; Iterable&lt;T&gt;.contains(element: T): Boolean &#123; if (this is Collection) return contains(element) return indexOf(element) &gt;= 0&#125;// `indexOf` 源码public fun &lt;@kotlin.internal.OnlyInputTypes T&gt; Iterable&lt;T&gt;.indexOf(element: T): Int &#123; if (this is List) return this.indexOf(element) var index = 0 for (item in this) &#123; if (element == item) return index index++ &#125; return -1&#125; 点开IntRange源码, 如下, IntRange继承了IntProgression类并实现了ClosedRange接口. 12345678910111213141516171819202122public class IntRange(start: Int, endInclusive: Int) : IntProgression(start, endInclusive, 1), ClosedRange&lt;Int&gt; &#123; override val start: Int get() = first override val endInclusive: Int get() = last override fun contains(value: Int): Boolean = first &lt;= value &amp;&amp; value &lt;= last override fun isEmpty(): Boolean = first &gt; last override fun equals(other: Any?): Boolean = other is IntRange &amp;&amp; (isEmpty() &amp;&amp; other.isEmpty() || first == other.first &amp;&amp; last == other.last) override fun hashCode(): Int = if (isEmpty()) -1 else (31 * first + last) override fun toString(): String = "$first..$last" companion object &#123; /** An empty range of values of type Int. */ public val EMPTY: IntRange = IntRange(1, 0) &#125;&#125; Ranges.kt源码中还包含了CharRange和LongRange, 类似地, CharRange继承了CharProgression类, LongRange继承了LongProgression类, 它们均实现了ClosedRange接口. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// `ClosedRange`接口 及 `IntProgression`类(`LongProgression`/`CharProgression`有些类似) 源码public interface ClosedRange&lt;T: Comparable&lt;T&gt;&gt; &#123; public val start: T public val endInclusive: T public operator fun contains(value: T): Boolean = value &gt;= start &amp;&amp; value &lt;= endInclusive public fun isEmpty(): Boolean = start &gt; endInclusive&#125;// 可以看到 `IntProgression` 实现了`Iterable` 接口public open class IntProgression internal constructor(start: Int, endInclusive: Int, step: Int) : Iterable&lt;Int&gt; &#123; init &#123; if (step == 0) throw kotlin.IllegalArgumentException("Step must be non-zero") &#125; public val first: Int = start public val last: Int = getProgressionLastElement(start.toInt(), endInclusive.toInt(), step).toInt() public val step: Int = step override fun iterator(): IntIterator = IntProgressionIterator(first, last, step) public open fun isEmpty(): Boolean = if (step &gt; 0) first &gt; last else first &lt; last override fun equals(other: Any?): Boolean = other is IntProgression &amp;&amp; (isEmpty() &amp;&amp; other.isEmpty() || first == other.first &amp;&amp; last == other.last &amp;&amp; step == other.step) override fun hashCode(): Int = if (isEmpty()) -1 else (31 * (31 * first + last) + step) override fun toString(): String = if (step &gt; 0) "$first..$last step $step" else "$first downTo $last step $&#123;-step&#125;" companion object &#123; public fun fromClosedRange(rangeStart: Int, rangeEnd: Int, step: Int): IntProgression = IntProgression(rangeStart, rangeEnd, step) &#125;&#125;// `IntProgressionIterator` 源码如下internal class IntProgressionIterator(first: Int, last: Int, val step: Int) : IntIterator() &#123; private val finalElement = last private var hasNext: Boolean = if (step &gt; 0) first &lt;= last else first &gt;= last private var next = if (hasNext) first else finalElement override fun hasNext(): Boolean = hasNext override fun nextInt(): Int &#123; val value = next if (value == finalElement) &#123; if (!hasNext) throw kotlin.NoSuchElementException() hasNext = false &#125; else &#123; next += step &#125; return value &#125;&#125; Kotlin Range 性能测试结合上面的源码剖析, 由于IntRange类继承了IntProgression类, 而IntProgression实现了Iterable接口, 因此可以对IntRange调用forEach方法, 类似地, LongRange、CharRange同样也可以调用forEach方法. 下面对Range做些性能测试: 123456789101112131415161718192021222324252627282930val range = 0..1_000val array = Array(1_000) &#123; it &#125;@Benchmarkfun rangeLoop(blackhole: Blackhole) &#123; range.forEach &#123; blackhole.consume(it) &#125;&#125;@Benchmarkfun rangeSequenceLoop(blackhole: Blackhole) &#123; range.asSequence().forEach &#123; blackhole.consume(it) &#125;&#125;@Benchmarkfun arrayLoop(blackhole: Blackhole) &#123; array.forEach &#123; blackhole.consume(it) &#125;&#125;@Benchmarkfun arraySequenceLoop(blackhole: Blackhole) &#123; array.asSequence().forEach &#123; blackhole.consume(it) &#125;&#125; 输出结果如下, 可以看到range版本循环要快于数组 12345Benchmark Mode Cnt Score Error UnitsrangeLoop avgt 200 3156.754 ± 27.725 ns/oprangeSequenceLoop avgt 200 5286.066 ± 81.330 ns/oparrayLoop avgt 200 2640.670 ± 8.357 ns/oparraySequenceLoop avgt 200 2817.694 ± 44.780 ns/op 整段代码字节码反编译Java源码如下, 可以看到range先被强制类型转化为Iterable类型, 然后再调用迭代器方法并使用while循环进行迭代,这也在一定程度上解释了range遍历要快于数组. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Benchmarkpublic final void rangeLoop(@NotNull Blackhole blackhole) &#123; Intrinsics.checkParameterIsNotNull(blackhole, "blackhole"); Iterable $receiver$iv = (Iterable)MyBenchmarkKt.getRange(); Iterator var3 = $receiver$iv.iterator(); // `rangeLoop`使用`while`循环, 而`arrayLoop`使用简单的`for`循环 while(var3.hasNext()) &#123; int element$iv = ((IntIterator)var3).nextInt(); blackhole.consume(element$iv); &#125;&#125;@Benchmarkpublic final void rangeSequenceLoop(@NotNull Blackhole blackhole) &#123; Intrinsics.checkParameterIsNotNull(blackhole, "blackhole"); Sequence $receiver$iv = CollectionsKt.asSequence((Iterable)MyBenchmarkKt.getRange()); Iterator var3 = $receiver$iv.iterator(); while(var3.hasNext()) &#123; Object element$iv = var3.next(); int it = ((Number)element$iv).intValue(); blackhole.consume(it); &#125;&#125;@Benchmarkpublic final void arrayLoop(@NotNull Blackhole blackhole) &#123; Intrinsics.checkParameterIsNotNull(blackhole, "blackhole"); Object[] $receiver$iv = (Object[])MyBenchmarkKt.getArray(); int var3 = $receiver$iv.length; for(int var4 = 0; var4 &lt; var3; ++var4) &#123; Object element$iv = $receiver$iv[var4]; int it = ((Number)element$iv).intValue(); blackhole.consume(it); &#125;&#125;@Benchmarkpublic final void arraySequenceLoop(@NotNull Blackhole blackhole) &#123; Intrinsics.checkParameterIsNotNull(blackhole, "blackhole"); Sequence $receiver$iv = ArraysKt.asSequence((Object[])MyBenchmarkKt.getArray()); Iterator var3 = $receiver$iv.iterator(); while(var3.hasNext()) &#123; Object element$iv = var3.next(); int it = ((Number)element$iv).intValue(); blackhole.consume(it); &#125;&#125; 再来看个例子, 在range上调用高阶函数, 如下: 123456789101112131415161718192021222324@Benchmarkfun rangeLoop(blackhole: Blackhole) = range .map &#123; it * 2 &#125; .first &#123; it % 2 == 0 &#125;@Benchmarkfun rangeSequenceLoop(blackhole: Blackhole) = range.asSequence() .map &#123; it * 2 &#125; .first &#123; it % 2 == 0 &#125;@Benchmarkfun arrayLoop(blackhole: Blackhole) = array .map &#123; it * 2 &#125; .first &#123; it % 2 == 0 &#125;@Benchmarkfun arraySequenceLoop(blackhole: Blackhole) = array.asSequence() .map &#123; it * 2 &#125; .first &#123; it % 2 == 0 &#125; 测试结果如下, 同样range版本高阶方法迭代要快于数组. 12345Benchmark Mode Cnt Score Error UnitsrangeLoop avgt. 200 8268.058 ± 179.797 ns/oprangeSequenceLoop avgt 200 16.109 ± 0.128 ns/oparrayLoop avgt 200 6490.003 ± 124.134 ns/oparraySequenceLoop avgt 200 14.841 ± 0.483 ns/op]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>JVM And JVM Languages</tag>
        <tag>Kotlin</tag>
        <tag>High Performance Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin高性能实战 (四) -- Kotlin Delegate (Part One)]]></title>
    <url>%2Fkt%2Fdlgt-class%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>JVM And JVM Languages</tag>
        <tag>Kotlin</tag>
        <tag>High Performance Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache Phoenix Query Server]]></title>
    <url>%2Fbigdata%2Fhbase%2Fpqs%2F</url>
    <content type="text"><![CDATA[Apache Phoenix客户端默认通过JDBC driver连接Phoenix, 对于非JVM语言而言存在连接问题, 并且在Phoenix客户端执行查询计划、结果处理等影响客户进程, JDBC driver默认充当一Thick Client. 为解决这一问题, 引入Phoenix Query Server(PQS), 其架构示意图如下, PQS允许客户端充当一Thin Client, 可水平拓展, PQS无状态. PQS作为一HTTP服务支持JSON和Protocol Buffer, 但默认使用Protocol Buffer(比JSON使用更加高效), Thin Client底层通过Apache Calcite’s Avatica组件实现, Avatica实现中服务端为HTTP Server, 而客户端为一简单的JDBC driver. PQS通过引入中间这层协议, 可以支持其它非JVM语言. 客户端配置PQS中Thin Client, 默认协议URL构造形式为jdbc:phoenix:thin:url=&lt;scheme&gt;://&lt;server-hostname&gt;:&lt;port&gt;, PQS常见配置属性如下: 属性 值 schema http server-host-name server主机名 port http端口 运行PQS服务在HBase RegionServer节点上运行PQS, 首先需导出以下环境变量: 1234# 写入 ∼/.ssh/bash_profile 或 ∼/.ssh/.bashrcexport HBASE_CONF_DIR=&lt;path_to_hbase_conf&gt;export PHOENIX_LIB_DIR=&lt;path_to_phoenix_lib_directory&gt;export HADOOP_CONF_DIR=&lt;path_to_hadoop_conf&gt; 在Phoenix安装目录, 运行PQS参考指令如下: 1$ bin/queryserver.py [start|stop|makeWinServiceDesc] [-Dhadoop=configs] 后台运行, 可键入以下指令: 1$ bin/queryserver.py start background PQS内部开启Jetty HTTP服务(端口默认为8765), 如需改变端口, 修改配置文件hbase-site.xml中phoenix.queryserver.http.port属性. PQS使用可以运行sqlline-thin.py脚本, 开始与PQS通信, 参考指令如下: 1$ bin/sqlline-thin.py &lt;http_query_server_url&gt; &lt;sql_file&gt; 使用PQS服务, 先准备一SQL文件, 然后通过PQS服务提交并运行对应SQL, 文件中SQL语句如下: 123456789-- emp_ddl.sql, 创建一张职员表CREATE TABLE IF NOT EXISTS EMPLOYEE ( EMP_ID INTEGER NOT NULL, EMP_NAME VARCHAR, CONTACT VARCHAR, HIRE_DATE DATE, SALARY INTEGER, CONSTRAINT PK PRIMARY KEY (EMP_ID)); 通过PQS执行以上这段SQL语句, 参考指令如下: 1$ bin/sqlline-thin.py http://localhost:8765 emp_ddl.sql 执行成功后, 可以通过以下指令查看职员表Schema: 1$ bin/sqlline-thin.py http://localhost:8765 QPS小结PQS支持连接HBase集群, 由于PQS内部封装了一HTTP Server, 可与负载均衡器结合使用获取高可用. 有关PQS使用, 需注意以下两点: PQS在有关JSON API数据传输方面, 不能保证向下兼容(Backwards Compatibility), 若使用Protocol Buffer, 可以保证向下兼容. Query Server从HBase RegionServer收集数据并Stream至客户端, 通常数据是无序的; 如需保证数据有序, 需在HBase配置文件hbase-site.xml中指定phoenix.query.force.rowkeyorder参数值.]]></content>
      <categories>
        <category>Distributed System</category>
      </categories>
      <tags>
        <tag>Big Data</tag>
        <tag>Apache Phoenix</tag>
        <tag>Apache HBase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Query Engine大作战 -- Apache Drill之复杂数据分析]]></title>
    <url>%2Fbigdata%2Fdrill%2Fanalysis%2F</url>
    <content type="text"><![CDATA[本文将介绍Apache Drill中一些常见的复杂数据分析. 复杂数据结构Drill支持复杂数据结构, 如Array和Map等. Drill中Array与大多数编程语言有些类似, 如数组下标从0开始而非从1开始, 示例SQL如下: 123-- 查询CSV格式数据SELECT col[0] AS shop_nameFROM dfs.ecomm_data.`ecomm_shops.csv`; 当然也可使用数组读取JSON数据, 比如JSON中有些字段为数组类型. 通常使用Map作为JSON数据容器, 比如下面这段SQL中ua字段为一Map, Drill中可以通过: Map.FieldName 形式访问Map中Value. 12345678910-- 查看不同浏览器PV分布SELECT uadat.ua.AgentNameVersion AS Browser, COUNT(*) AS BrowserCountFROM ( SELECT parse_user_agent(`request_user-agent`) AS ua FROM dfs.httpd_logs.`log_data/ecomm.httpd`) AS uadatGROUP BY uadat.ua.AgentNameVersionORDER BY BrowserCount DESC; JSON数据分析如果JSON或其他嵌套数据格式化合理(能准确推断出数据类型), Apache Drill支持JSON数据查询与分析. Drill解析问题Drill默认将带小数点数字解析为Double类型, 不带小数点数字解析为BigInt; Drill默认不支持Map中Field为混合类型, 如果用户JSON数据中存在以上两个问题, 可能导致Schema解析错误, 无法成功解析JSON或分析. Apache Drill有俩配置项, 可预防这种问题, 如设置store.json.read_number_as_double为true, 可避免数字格式化错误. 1ALTER SESSION SET `store.json.read_number_as_double` = true; 可以设置store.json.all_text_mode为true, 将所有Field解析为Varchar类型, 避免JSON字段中混合类型导致的解析错误. 1ALTER SESSION SET `store.json.all_text_mode` = true; 但如果JSON数据中确实存在混合类型, 又不想所有的Field被Drill解析为Varchar类型, 可以考虑Drill新引入的Union类型(处于测试阶段, 不稳定), 允许JSON数据中同一Field拥有不同类型, 配置参考如下: 1ALTER SESSION SET `exec.enable_union_type` = true; FLATTEN()Drill提供一比较实用函数FLATTEN(), 可将嵌套的JSON数据字段展开, 假定JSON数据样本(empl.json)如下: 1234567891011121314151617181920212223242526272829&#123; "columns": [ "first_name", "last_name", "birthday" ], "data": [ [ "Robert", "Hernandez", "5/3/81" ], [ "Steve", "Smith", "8/4/84" ], [ "Anne", "Raps", "9/13/91" ], [ "Alice", "Muller", "4/15/88" ] ]&#125; 将上面这段嵌套的JSON样本数据中data字段展开, 参考如下: 123456789SELECT col_fields[0] AS first_name, col_fields[1] AS last_name, col_fields[2] AS birthdayFROM( SELECT FLATTEN(data) AS col_fields FROM dfs.employee_data.`empl.json`) AS employee_data first_name last_name birthday Robert Hernandez 5/3/81 Steve Smith 8/4/84 Anne Raps 9/13/91 Alice Muller 4/15/88 KVGEN()Drill还提供另一实用函数KVGEN(), 支持访问面向列存储的JSON数据, 该函数返回一数组, 数组中每项元素为KV键值对. 假定样本数据(empl_cols.json)如下: 1234567891011121314151617181920&#123; "first_name": &#123; "0":"Robert", "1":"Steve", "2":"Anne", "3":"Alice" &#125;, "last_name": &#123; "0":"Hernandez", "1":"Smith", "2":"Raps", "3":"Muller" &#125;, "birthday": &#123; "0":"5/3/81", "1":"8/4/84", "2":"9/13/91", "3":"4/15/88" &#125;&#125; 将样本数据中FirstName值抽取出来, 参考如下: 12SELECT FLATTEN(KVGEN(first_name))['value'] AS first_nameFROM dfs.employee_data.`empl_cols.json` firstname Robert Steve Anne Alice 日志数据分析新版Drill支持读取和查询Apache Web服务器日志(Drill内部嵌入了HTTPD解释器), 可以通过Apache Drill对这些日志数据进行聚合或Join等操作. 为了正常读取Web服务器日志, 需对Drill支持的可插拔存储进行相关配置. 通常Apache Web Server配置路径为/etc/apache2/apache2.conf, 该配置文件中有一项LogFormat(日志格式)配置, 参考如下: 1LogFormat "%h %l %u %t \"%r\" %&gt;s %O \"&#123;Referer&#125;i\" \"%&#123;User-Agent&#125;i"" 拷贝该项配置, 打开Web Console点击可插拔存储(如dfs等)配置, 贴到logFormat配置中, 参考如下: 12345"httpd": &#123; "type": "httpd", "logFormat": "%h %l %u %t \"%r\" %&gt;s %O \"&#123;Referer&#125;i\" \"%&#123;User­Agent&#125;i\"", "timestampFormat": null&#125; 以上Web日志格式中, 常见字段(Format String)说明如下:配置字段名说明%h远程主机名, 若HostnameLookups设置为off, 默认记录IP地址%l远程日志名(源自identd, 如果存在的话), 通常需设置mod_ident和IdentityCheck为On%r请求第一行%s状态(Status), 源请求状态, 使用%&gt;s作为最终状态%t接收请求时间%u若为验证请求记录远程用户, 非验证请求为401%O发送字节(包括头部), 如果请求被丢弃有可能为0, 使用时需开启mod_logio%{VARNAME}i变量名(VARNAME)内容, 发送至Server请求的Header行 配置完成后, 可以开始查询Web Server日志, 以下为部分Web日志样本, 参考如下: 1234567835.154.11.105 ­ ­ [21/Oct/2014:04:11:25 +0100] \"GET /linux/doing­pxe­without­dhcp­control HTTP/1.1" 200 24323 \"http://your.ecomm.site.com/" "Mozilla/5.0 (Windows NT 5.1; rv:35.0) \Gecko/20100101 Firefox/35.0"37.86.201.166­ ­ [21/Oct/2014:04:11:26 +0100] \"GET /join_form HTTP/1.0" 200 11114 "http://your.ecomm.site.com/" \"Mozilla/5.0 (Windows NT 5.1; rv:35.0) Gecko/20100101 Firefox/35.0" 查询日志中所有可见Fields: 123SELECT * FROM dfs.httpd_logs.`log_data/ecomm.httpd`LIMIT 20; 分析用户代理(User Agent, 包括浏览器标识,操作系统标识,渲染引擎,版本信息等字段)类型: 12SELECT `request_user-agent`FROM dfs.httpd_logs.`log_data/ecomm.httpd`; 直接解析用户代理文本字符串, 有些费劲, 但Drill提供了一Util方法parse_user_agent, 返回一Map包含User Agent明细数据. 以下SQL查看不同浏览器PV分布: 123456789SELECT uadat.ua.AgentNameVersion AS Browser, COUNT(*) AS BrowserCountFROM ( SELECT parse_user_agent(`request_user-agent`) AS ua FROM dfs.httpd_logs.`log_data/ecomm.httpd`) AS uadatGROUP BY uadat.ua.AgentNameVersionORDER BY BrowserCount DESC; Web Server日志中, 通常request_referer包含了URL, 可以通过parse_url()函数对URL进行解析, SQL参考如下: 12345-- parse_url(`request_referer`)返回URL协议、主机、路径-- 等URL相关信息, 该函数返回结果为一MapSELECT `request_referer`, parse_url(`request_referer`)FROM dfs.httpd_logs.`log_data/ecomm.httpd`WHERE `request_referer` IS NOT NULL parse_query()函数, 可用于网络攻防日志分析, 如通过URL来源鉴定是否为可疑攻击等: 1234567SELECT qmap.query_map.`came_from` AS came_fromFROM ( SELECT parse_query(`request_referer_query`) AS query_map FROM dfs.httpd_logs.`log_data/ecomm.httpd` WHERE LENGTH(`request_referer_query`) &gt; 0) AS qmapWHERE qmap.query_map.`came_from` IS NOT NULL; 除了Web Server日志, Drill还可分析关系型数据库日志, 如MySQL日志数据等. 当然, 为成功解析MySQL日志, 需对Drill读取日志文件的可插拔存储增加一些配置, 如与上例中HTTPD日志类似的Schema解析与字段说明, 必要时需给出合理的正则解析. 配置成功后, 可以使用Drill解析MySQL日志, 参考如下:1SELECT * FROM dfs.mysql.`mysql.log`;]]></content>
      <categories>
        <category>Distributed System</category>
      </categories>
      <tags>
        <tag>Apache Drill</tag>
        <tag>Big Data</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flink学习手札之Stream Window小结篇]]></title>
    <url>%2Fbigdata%2Fflink%2Fwindow%2F</url>
    <content type="text"><![CDATA[Youtube上观看的Flink学习笔记, 有段时间了, 由于是边看视频边记得笔记, 逻辑有些乱, 还请见谅! 有时间再重新整理下! Window生命周期 Item 说明 Window Content 窗口内容,或ReduceFunction/AggregateFunction窗口operator增量聚合结果 Window Object 窗口算子基于返回对象对数据进行分组,窗口对象用于区分不同窗口.每个窗口对象拥有基于哪个窗口之后的端点时间戳及可以删除的状态 Trigger计时器 Trigger可注册在某个时间点调用的计时器如计算一个窗口还是清空内容.这些计时器由窗口操作符维护 Trigger自定义状态 Trigger可以定义per-window/per-key或自定义状态,这些状态完全由Trigger控制,不用window operator维护 当窗口算子删除一个要结束的Window时(到达窗口对象定义的结束时间戳), 具体发生于ProcessingTime还是EventTime语义取决于WindowAsssigner.isEventTime()返回值. 删除一个窗口时,自动清除窗口内容并丢弃窗口对象, 并不会清除自定义Trigger状态及注册的触发计时器(对于窗口操作符而言并不透明). 可以通过Trigger.clear()防止状态泄露. AssignerGobalWindows Assigner映射所有数据至同一全局窗口, 默认Trigger为NeverTrigger, 实现上须指定自定义Trigger及Evictor. GlobalWindows结束时间戳为Long.MAX_VALUE, 导致其从不被完全清空掉. 对于不断演变发展的KeyedStream, GlobalWindows为每个key维护某些状态, 需谨慎使用. MergingWindowAssigner接口继承了WindowAssigner接口, 用于Merge窗口算子. WindowAssigner的Flink源码, 参考如下: 12345678910111213public abstract class WindowAssigner&lt;T, W extends Window&gt; implements Serializable &#123; // Returns a collection of windows to which the element is assigned public abstract Collection&lt;W&gt; assignWindows(T element,long timestamp, WindowAssignerContext context); public abstract Trigger&lt;T, W&gt; getDefaultTrigger(StreamExecutionEnvironment env); public abstract TypeSerializer&lt;W&gt; getWindowSerializer(ExecutionConfig executionConfig); // Indicates whether this assigner creates event-time windows public abstract boolean isEventTime(); // A context that gives access to the current processing time public abstract static class WindowAssignerContext &#123; public abstract long getCurrentProcessingTime(); &#125; &#125; 以下代码为实现一30秒滚动窗口的WindowAssigner 123456789101112131415type winAsgnCtx = WindowAssigner.WindowAssignerContextclass ThirtySecondsWindows extends WindowAssigner[Object, TimeWindow] &#123; val windowSize: Long = 30 * 1000L override def assignWindows(o: Object, ts: Long, ctx: winAsgnCtx): java.util.List[TimeWindow] = &#123; val startTime = ts - (ts % windowSize) val endTime = startTime + windowSize Collections.singletonList(new TimeWindow(startTime, endTime)) &#125; override def getWindowSerializer(executionConfig: ExecutionConfig): TypeSerializer[TimeWindow] = &#123; new TimeWindow.Serializer &#125; override def getDefaultTrigger(env: envirnoment.StreamExecutionEnvironment): Trigger[Object, TimeWindow] = &#123; EventTimeTrigger.create() &#125; override def isEventTime = true&#125; TriggerMergable Triggers只能使用可以自动聚合的状态原语, 如ListState, ReduceState或AggregatingState. Trigger可以访问时间属性及计时器, 也可访问状态, 每次调用Trigger时返回TriggerResult, TriggerResult有以下值: 选项 说明 CONTINUE 不采取行动 FREE 若窗口算子拥有ProcessWindowFunction,调用函数返回结果; 若为增量聚合函数ReduceFunction/AggregateFunction,仅触发当前聚合结果.窗口状态并不会改变 PURGE 完全丢弃窗口内容并移除所有元数据, 调用ProcessWindowFunction.clear()清除所有自定义的per-window状态 FIRE_AND_PURGE 首先计算窗口, 然后接着移除所有状态及元数据 其中, Trigger的Flink源码, 参考如下: 123456789101112131415161718192021222324252627282930313233343536373839public abstract class Trigger&lt;T, W extends Window&gt; implements Serializable &#123; //源码 // Called for every element that gets added to a window TriggerResult onElement(T element, long timestamp, W window, TriggerContext ctx); // Called when a processing-time timer fires public abstract TriggerResult onProcessingTime(long timestamp, W window, TriggerContext ctx); // Called when an event-time timer fires public abstract TriggerResult onEventTime(long timestamp, W window, TriggerContext ctx); // Returns true if this trigger supports merging of trigger state public boolean canMerge(); // Called when several windows have been merged into one window // and the state of the triggers needs to be merged public void onMerge(W window, OnMergeContext ctx); // Clears any state that the trigger might hold for the given window public abstract void clear(W window, TriggerContext ctx); &#125; // A context object that is given to Trigger methods to allow them // to register timer callbacks and deal with state public interface TriggerContext &#123; long getCurrentProcessingTime(); long getCurrentWatermark(); void registerProcessingTimeTimer(long time); void registerEventTimeTimer(long time); void deleteProcessingTimeTimer(long time); void deleteEventTimeTimer(long time); // Retrieves a state object that is scoped to the window and the key of the trigger &lt;S extends State&gt; S getPartitionedState(StateDescriptor&lt;S, ?&gt; stateDescriptor); &#125; // Extension of TriggerContext that is given to the Trigger.onMerge() method public interface OnMergeContext extends TriggerContext &#123; // Merges per-window state of the trigger // The state to be merged must support merging void mergePartitionedState(StateDescriptor&lt;S, ?&gt; stateDescriptor); &#125; 如何使用Trigger, 以下为一个小例子: 1234567891011121314151617181920212223242526272829303132333435type TrgCtx = Trigger.TriggerResultclass OneSecondIntervalTrigger extends Trigger[SensorReading, TimeWindow] &#123; val firstSeenDesc = new ValueStateDescriptor[Boolean]("firstSeen", classOf[Boolean]) override def onElment(r: SensorReading, timestamp: Long, window: TimeWindow, ctx: TrgCtx): TriggerResult = &#123; val firstSeen: ValueState[Boolean] = ctx.getPartitionedState(firstSeenDesc) if (!firstSeen.value()) &#123; val t = ctx.getCurrentWatermark + (1000 - (ctx.getCurrentWatermark % 100)) ctx.registerEventTimeTimer(t) ctx.registerEventTimeTimer(window.getEnd) // register timer for the window end firstSeen.update(true) &#125; TriggerResult.CONTINUE &#125; override def onEventTime(timestamp: Long, window: TimeWindow, ctx: TrgCtx): TriggerResult = &#123; if (timestamp == wind.getEnd) &#123; TriggerResult.FIRE_AND_PURGE &#125; else &#123; val t = ctx.getCurrentWatermark + (1000 - (ctx.getCurrentWatermak % 100)) if (t &lt; window.getEnd) &#123; ctx.registerEvenTimeTimer(t) &#125; TriggerResult.FIRE &#125; &#125; override def onProcessingTime(timestamp: Long, window: TimeWindow, ctx:TrgCtx): TriggerResult = &#123; TriggerResult.CONTINUE // dont't process processing time timers &#125; override def clear(window: TimeWindow, ctx: TrgCtx): Unit = &#123; val firstSeen: ValueState[Boolean] = ctx.getPartitionedState(firstSeenDesc) firstSeen.clear() // clear trigger state. 由于使用的是`ValueState`, 该Trigger不可合并(non-mergable) &#125;&#125; EvictorEvictor的Flink源码, 参考如下: 123456789101112131415161718192021222324/**Evictors常用于`GlobalWindow`清理部分窗口而非清除整个窗口状态. 可以在窗口计算之前或之后移除部分数据 * Evictors不适用于`ReduceFunction`/`AggregateFunction`对窗口进行增量聚合. 源码参考如下 */public interface Evictor&lt;T, W extends Window&gt; extends Serializable &#123; // Optionally evicts elements. Called before windowing function. void evictBefore( Iterable&lt;TimestampedValue&lt;T&gt;&gt; elements, int size, W window, EvictorContext evictorContext); //EvictorContext提供当前处理时间及水印的访问途径 // Optionally evicts elements. Called after windowing function. void evictAfter( Iterable&lt;TimestampedValue&lt;T&gt;&gt; elements, int size, W window, EvictorContext evictorContext); // A context object that is given to Evictor methods. interface EvictorContext &#123; long getCurrentProcessingTime(); // Returns the current event time watermark. long getCurrentWatermark(); &#125; 窗口算子及类型主要有两类: Keyed Stream及Non-Keyed Stream. keyed stream window nonkeyed stream window 并行计算 单线程处理 创建一窗口算子, 需指定Window Assigner及Window Function. WindowAssigner决定窗口输入流数据Record如何分组, 通常返回WindowStream及AllWindowedStream(Nonkeyed Stream). WindowFunction适用于WindowStream或 AllWindowedStream, 处理窗口内数据Record. 示例代码, 参考如下: 12inputStream.keyBy(...).window(...).reduce/aggregate/process(...) // keyed streaminputStream.windowAll(...).reduce/aggregate/process(...) // nonkeyed stream 除了基于时间窗口,Flink也支持Count-based Window, 由于依赖于消费顺序,计数窗口无序,使用时需指定自定义Trigger对窗口进行维护. 123456789101112131415161718192021val sensorData: DataStream[SensorReading] = ...// Tumbling Windowval avgTemp = sensorData.keyBy(_.id) //或使用便捷方式 .timeWindow(Time.seconds(1)), 也可指定时间偏移offset(第二个时间参数) //如 .window(TumblingEventTimeWindows.of(Time.hours(1), Time.minutes(15))) // TumblingProcessingTimeWindows.of(Time.seconds(1)) .window(TumblingEventTimeWindows.of(Time.seconds(1))) .process(new TemperatureAverager)// Sliding Windowval slidingAvgTemp = sensorData.keyBy(_.id) //可以使用便捷方式 .window(Time.hours(1), Time.minutes(15)) // SlidingProcessingTimeWindows.of(Time.hours(1), Time.minutes(15)) .window(SlidingEventTimeWindows.of(Time.hours(1), Time.minutes(15))) .process(new TemperatureAverager)// Session Window, Session Gap时间范围内不接受Record,不活跃(inactivity)val sessionWindows = sensorData.keyBy(_.id) // ProcessingTimeSessionWindows.withGap(Time.minutes(15)) .window(EventTimeSessionWindows.withGap(Time.minutes(15))) .process(...) 窗口类型, 主要有三大类: Tumbing Window(滚动窗口), Sliding Window(滑动窗口)以及Session Window(会话窗口). Tumbing Window Sliding Window Session Window 常见窗口函数 类型 函数 Incremental Aggregate Functions ReduceFunction,AggregateFunction Full Window Functions ProcessWindowFunction ReduceFunction示例代码, 参考如下: 1234val minTempPerWindow: DataStream[(String, Double)] = sensorData.map&#123; r =&gt; (r.id, r.temperature)&#125; .keyBy(_._1) .timeWindow(Time.seconds(15)) .reduce&#123;(r1, r2) =&gt; (r1._1, r1._2.min(r2._2))&#125; AggregateFunctionAggregateFunction 接口, Flink源码参考如下: 12345678public interface AggregateFunction&lt;IN, ACC, OUT&gt; extends Function, Serializable &#123; ACC createAccumulator(); // add an input element to the accumulator and return the accumulator. ACC add(IN value, ACC accumulator); OUT getResult(ACC accumulator); // merge two accumulators and return the result.= ACC merge(ACC a, ACC b); &#125; 使用示例代码, 参考如下: 123456789101112131415161718val avgTempPerWindow: DataStream[(String, Double)] = sensorData.map &#123; r =&gt; (r.id, r.temperature)&#125; .keyBy(_._1) .timeWindow(Time.seconds(15)) .aggregate(new AvgTempFunction)class AvgTempFunction extends AggregateFunction[(String, Double), (String, Double, Int), (String, Double)] &#123; val initVal = ("", 0.0, 0) override def createAccumulator() = initVal override def add(in: (String, Double, acc:(String, Double, Int))) = &#123; (in._1, in._2 + acc._2, 1 + acc._3) &#125; override def merge(acc1: (String, Double, Int), acc2: (String, Double, Int)) = &#123; (acc1._1, acc1._2 + acc2._2, acc1._3 + acc2._3) &#125; override def getResult(acc: (String, Double, Int)) = &#123; (acc._1, acc._2 / acc._3) &#125;&#125; ProcessWindowFunction通过Context对象访问当前处理时间及事件时间及Side outputs, 窗口元数据通常包括可用于窗口标识符信息如开始和结束时间戳. ProcessWindowFunction存储所有Events至ListState, 该抽象类, Flink源码参考如下: 123456789101112131415161718192021public abstract class ProcessWindowFunction&lt;IN, OUT, KEY, W extends Window&gt; extends AbstractRichFunction &#123; // Evaluates the window void process(KEY key, Context ctx, Iterable&lt;IN&gt; vals, Collector&lt;OUT&gt; out) throws Exception; // Deletes any custom per-window state when the window is purged public void clear(Context ctx) throws Exception &#123;&#125; // The context holding window metadata public abstract class Context implements Serializable &#123; // Returns the metadata of the window public abstract W window(); public abstract long currentProcessingTime(); // Returns the current event-time watermark public abstract long currentWatermark(); // State accessor for per-window state public abstract KeyedStateStore windowState(); // State accessor for per-key global state public abstract KeyedStateStore globalState(); // Emits a record to the side output identified by the OutputTag. public abstract &lt;X&gt; void output(OutputTag&lt;X&gt; outputTag, X value); &#125; 以下代码计算每5秒Tumbling窗口内最高最低温度 12345678910111213case class MinMaxTemp(id: String, min: Double, max: Double, endTs: Long)val minMaxTempPerWindow: DataStream[MinMaxTemp] = sensorData.keyBy(_.id) .timeWindow(Time.seconds(5)) .process(new HighAndLowTempProcessFunction)class HighAndLowTempProcessFunction extends ProcessWindowFunction[SensorReading, MinMaxTemp, String, TimeWindow] &#123; override def process(key: String, ctx: Context, vals: Iterable[SensorReading], out: Collector[MinMaxTemp]): Unit = &#123; val temps = vals.map(_.temperature) val windowEnd = ctx.window.getEnd val minMaxTemp = MinMaxTemp(key, temps.min, temps.max, windowEnd) out.collect(minMaxTemp) &#125;&#125; 窗口增量聚合函数ProcessWindowFunction虽然强大, 但需谨慎使用, 该函数通常容纳比增量聚合函数更多状态数据. 如需应用增量聚合逻辑并访问窗口元数据, 可以结合使用ReduceFunction或AggregateFunction. 当窗口触发器触发时, 分配至窗口的数据立即聚合, 聚合结果会立即由ProcessWindowFunction处理. 示例代码, 参考如下: 12345678910111213141516171819202122232425input.keyBy(...) .timeWindow(...) //.aggregate(incrAggregator: AggregateFunction[IN, ACC, V], windowFunction: ProcessWindowFunction[V, OUT, K, W]) .reduce(incrAggregator: ReduceFunction[IN], function: ProcessWindowFunction[IN, OUT, K, W]) //case class MinMaxTemp(id: String, min: Double, max: Double, endTs: Long) val incrAgg = (r1: (String, Double, Double), r2: (String, Double, Double)) =&gt; &#123; (r1._1, r1._2.min(r2._2), r1._3.max(r2._3)) &#125; val minMaxTempPerWindow2: DataStream[MinMaxTemp] = sensorData.map &#123;r =&gt; (r.id, r.temperature, r.temperature)&#125; .keyBy(_._1) .timeWindow(Time.seconds(5)) .reduce(incrAgg, new AssignWindowEndProcessFunction()) class AssignWindowEndProcessFunction extends ProcessWindowFunction[(String, Double, Double), MinMaxTemp, String, TimeWindow] &#123; override def process(key: String, ctx: Context, minMaxIt: Iterable[(String, Double, Double)], out: Collector[MinMaxTemp]): Unit = &#123; val minMax = minMaxIt.head val windowEnd = ctx.window.getEnd out.collect(MinMaxTemp(key, minMax._2, minMax._3, windowEnd)) &#125; &#125; 窗口Join 1234567891011// Interval Joininput.keyBy(0).between(lowerBound, upperBound).process(ProcessJoinFunction)// Window Joininput1.join(input2) .where(...) //Specify key attributes for input1 .equalTo(...) //Specify key attributes for input2 .window(...) //Specify the WindowAssigner .trigger(...) //Optional: specify a Trigger .evictor(...) //Optional: specify a Evictor .apply(...) //Specify the JoinFunction 处理延迟数据通常有以下三种方式用于处理延迟数据: 简单丢弃 （EventTime窗口算子默认丢弃） 重定向至其它Stream 基于延迟事件更新计算结果, 触发更新 示例代码, 参考如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//重定向延迟事件, 比如可以通过DataStream中side-output特性重定向,延迟事件可以通过常用的sink函数处理或触发//基于具体业务逻辑,可以将延迟数据嵌入至周期性Backfill流式进程中val readings: DataStream[SensorReading] = ???val lateReadingOutputTag = new OutputTag[SensorReading]("late-readings")val countPer10Secs: DataStream[(String, Long, Int)] = readings.keyBy(_.id).timeWindow(Time.seconds(10)) .sideOutputLateData(lateReadingOutputTag) .process(new CountFunction())val lateStream: DataStream[SensorReading] = countPer10Secs.getSideOutput(lateReadingOutputTag)// filter late sensor readings and redirects to a side outputval filterReadings: DataStream[SensorReading] = readings.process(new LateReadingsFilter)val lateReadings: DataStream[SensorReading] = filterReadings.getSideOutput(lateReadingOutputTag)class LateReadingsFilter extends ProcessFunction[SensorReading, SensorReading] &#123; val lrOutputTag = lateReadingOutputTag override def processRlement(in: SensorReading, ctx: ProcessFunction[SensorReading, SensorReading]#Context, out: Collector[SensorReading]): Unit = &#123; // late reading =&gt; redirect to the side output if (in.timestamp &lt; ctx.timerService().currentWatermark()) &#123; ctx.output(lrOutputTag, in) &#125; else &#123; out.collect(in) &#125; &#125;&#125;// 基于延迟事件, 触发更新type OT = (String, Long, Int, String)val countPer10Secs: DataStream[OT] = readings.keyBy(_.id).timeWindow(Time.seconds(10)) .allowedLateness(Time.seconds(5)).process(new UpdatingWindowCountFunction)class UpdatingWindowCountFunction extends ProcessWindowFunction[SensorReading, OT, String, TimeWindow] &#123; val isUpdateDesc = new ValueStateDescriptor[Boolean]("isUpdate", Types.of[Boolean]) override def process(id: String, ctx: Context, elements: Iterable[SensorReading], out: Collector[OT]): Unit = &#123; val cnt = elements.count(_ =&gt; true) val isUpdate = ctx.windowState.getState(isUpdateDesc) // first evaluation, emit first result else emit an update if (!isUpdate.value()) &#123; out.collect((id, ctx.window.getEnd, cnt, "first")) isUpdate.update(true) &#125; else &#123; out.collect((id, ctx.window.getEnd, cnt, "update")) &#125; &#125;&#125;]]></content>
      <categories>
        <category>Distributed System</category>
      </categories>
      <tags>
        <tag>Big Data</tag>
        <tag>Apache Flink</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shapeless初体验之依赖类型(Dependent Types)]]></title>
    <url>%2Fshapeless%2Fdependent-types%2F</url>
    <content type="text"><![CDATA[本文将接着介绍Shapeless中依赖类型的几点常见用法. 邂逅依赖类型什么是依赖类型(Dependent Types)? 别急, 先回顾下Shapless中Generic[T] 特质源码: 12345678/** 可以看到 `Generic[T]` 特质存在两个类型: `T` 与 `Repr` * `Repr` 可以为转换前(输入)或转换后(输出)的类型 */trait Generic[T] extends Serializable &#123; type Repr def to(value: T): Repr def from(value: Rper): T&#125; 现在假定有一个 fetchRepr 方法, 猜猜看该方法返回类型是啥? 12345678import shapeless.Genericdef fetchRepr[T](value: T)(implicit generic: Generic[T]) = &#123; // 基于 `Generic[T]` 特质中的`to`方法源码, 很容易判断返回类型为`Repr` // 所以此处返回类型为 `Repr`. // 但问题是此处仅有方法泛型参数`T`, 没有`Repr` 类型参数!!! generic.to(value)&#125; 实际上, 上面方法的返回类型依赖于 generic 实例类型. 再来看个小例子: 12345case class Point(x: Int, y: Int)case class PointShifted(original: Point, result: Point)fetchRepr(Point(16, 21))fetchRepr(PointShifted(Point(11, 21), Point(16, 66))) 猜猜看, 运行上面代码, 将返回什么? 12345scala&gt; fetchRepr(Point(16, 21))res1: shapeless.::[Int, shapeless.::[Int,shapeless.HNil]] = 16 :: 21 :: HNilscala&gt; fetchRepr(PointShifted(Point(11, 21), Point(16, 66)))res2: shapeless.::[Point, shapeless.::[Point,shapeless.HNil]] = Point(11,21) :: Point(16,66) :: HNil 可以看到返回类型均为 HList, 只不过前者为 HList[Int :: Int :: HNil], 后者为 HList[Point :: Point :: HNil]. 什么是依赖类型(Dependent Types), 以上便是依赖类型. 换句话说, 方法fetchRepr返回类型通过类型成员依赖值参数(如果不太理解这句话, 也没关系, 请再看遍上面的Generic[T]特质源码). 如果对方法fetchRepr, 重构代码, 参考如下: 123trait GenericT[T, Repr]def fetchReprRefactored[T, U](value: T)(implicit generic: GenericT[T, U]): U = ??? 很显式, 很有成就感, 是不是? 厉害呀, 这代码好厉害哦….. 好了, 不说反话了, 上面这行代码, 一点用都没有. 为啥? 现在Repr不得不作为类型参数传入, 充当方法签名的一部分, 失去了Dependent Types(依赖类型)的意义. 小结: 类型参数适合充当”输入”, 类型成员适合充当”输出”. 不好意思, 又逼着你复习一遍Scala泛型了. 泛型方法依赖类型在Shapless中使用广泛, 如Generic与Witness. 比如Shapless中提供了一类型类Last, 用于返回HList中最后一个元素. 简化版的Last源码参考如下: 1234trait Last[L &lt;: HList] &#123; type Out def apply(in: L): Out&#125; 如何使用, 可以先看个小例子: 12345678import shapeless.&#123;HList, ::, HNil&#125;import shapless.ops.hlist.Lastval lastCaseOne = Last[String :: Int :: HNil]val lastCaseTwo = Last[Double :: String :: HNil]lastCaseOne("Bonjour" :: 66 :: HNil) lastCaseTwo(166.21 :: "Hola" :: HNil) 运行上面代码, 返回 12345scala&gt; lastCaseOne("Bonjour" :: 66 :: HNil)res1: lastCaseOne.Out = 66scala&gt; lastCaseTwo(166.21 :: "Hola" :: HNil)res2: lastCaseTwo.Out = Hola 运行结果符合预期, 但如果运行下面这段代码, 肯定报错, 原因在于Last需确保输入的HList必须至少含有一个元素. 1234scala&gt; Last[HNil] error: Implicit not found: shapeless.Ops.Last[shapeless.HNil]. shapeless.HNil is empty, so there is no last element. Last[HNil] ^ 还有一点, Last实例的类型参数会进行类型校验, 比如运行下面这段代码将报错 123456scala&gt; lastCaseOne(166 :: "Bonjour" :: HNil) error: type mismatch; found : shapeless.::[Int,shapeless.::[String,shapeless.HNil]] required: shapeless.::[String,shapeless.::[Int,shapeless.HNil]] lastCaseOne(166 :: "Bonjour" :: HNil) ^ 仿照 Last 源码, 可以写段代码如对HList的第二个元素进行判断, 代码参考如下: 12345678910111213141516// 返回 HList 第二个元素trait SecondElement [L &lt;: HList] &#123; type Out def apply(in: L): Out&#125;object SecondElement &#123; type Aux[L &lt;: HList, O] = SecondElement[L] &#123;type Out = O&#125; def apply[L &lt;: HList] ( implicit secondElement: SecondElement[L] ): Aux[L, secondElement.Out] = &#123; secondElement &#125;&#125; 类型类与伴生对象定义完了, 下面写个隐式方法实例化SecondElement, 代码参考如下: 1234567implicit def getSecondElement[T1, T2, R &lt;: HList](): Aux[T1 :: T2 :: R, T2] = new SecondElement[T1 :: T2 :: R] &#123; type Out = T2 type L = T1 :: T2 :: R def apply(in: L): T2 = in.tail.head &#125; 检查代码是否可以正常运行, 测试代码参考如下: 12345val secondElemCaseOne = SecondElement[String :: Double :: Int :: HNil]val secondElemCaseTwo = SecondElement[Int :: String :: Double :: HNil]secondElemCaseOne("Bonjour" :: 66.11 :: 166 :: HNil)secondElemCaseTwo(16 :: "Bonjour" :: 166.21 :: HNil) 运行上面这段代码: 12345scala&gt; secondElemCaseOne("Bonjour" :: 66.11 :: 166 :: HNil)res1: secondElemCaseOne.Out = 66.11scala&gt; secondElemCaseTwo(16 :: "Bonjour" :: 166.21 :: HNil)res2: secondElemCaseTwo.Out = Bonjour 运行正常. 类似地, 如果HList 类型校验不成功, 会报错 12345678910111213scala&gt; // 如果HList类型个数不匹配(如下面HList仅有一个类型), 报错scala&gt; SecondElement("Bonjour" :: HNil) error: could not find implicit value for parameter secondElement: SecondElement[shapeless.::[String,shapeless.HNil]] SecondElement[String :: HNil] ^scala&gt; // 如果HList实例类型不匹配, 报错scala&gt; secondElemCaseOne(66.11 :: "Bonjour" :: 166 :: HNil) error: type mismatch; found : shapeless.::[Double,shapeless.::[String,shapeless.::[Int,shapeless.HNil]]] required: shapeless.::[String,shapeless.::[Double,shapeless.::[Int,shapeless.HNil]]] secondElemCaseOne(66.11 :: "Bonjour" :: 166 :: HNil) ^ 小结: 尽量将自由变量编码成类型参数 . 含有依赖类型的泛型方法提供了一种从源类型转换为目标类型的方式. 链(Chain)与组合依赖类型允许对含有依赖类型的泛型方法链(Chain)起来, 以便写出更具表现力的泛型代码. 比如, 可以写个方法将上面的代码逻辑链起来: 12345678def fetchLastField[T, Repr &lt;: HList](in: T)( implicit generic: Generic.Aux[T, Repr], last: Last[Repr]): last.Out = &#123; last.apply(generic.to(in))&#125; 检测上面这段代码是否可以正常运行(符合预期, 代码运行无误): 12scala&gt; fetchLastField(PointShifted(Point(11, 21), Point(16, 66)))res1: Point = Point(16, 66) 假定有这样一个需求: 12345// 假定存在某项封装值(比如经过很多复杂业务逻辑处理得到, 具体处理逻辑略)// 现在希望写个泛型方法获取该封装值 // 此处使用Case Class作为该封装值容器, 仅为示例case class SomeWrapper(value: Int)// 由于是要设计泛型方法, 总不能使用 `SomeWrapper.value` 这种方式获取 想想看, 有什么好方法? 下面先给出个人的代码逻辑, 如果还有更好的方式, 欢迎补充. 1234567891011import shapeless.ops.hlist.IsHCons// `IsHCons` 可用于将 HList分割成Head与Taildef extractWrappedValue[T, Repr &lt;: HList, Head](in: T)( implicit generic: Generic.Aux[T, Repr], isHCons: ISHCons.Aux[Repr, Head, HNil]): Head = &#123; generic.to(in).head&#125; 效果(运行成功, 符合预期): 12scala&gt; extractWrappedValue(SomeWrapper(166))res1: Int = 166 本文小结: (如何写出符合预期的依赖类型代码, 以下是几点建议) 编译器一次只能处理一项约束(Constraint), 因而使用隐式转换时, 单个隐式转换中不宜使用过多约束 必要时抽取每一项中间类型作为类型参数, 尽管有些类型参数并不会在输出结果中使用, 但编译器需要 编译器从左至右进行隐式查找, 如果找不到合适的组合可能会回溯. 使用隐式转换时, 注意顺序, 必要时使用一项或多项类型参数连接前一隐式值(或隐式方法) 可以使用Shapeless中的Aux类型别名增加代码可读性, 必要时可以在含有依赖类型的泛型方法中使用Aux类型别名 尽量显式声明返回类型, 必要时指明类型参数及类型成员, 以便编译器进行隐式查找. 类型成员很重要, 必要时可以通过Shapless中Aux类型预留]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>JVM And JVM Languages</tag>
        <tag>Shapeless</tag>
        <tag>Generic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云中漫步, Apache Phoenix与常见Hadoop生态组件交互]]></title>
    <url>%2Fbigdata%2Fhbase%2Fphoenix-integ%2F</url>
    <content type="text"><![CDATA[本文将介绍Apache Phoenix与常见Hadoop生态组件交互. 与Spark集成Apache Phoenix可与Spark集成, 充分利用Spark API对Phoenix表数据读写提供原生支持. 提交Spark任务时, 可以将依赖包phoenix-spark-phoenix_version-Hbase-hbase_version.jar路径作为参数传入或加入到Spark类路径中, 参考指令如下: 123$ bin/spark-submit.sh --jar /path/to/phoenix-spark-&lt;phoenix_version&gt;-Hbase-&lt;hbase_version&gt;.jar \ # Spark任务Jar包, 运行类及参数等 # 其它配置项, 如driver-memory、executor-memory、executors等略 通过使用Spark RDD对Phoenix表间数据进行读写, 参考代码如下, 该任务从ORDERS表中读取数据并计算每位顾客消费金额, 并将结果数据存储至CUSTOMER_STATS表中. 123456789101112131415161718192021222324252627282930313233343536373839404142434445import org.apache.spark.SparkConfimport org.apache.spark.rdd.RDDimport java.math.BigDecimalobject PhoenixAppSparkRDD &#123; def main(args: Array[String]): Unit = &#123; val zkQuorum = Some("zk-n1:2181") val master = "spark-master" val conf = new SparkConf() .setAppName("Phoenix-Spark-RDD-Write") .setMaster(master) val sc = new SparkContext(conf) val inputTable = "ORDERS" val inputColumns = Seq("ORDER_ID", "CUST_ID", "AMOUNT") val outputTable = "CUSTOMER_STATS" runPhoenixAppRDD(sc, zkQuorum, inputTable, inputColumns, outputTable) &#125; def runPhoenixAppRDD(sc: SparkContext, zkQuorum: Option[String], inputTable: String, inputColumns: Seq[String], outputTable: String): Unit = &#123; val rdd: RDD[Map[String, AnyRef]] = sc.phoenixTableAsRDD(inputTable, inputColumns, zkQuorum) val customerId = inputColumns(1) val amountCol = inputColumns(2) val result = rdd.map &#123; row =&gt; val key = row(customerId).asInstanceOf[Long] val amount = row(amountCol).asInstanceOf[BigDecimal] (key, amount.doubleValue()) &#125; .reduceByKey(_+_) val outputColumns = Seq(customerId, amountCol) result.saveToPhoenix(outputTable, outputColumns, zkQuorum) &#125;&#125; 也可通过使用Spark DataFrame对Phoenix表间数据进行读写, 参考代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243import org.apache.spark.SparkConfimport org.apache.spark.rdd.RDDobject PhoenixAppSparkDF &#123; def main(args: Array[String]): Unit = &#123; val zkQuorum = Some("zk-n1:2181") val master = "spark-master" val conf = new SparkConf() .setAppName("Phoenix-Spark-DataFrame-Write") .setMaster(master) val sc = new SparkContext(conf) val inputTable = "ORDERS" val inputColumns = Seq("ORDER_ID", "CUST_ID", "AMOUNT") val outputTable = "CUSTOMER_STATS" runPhoenixAppDF(sc, zkQuorum, inputTable, inputColumns, outputTable) &#125; def runPhoenixAppDF(sc: SparkContext, zkQuorum: Option[String], inputTable: String, inputColumns: Seq[String], outputTable: String): Unit = &#123; val df = sc.phoenixTableAsDataFrame(inputTable, inputColumns, zkQuorum) val customerId = inputColumns(1) val amountCol = inputColumns(2) val result = df.rdd.map &#123; row =&gt; val key = row.getString(1) val amount = row.geString(2) (key.toLong, amount.toDouble) &#125; .reduceByKey(_+_) val outputColumns = Seq(customerId, amountCol) result.saveToPhoenix(outputTable, outputColumns, zkQuorum) &#125;&#125; 目前Phoenix-Spark插件暂不支持从Phoenix表中批量加载数据, 对于Java用户而言, 使用DataFrame API相对简单, 因为PhoenixRDD暂不支持直接从Java调用. 与Hive集成用户可以使用自定义PhoenixHiveHandler从Apache Phoenix表中读取数据至Hive表中. 首先要将phoenix-phoenix_version-hbase-hbase_version-hive.jar加入Hive环境变量(类路径)中, 可以参考以下命令行: 12# 开启Hive Shell, 键入以下指令, Jar包路径可以是本地文件路径也可以是HDFS、S3等其它分布式文件系统路径ADD JAR /path-to/phoenix-&lt;phoenix_version&gt;-Hbase-&lt;hbase_version&gt;-hive.jar 或者在开启Hive终端时指定Jar包路径: 1$ bin/hive --auxpath=/path-to/phoenix-&lt;phoenix_version&gt;-Hbase-&lt;hbase_version&gt;-hive.jar 也可以写入Hive配置文件hive-site.xml中, 参考如下: 1234&lt;property&gt; &lt;name&gt;hive.aux.jars.path&lt;/name&gt; &lt;value&gt;/path-to/phoenix-&lt;phoenix_version&gt;-Hbase-&lt;hbase_version&gt;-hive.jar&lt;/value&gt;&lt;/property&gt; 解决完Jar包依赖问题, 现在可以建表读取数据了, 可以在Hive中创建内部表或外部表, 区别在于数据表及数据生命周期的管理者不同, 如果是内部表, 数据及生命周期由Hive管理; 若为外部表, 只有元数据由Hive管理. 建表语句参考如下, 注意TBLPROPERTIES中phoenix.column.mapping映射Hive表中每一列至Phoenix, 映射关系为: Hive列:Phenix列, 任何需要传入Phoenix表中属性均可以通过使用TBLPROPERTIES传入. 12345678910111213141516171819-- 创建外部表, orders订单表CREATE EXTERNAL TABLE orders( id int, custid int, order_date date, amount double, quantity int)STORED BY 'org.apache.phoenix.hive.PhoenixStorageHandler'TBLPROPERTIES ( "phoenix.table.name" = "orders", "phoenix.zookeeper.quorum" = "zk_quorum", "phoenix.rowkeys" = "id, custid", "phoenix.column.mapping" = "id:order_id, custid:cust_id, order_date:order_date, amount:amount, quantity:quantity", "phoenix.table.options" = "SALT_BUCKETS=10"); 执行以上指令, 更新Hive元数据存储同时也会创建一张Phoenix表, 或者说, 外部表即订单表orders元数据将由Hive管理, 而实际数据存储于Phoenix表中. 与MR集成尽管Phoenix通过使用HBase底层API支持SELECT、UPSERT等子句拓展, 但有时需要执行一些大批量处理任务如构建索引、聚合大表等, 此时Driver API容易出现瓶颈(如客户端消耗过多内存、影响应用性能等), 该种情况下可以考虑使用MapReduce对Phoenix表进行读写. Phoenix可使用DBInputFormat及DBOutputFormat API进行MapReduce读写. 如用户可以从Phoenix表中读取数据, 执行如SELECT查询, 将底层Byte Stream转化为自定义Writable类. 自定义InputFormat类PhoenixInputFormat, 内部基于输入查询计算查询计划并根据输入Split数量进行优化, PhoenixOutputFormat将数据写入HBase前将Java类型数据序列化至Byte Stream. Apache Phoenix与MapReduce集成时, 需将依赖包phoenix-client-phoenix_version.jar打入MapReduce任务Jar包中, 确保Drive程序可以访问Phoenix表并执行查询计划. 示例代码参考如下, 该MapReduce任务从ORDERS表中读取数据并计算每位顾客消费金额, 并将结果数据存储至ORDER_STATS表中. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.conf.Configured;import org.apache.hadoop.hbase.HBaseConfiguration;import org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil;import org.apache.hadoop.io.DoubleWritable;import org.apache.hadoop.io.LongWritable;import org.apache.hadoop.io.NullWritable;import org.apache.hadoop.io.Writable;import org.apache.hadoop.mapreduce.Job;import org.apache.hadoop.mapreduce.Mapper;import org.apache.hadoop.mapreduce.Reducer;import org.apache.hadoop.mapreduce.lib.db.DBWritable;import org.apache.hadoop.util.Tool;import org.apache.phoenix.mapreduce.PhoenixOutputFormat;import org.apache.phoenix.mapreduce.util.PhoenixMapReduceUtil;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.DataInput;import java.io.DataOutput;import java.io.IOException;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;public class OrderStatsApp extends Configured implemnts Tool &#123; private static final Logger LOG = LoggerFactory.getLogger(OrderStatsApp.class); public static main(String[] args) throws Exception &#123; int status = ToolRunner.run(new OrderStatsApp(), args); System.exit(status); &#125; public int run(String[] args) throws Exception &#123; try &#123; final Configuration configuration = HBaseConfiguration.create(getConf()); setConf(configuration); final Job job = Job.getInstance(configuraion, "phoenix-mr-job-order-stats"); final String selectQuery = "SELECT ORDER_ID, CUST_ID, AMOUNT FROM ORDERS"; PhoenixMapReduceUtil.setInput(job, OrderWritable.class, "ORDERS", selectQuery); PhoenixMapReduceUtil.setOutput(job, "ORDER_STATS", "CUST_ID", "AMOUNT"); job.setMapperClass(OrderMapper.class); job.setReducerClass(OrderReducer.class); job.setOutputFormatClass(PhoenixOutputFormat.class); job.setMapOutputKeyClass(LongWritable.class); job.setMapOutputValueClass(DoubleWritable.class); job.setOutputKeyClass(NullWritable.class); job.setOutputValueClass(OrderWritable.class); TableMapReduceUtil.addDependencyJars(job); job.waitForCompletion(true); return 0; &#125; catch (Exception e) &#123; LOG.error(String.format( "An exception [%s] occurred while performing the job: ", e.getMessage())); return -1; &#125; &#125; public static class OrderMapper extends Mapper&lt;NullWritable, OrderWritable, LongWritable, DoubleWritable&gt; &#123; private LongWritable customerId = new LongWritable(); private DoubleWritable amount = new DoubleWritable(); @Override protected void map(NullWritable key, OrderWritbale order, Context context) throws IOException, InterruptedException &#123; customerId.set(order.customerId); amount.set(order.amount); context.write(customerId, amount); &#125; &#125; public static class OrderReducer extends Reducer&lt;LongWritable, DoubleWritable, NullWritable, OrderWritable&gt; &#123; @Override protected void reduce(LongWritable key, Iterable&lt;DoubleWritable&gt; amounts, Context context) throws IOException, InterruptedException &#123; double totalValue = 0; for (DoubleWritable amount: amounts) &#123; totalValue += amount.get() &#125; context.write(NullWritable.get(), new OrderWritable(key.get(), totalValue)); &#125; &#125; public static class OrderWritable implements DBWritable, Writable &#123; private Long customerId; private Double amount; public OrderWritable () &#123; &#125; public OrderWritable(Long customerId, Double amount) &#123; this.customerId = customerId; this.amount = amount; &#125; public void write(PreparedStatement preparedStatement) &#123; preparedStatement.setLong(1, customerId); preparedStatement.setDouble(2, amount); &#125; public void readFields(ResultSet resultSet) throws SQLException &#123; customerId = resultSet.getLong("CUST_ID"); amount = resultSet.getDouble("AMOUNT"); &#125; public void write(DataOutput dataOutput) throws IOException &#123; dataOutput.writeLong(customerId); dataOutput.writeDouble(amount); &#125; public void readFields(DataInput dataInput) throws IOException &#123; this.customerId = dataInput.readLong(); this.amount = dataInput.readDouble(); &#125; &#125;&#125; 通常, 创建索引是一同步过程(非异步), 如果在大表上创建索引, 拓展困难. Apache Phoenix与MapReduce集成, 也支持异步创建索引. 与Flume集成Flume通常由Source、Channel、Sink组成, 支持Push(推送)和Pull(拉取)数据, 管道(Channel)作为Buffer队列避免数据陡增, 当管道中Events写入目的Sink并作为事务中一部分被Sink移除时才可视为已持久化, Sink可插拔, Phoenix提供自定义Sink, 便于与Flume集成. 进行集成时, Phoenix Flume插件需在Flume中注册, 可以拷贝Jar包phoenix-flume-phoenix_version-HBase-hbase_version.jar至$FLUME_HOME/plugins.d/phoenix-sink/lib目录下. 以下参考配置为从Kafka集群Stream数据至Apache Phoenix, 假定配置文件为phoenix-agent.conf 1234567891011121314151617181920212223242526272829# 主要组件配置, Source为Kafka, Sink为Phoenixagent.sources=kcollectoragent.sinks=phoenix-sinkagent.channels=memoryChannel# Source配置agent.sources.kcollector.type = org.apache.flume.source.kafka.KafkaSourceagent.sources.kcollector.channels = memoryChannelagent.sources.kcollector.zookeeperConnect = zk-n1:2181agent.sources.kcollector.topic = phoenix-consumeragent.sources.kcollector.groupId = flume_to_phoenixagent.sources.kcollector.kafka.consumer.timeout.ms = 100# Channel配置agent.channels.memoryChannel.type=memoryagent.channels.memoryChannel.byteCapacityBufferPercentage=20agent.channels.memoryChannel.transactionCapacity=100# Sink配置agent.sinks.phoenix-sink.type=org.apache.phoenix.flume.sink.PhoenixSinkagent.sinks.phoenix-sink.channel=memoryChannelagent.sinks.phoenix-sink.batchSize=100agent.sinks.phoenix-sink.table=PHNIX_TESTagent.sinks.phoenix-sink.ddl=CREATE TABLE IF NOT EXISTS PHNIX_TEST(uid VARCHAT NOT NULL, msg VARCHAR CONSTRAINT pk PRIMARY KEY(uid))agent.sinks.phoenix-sink.zookeeperQuorum=zk-n1agent.sinks.phoenix-sink.serializer=REGEXagent.sinks.phoenix-sink.serializer.rowkeyType=uuidagent.sinks.phoenix-sink.serializer.regex=([^]*)agent.sinks.phoenix-sink.serializer.columns=msg 开启终端运行以下命令行, 将Kafka中生产的每一条消息, 转化为String并写入Apache Phoenix中. 1$ bin/flume-ng agent -f conf/phoenix-agent.conf -c ./conf -n agent 与Pig集成用户可以通过使用PhoenixHBaseLoader以及PhoenixHBaseStorage加载、存储数据至Phoenix表中. 首先需要将Jar包phoenix-pig-phoenix_version-HBase-hbase_version.jar在Pig中注册, 参考Pig脚本如下: 1REGISTER /path/to/phoenix-pig-&lt;phoenix_version&gt;-HBase-&lt;hbase_version&gt;.jar 也可以在开启Pig终端时将Jar包路径作为参数传入, 参考指令如下: 1$ pig -Dpig.additional.jars.uris=/path/to/phoenix-pig-&lt;phoenix_version&gt;-HBase-&lt;hbase_version&gt;.jar script.pig 访问Phoenix表数据, 参考Pig脚本如下, PhoenixHBaseLoader内部将LOAD子句转化成SELECT查询并从表中多个Region获取数据. 1234567891011121314-- 指定表名REGISTER hdfs://pig/lib/phoenix-pig-&lt;phoenix_version&gt;-HBase-&lt;hbase_version&gt;.jarORDER = LOAD 'hbase://table/ORDERS' USING org.apache.phoenix.pig.PhoenixHBaseLoader('zookeeper_quorum_uri');-- 指定表中列REGISTER hdfs://pig/lib/phoenix-pig-&lt;phoenix_version&gt;-HBase-&lt;hbase_version&gt;.jarORDER = LOAD 'hbase://table/ORDERS/ORDER_ID, CUST_ID' USING org.apache.phoenix.pig.PhoenixHBaseLoader('zookeeper_quorum_uri');-- 指定SQL语句REGISTER hdfs://pig/lib/phoenix-pig-&lt;phoenix_version&gt;-HBase-&lt;hbase_version&gt;.jarORDER = LOAD 'hbase://query/SELECT ORDER_ID, CUST_ID FROM ORDERS' USING org.apache.phoenix.pig.PhoenixHBaseLoader('zookeeper_quorum_uri'); 存储数据至Phoenix, PhoenixHBaseStorage内部将Pig数据类型映射成对应Phoenix数据类型并序列化. 123456REGISTER hdfs://pig/lib/phoenix-pig-&lt;phoenix_version&gt;-HBase-&lt;hbase_version&gt;.jarA = LOAD '/path/to/data' USING PigStorage('\t') AS (a:chararray, b:chararray, c:datetime);STORE A INTO 'hbase://phoenix-table' USING org.apache.phoenix.pig.PhoenixHBaseStorage('$&#123;zookeeper.quorum&#125;', '-batchSize 100'); 注意, 在LOAD子句中不能使用AGGREGATE、GROUP BY、LIMIT或DISTINCT等关键字.]]></content>
      <categories>
        <category>Distributed System</category>
      </categories>
      <tags>
        <tag>Big Data</tag>
        <tag>Apache Phoenix</tag>
        <tag>Apache HBase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cascading实战之Operation篇]]></title>
    <url>%2Fbigdata%2Fcascading%2Fops-intro%2F</url>
    <content type="text"><![CDATA[本文将对Cascading自定义操作进行简介. Cascading中一个Operation对应一个类, 可以通过new关键字实例化这些对象, 创建Pipe后, 通过参数传递形式将这些对象传入并绑定至管道(Pipe)中. Pipe中传入数据元组与特定的Operation进行绑定, 以便执行数据转换、计算逻辑. 示例代码如下: 12345678910111213// Each (单元组) PipeinPipe = new Each(inPipe, new CustomFunction());// 调用自定义FilterinPipe = new Each(inPipe, new CustomFilter());// 调用自定义ValueAssertioninPipe = new Each(inPipe, AssertionLevel.STRICT, new CustomValueAssertion());// Every (分组元组, 非单元组) Pipe, 调用自定义AggregatorinPipe = new Every(inPipe, new CustomAggregator());// 调用自定义BufferinPipe = new Every(inPipe, new CustomBuffer());// 调用自定义GroupAssertioninPipe = new Every(inPipe, AssertionLevel.STRICT, new CustomGroupAssertion()); Cascading中所有Operation源自Operation接口, 其它特定接口如Filter、Function、Aggregator、Buffer等均源自该接口. BaseOpertaion提供具体实现, 该类为Operation中多数具体类的基类. Cascading中Operation可以粗略地分为以下几类(若按Type划分, 请参考下文中Operation Type小节): Filter, 对数据进行过滤 Function, 执行特定数据转换或计算方法 Aggregator, 对数据集进行聚合、汇总 Buffer, 在一定数量的数据集执行数据计算 Assertion, 断言, Assertion适用于单元组Pipe(如Each)和分组元组Pipe(如Every)等. 关于Operation与Fields, 存在以下俩种方式绑定Function、Fields至Pipe中: 方式一: 绑定Function、所有Fields至Pipe中 1inPipe = new Each(inPipe, Fields.ALL, new CustomFunction()); 方式二: 绑定Funtion、特定Fields至Pipe中 1inPipe = new Each(inPipe, new Fields("name", "address"), new CustomFunction()); 类似地, 存在以下三种方式绑定Function并触发Fields处理于Pipe中: 方式一: 绑定Function、触发所有Fields至Pipe中处理 1inPipe = new Each(inPipe, new CustomFunction(), Fields.ALL); 方式二: 绑定Function、触发RESULTS Fields至Pipe中 1inPipe = new Each(inPipe, new CustomFunction(), Fields.RESULTS); 方式三: 绑定Function、触发特定Fields至Pipe中处理 1inPipe = new Each(inPipe, new CustomFunction(), new Fields("name", "address")); Operation TypeCascading中Operation可分为俩大类: 一类执行于单元组的Operation与另一类执行于Group元组(分组元组, 非单元组)的Operation. 单元组与Each管道(Pipe)相关, Group元组与Every Pipe相关. EachEach管道常用于处理单元组, Each Opeartion中存在Filter与Function. FilterFilter是所有Operation中最简单的, 执行该Operation时仅需实现一个方法isRemove(), 该方法传入一元组并判断是否为待移除元组. Filter内部调用逻辑, 参考如下: Filter实现代码, 参考如下: 123456public class CustomFilter extends BaseOperation&lt;Context&gt; implements Filter&lt;Context&gt; &#123; // `prepare()`、`cleanup()` 方法实现略 public boolean isRemove(FlowProcess flowProcess, FilterCall&lt;Context&gt; filterCall) &#123; // 具体过滤逻辑略 &#125;&#125; Cascading自带过滤器(Filter), 参考如下: Filter名称 说明 ExpressionFilter 传入一Expression字符串, 编译并通过名称或位置绑定输入元组、然后执行, 基于表达式返回Boolean值, 该Filter使用Janino编译 RegexFilter 基于正则表达式过滤 SampleFilter 基于采样比例对元组进行采样抽取, 其中初始化随机数生成函数的Seed值可选 Deubg 打印每项元组至标准输出 FilterNotNull 过滤掉每一项不含null值元组 FilterNull 过滤掉每一项含null值元组 And 传入一过滤器列表, 对列表中Filter进行逻辑与操作(即若满足列表中所有Filter条件则返回true) Or 传入一过滤器列表, 对列表中Filter进行逻辑或操作(即若满足列表中任一Filter条件则返回true) XOR 传入一过滤器集, 对其中Filter进行异或操作(如果所有Filter均返回true或false, 则最终结果返回false) Not 对传入的Filter取反 ScriptFilter 基于脚本内容过滤 示例代码如下: 123456789101112inPipe = new Each(inPipe, new RegexFilter("ECOMM"));// 从Data Stream中抽取20% 数据元组inPipe = new Each(inPipe, new SampleFilter(0.2));// 基于Expression过滤inPipe = new Each(inPipe, new ExpressionFilter("$0 + $1 &lt;= 10000"));// 写入所有元组至标准输出inPipe = new Each(inPipe, new Debug());//基于Field名过滤 inPipe = new Each(inPipe, new Fields("salary", "raise"), new ExpressionFilter("$salary + $raise &lt;= 10000"));// Or、And FilterinPipe = new Each(inPipe, new Or(new FilterOne(), new FilterTwo(), new FilterThree()));inPipe = new Each(inPipe, new And(new FilterOne(), new FilterTwo(), new FilterThree())); FuntionFunction比较通用, 执行特定计算或数据转换逻辑, 然后返回结果元组. Function内部调用逻辑, 参考如下(该Operation主要方法为operate()): Function实现代码, 参考如下: 123456public class CustomFunction extends BaseOperation&lt;Context&gt; implements Function&lt;Context&gt; &#123; // `prepare()`、`cleanup()` 方法实现略 pubic void operate(FlowProcess flowProcess, FunctionCall&lt;Context&gt; functionCall) &#123; // 具体处理逻辑略 &#125;&#125; Cascading自带Function, 参考如下: Functon名称 说明 DateFormatter 将Java时间戳转化为Java字符串, 即传入时间可为SimpleTimeFormat或Timezone、Locale对象 DateParser 将字符串转化为Java中Timestamp对象 RegexParser 基于正则解析 RegexPlacer 基于正则替换 RegexSplitGenerator 基于正则分割元组 ExpressionFunction 传入一Expression字符串, 该函数将编译成字节码, 并通过名称或位置绑定输入元组、然后执行并输出结果, 该函数使用Janino编译 ScriptFunction 可传入一些列脚本字符串, 该函数将编译成字节码, 并通过名称或位置绑定输入元组、然后执行并输出结果, 该函数使用Janino编译 FieldJoiner 将多项Fields通过可选的分隔符(默认为TAB)拼接成一项Field FieldFormatter 将多项Fields按照格式化字符串合并为一项Field Insert 插入部分Fields值至元组中 UnGroup 传入一组Field Selector及Value Field Selector, 为每项Value Field Selector输出分组元组 Identity 什么也没做, 仅写入输入元组至输出collector中 XPathParser 通过使用XPath表达式抽取数据 TagSoupParser 通过使用Tag Soup解释器引擎将HTML转换成合法的XHTML 示例代码如下: 12345678910// INSERT 值至Tuple中inPipe = new Each(inPipe, new Insert(new Fields("datasrc"), "ECOMM DATA"));// 将三项Fields合并成一项inPipe = new Each(inPipe, new FieldJoiner(new Fields("LastName", "FirstName", "MiddleName"), " "));// 基于Expression的函数inPipe = new Each(inPipe, new ExpressionFunction(new Fields("TotalSalary"), "$salary + $raise", Long.class));// 使用`UnGroup` 对元组进行分割// 注意 `UnGroup` 在Hadoop中仅为一Map进程(除非后续指定`GroupBy`)inPipe = new Each(inPipe, new UnGroup(new Fields("FirstName", "LastName"), new Fields[] &#123;new Fields("Salary"), new Fields("Raise")&#125;)); EveryEvery管道, 执行于一组元组之上(非单元组), 通常这些分组由GroupBy管道确定. 这些分组元组可以一次处理一项(Aggregator)或一次性处理所有(Buffer). AggregatorAggreagator常用于聚合(如求和、平均值等)操作, 在一组元组上执行具体聚合逻辑, 返回聚合结果值. Aggregator调用示意图如下: Aggreagator实现代码, 参考如下: 1234567891011121314public class CustomAggreagator extends BaseOperation&lt;Context&gt; implements Aggreagator&lt;Context&gt; &#123; // `prepare()`、`cleanup()` 方法实现略 public void start(FlowProcess flowProcess, AggregatorCall&lt;Context&gt; aggregatorCall) &#123; // 具体实现略 &#125; public void aggregate(FlowProcess flowProcess, AggregatorCall&lt;Context&gt; aggregatorCall) &#123; // 具体实现略 &#125; public void complete(FlowProcess flowProcess, AggregatorCall&lt;Context&gt; aggregatorCall) &#123; // 具体实现略 &#125;&#125; Cascading中自带Aggregator, 参考如下(注意新版Cascading中, MinBy、MaxBy、FirstBy、AverageBy、SumBy及CountBy基类均为AggregateBy, AggregateBy与Hadoop中Combiner类似, 于Map端聚合部分结果、然后在Reduce端合并, AggregateBy通过自动插入GroupBy至Stream中执行Reducer函数): Aggregator名称 说明 First 输出任意一组元组第一项Record (新版Cascading中为FirstBy) Last 输出任意一组元组最后一项Record Min 输出组中包含最小值的Record (新版Cascading中为MinBy) Max 输出组中包含最大值的Record (新版Cascading中为MaxBy) Average 输出组中平均值 (新版Cascading中为AverageBy) Sum 对组中元组值进行求和 (新版Cascading中为SumBy) Count 对组中元组进行计数 (新版Cascading中为CountBy) 示例代码如下: 1234567891011// 对分组元组进行计数inPipe = new GroupBy(inPipe, new Fields("group"));inPipe = new Every(inPipe, Fields.ALL, new Count(new Fields("TotalRecords")), Fields.ALL);// 对分组元组求和inPipe = new GroupBy(inPipe, new Fields("ToSum"));inPipe = new Every(inPipe, new SumBy(new Fields(new Fields("Bonus"), new Fields("SumBonus"), Long.class)));// 找出部门年龄最小人员 (分组默认升序), 也可使用 `MinBy`inPipe = new GroupBy(inPipe, new Fields("Department"), new Fields("Age"));inPipe = new Every(inPipe, new First()); BufferBuffer允许在一个”窗口”上的元组进行操作, Buffer与Aggregator有些类似, 但同时传入一组元组进行处理, 而非单元组. 其中分组操作可由GroupBy和CoGroup管道定义, Buffer中operate()方法可传入一TupleEntries相关迭代器. Buffer内部调用逻辑示意图如下: Buffer实现代码, 参考如下: 123456public class CustomBuffer extends BaseOperation&lt;Context&gt; implements Buffer&lt;Context&gt; &#123; // `prepare()`、`cleanup()` 方法实现略 pubic void operate(FlowProcess flowProcess, BufferCall&lt;Context&gt; bufferCall) &#123; // 具体处理逻辑略 &#125;&#125; Cascading中自带Buffer, 有FirstNBuffer, 该Buffer可以接收Group中特定数量元组, 有些类似TOP N做法, 示例代码如下: 123// 每组选取前1000项Record, 按照自定义函数处理inPipe = new Every(inPipe, new FirstNBuffer(1000));inPipe = new Each(inPipe, new CustomFunction()); AssertionAssertion与Java中断言类似, 适用于条件未满足、抛出异常情形, Assertion常用于测试、Debug, 特别是单元测试中. Assertion与其它Operation不同之处在于, 一般的Assertion需继承BaseAssertion&lt;Context&gt;、实现ValueAssertion&lt;Context&gt;或GroupAssertion&lt;Context&gt;接口(取决于运用于Each还是Every管道). ValueAssertion&lt;Context&gt;接口中doAssert()执行主逻辑、getTrace()方法用于存储断言Fail相关信息以便Trace, ValueAssertion&lt;Context&gt;调用示意图如下: GroupAssertion&lt;Context&gt;接口, 需实现start()、aggregate()及doAssert()方法, start()方法用于断言初始化、开启新元组, 然后将组中每一项元组传入aggregate()方法中执行与Aggregator类似的计算, 处理完后调用doAssert()方法. GroupAssertion&lt;Context&gt;调用示意图如下: Assertion存在以下AssertionLevel: AssertionLevel.STRICT, 适用于生产Job级别 AssertionLevel.VALID, 适用于测试代码中 AssertionLevel.NONE, 关闭所有断言 Cascading中自带Asssertion, 参考如下: Assertion名称 说明 AssertEquals 构造器中传入一元组, 然后验证入参中所有待处理元组是否含有相同数量的Entries AssertEqualsAll 与上类似 AssertNotEquals 与上类似, 注意条件为非等 AssertExperssion 基于Expression验证所待处理元组, 基于Expression返回结果, 该类使用Janino编译 AssertGroupBase 该基类不常用, 一般继承该基类实现自定义Assertion AssetGroupSizeEquals 基于Size或正则断言 AssertGroupSizeLessThan 与上类似, Size判定条件为小于 AssertGroupSizeMoreThan 与上类似, Size判定条件为大于 AssertMatches 基于正则断言 AssertMatchesAll 基于正则断言 AssertNotNull 断言所有待处理元组不为空 AssertNull 与上类似, 判定条件为元组为空 AssertSizeEquals 判定传入Size与所有待处理元组Size是否相等 AssertSizeLessThan 与上类似, Size判定条件为小于 AssertSizeMoreThan 与上类似, Size判定条件为大于 示例代码如下: 12345678910// 验证每项元组中所有Fields非空inPipe = new Each(inPipe, AssertionLevel.STRICT, new AssertNotNull());// 验证所有元组长度为5inPipe = new Each(inPipe, AssertionLevel.STRICT, new AssertSizeEquals(5));// 基于Expression断言, 验证前俩项Field之和为10inPipe = new Each(inPipe, AssertionLevel.STRICT, new AssertionExpression("$0 + $1 ==10L", Long.class));// 验证Field中Salary(本薪) 和 Raise(提薪部分)之和小于 10000inPipe = new Each(inPipe, AssertionLevel.STRICT, new AssertionExpression("$salary +$raise &lt;10000L", Long.class));// 验证每组至少存在俩元组inPipe = new Each(inPipe, AssertionLevel.STRICT, new AssertGroupSizeMoreThan(1)); Operation类与接口Operation类与接口, 继承关系类图如下, 实际上Context作为一类型参数, 也可简单替换为&lt;T&gt;, 主要表明存储于Operation类的对象类型. Operation接口, 存在以下方法签名: 1234567891011121314public interface Operation&lt;Context&gt; &#123; // 接口中其它方法声明略 void prepare(FlowProcess flowProcess, OperationCall&lt;Context&gt; operationCall); void cleanup(FlowProcess flowProcess, OperationCall&lt;Context&gt; operationCall); void flush(FlowProcess flowProcess, OperationCall&lt;Context&gt; operationCall); int getNumArgs(); Fields getFieldDeclartion(); boolean isSafe();&#125; BaseOperation类中提供了许多获取Operation参数的方法, 如调用getFieldDeclaration()方法返回Fields对象, 包含所有创建的Fields信息; getNumArgs()返回输入Fields数量等. 调用isSafe()方法, 若返回true, 表明在同一数据集上运行多次该Operation, 最终得到同一结果, 没有副作用, 具有幂等性. 下图为基本Operation内部调用逻辑示意图, 通过调用prepare()方法初始化, 调用operate()方法对要处理元组执行具体计算、转换逻辑, 处理完成后调用cleanup()方法进行内存释放、关闭文件句柄、数据库连接等. 通常, prepare()方法在Operation执行前调用, 常用于分配context对象并将其存储于OperationCall&lt;Context&gt;中, 实际上prepare()方法还可以做很多事情, 如从磁盘上加载数据、对任务进行反馈通知等. 当所有数据处理任务完成后, 可以调用cleanup()方法, 该方法常用于释放Context对象及分配的内存. ContextContext作为用户定义类型, 由Operation分配, 该对象可传入Operation接口方法中调用, 换句话说, Context可用于存储方法调用的状态信息. 由于Operation是有类型的, 类型参数为Context, 实现Operation接口的子类须指明具体泛型参数. Cascading中并不存在具体类或接口名为Context, Context作为泛型参数引入, 一是类型安全需要, 二是代码复用需要. FlowProcessFlowProcess允许Operation访问底层处理系统相关数据元素, 如Cascading任务以本地模式运行时可访问不同Property值, 若以Hadoop模式运行时可访问JobConf中封装的所有Hadoop类. FlowProcess由Cascading系统创建、可传入Operation接口方法中, 允许访问系统计数器及其它特定Cascading标识与资源等, 注意FlowProcess可不带泛型参数. OperationCall该对象封装了所有Operation需指定的参数, 由Pipe调用该对象进行实际数据处理. OperationCall&lt;Context&gt; 允许用户访问Context对象存储状态. 每一个Operation类型均有源自OperationCall&lt;Context&gt;的接口, 如Filter有FilterCall&lt;Context&gt;, Function有FunctionCall&lt;Context&gt;等. 下表为常见接口中参考方法:]]></content>
      <categories>
        <category>Distributed System</category>
      </categories>
      <tags>
        <tag>Big Data</tag>
        <tag>Cascading</tag>
        <tag>MapReduce</tag>
        <tag>Apache Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Query Enigne大作战 -- Apache Drill之网络报文分析]]></title>
    <url>%2Fbigdata%2Fdrill%2Fnetanalysis%2F</url>
    <content type="text"><![CDATA[本文将介绍Apache Drill与网络报文分析相关的一些常见分析技巧. 捕获的网络报文数据, 常见格式为PCAP或PCAP-NG(注意这些格式均为Binary, 二进制数据), 可以通过Wireshark来分析这些PCAP数据, 但Wireshark本身受单机内存限制, 无法分析大规模、大批量网络报文数据. Drill报文分析Apache Drill可直接分析这些PCAP或PCAP-NG报文数据, 无需安装其它插件或依赖包, Drill可用于分析PCAP(或PCAP-NG)中以下数据字段: 协议类型(如TCP/UDP) IP地址, 如源IP地址, 目的IP地址 源端口, 目的端口 源MAC地址, 目的MAC地址 报文创建时间 报文长度 TCP会话及Flag 二级制报文数据(Binary) Drill分析PCAP报文样本数据, 脚本参考如下: 123456789-- 统计TCP会话中报文数分布SELECT tcp_session, COUNT(*) AS packet_countFROM dfs.net_data.`scan.pcap`GROUP BY tcp_sessionHAVING COUNT(*) &gt; 1 查看具体给定TCP会话中各项报文数据, 如下: 12345SELECT * FROM dfs.net_data.`scan.pcap`WHERE tcp_session=6346604732028469374 如上图所示, 第一项报文为SYN(见Flag字段), 然后接着一系列ACK/SYN报文而非ACK报文. Drill报文聚合下面编写一Drill UDAF对这些报文数据进行聚合, 判定某项给定会话是否为Syn泛洪攻击. 该UDAF主逻辑参考如下: 首先, 对TCP会话进行分组 若Flag已设置为SYN, 计数器累加 若Flag已设置为SYN|ACK, 计数器累加 若会话从未关闭(从未接收ACK), 返回true; 否则返回false 代码参考如下(注意TCP三次握手协议, TCP为可靠连接): 12345678910111213141516171819202122232425// 此处仅给出Drill UDAF中`add()`方法及`output()`方法实现逻辑,// `setup()` 及 `reset()` 方法相对简单, 略// 假定该UDAF注册函数名为 `is_syn_scan`@Overridepublic void add() &#123; if (syn.value == 1 &amp;&amp; connectionStatus.value == 0 ) &#123; // 尝试新建连接, 接收SYN 并等待 SYN|ACK connectionStatus.value = 1; &#125; else if(connectionStatus.value == 1 &amp;&amp; synAck.value == 1) &#123; // 若Flag为 SYN|ACK, 连接状态(Status)设置为2, 并等待最终ACK connectionStatus.value = 2; &#125; else if(connectionStatus.value == 2 &amp;&amp; syn.value == 0 &amp;&amp; ack.value == 1) &#123; // 接收到ACK, 连接建立 connectionStatus.value = 3; &#125; &#125;@Override public void output() &#123; if (connectionStatus.value == 2) &#123; out.value = 1; &#125; else &#123; out.value = 0; &#125;&#125; 假定该UDAF注册函数名为is_syn_scan, 部署成功后, 使用参考如下: 123456SELECT tcp_session, is_syn_scan(tcp_session, tcp_flags_syn, tcp_flags_ack)FROM net_data.`scan.pcap`GROUP BY tcp_session 此外, 也可用于HAVING子句中, 参考如下: 1234567SELECT tcp_sessionFROM net_data.`scan.pcap`GROUP BY tcp_sessionHAVING is_syn_scan(tcp_session, tcp_flags_syn, tcp_flags_ack)]]></content>
      <categories>
        <category>Distributed System</category>
      </categories>
      <tags>
        <tag>Apache Drill</tag>
        <tag>Big Data</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Query Engine大作战 -- Apache Drill之ML Pipeline构建篇]]></title>
    <url>%2Fbigdata%2Fdrill%2Fmlpipe%2F</url>
    <content type="text"><![CDATA[本文将介绍Apache Drill如何与机器学习中Pipeline进行交互, 如参与Pipeline构建与模型预测等. ML PipelineApache Drill并不支持机器学习, Drill本身包含没有机器学习相关的包或库, 因此并不能直接使用Drill进行模型训练与预测. 虽然Drill并不支持机器学习迭代训练, 但可以作为机器学习Pipeline中一环, 参与模型迭代与优化. 以监督型机器学习为例, 常见的机器学习迭代过程如下: 虽然Drill并不直接支持模型训练, 但在查询时可利用训练好的模型进行预测, 本文以H2O为例, 进行分类预测(采用GBM模型). H2O允许用户序列化或导出训练模型, 模型可以导出为POJO(Plain Old Java Object)或MOJO(Maven Old Java Object), 模型导出, 代码参考如下: 12345678910111213141516171819202122232425262728293031import h2ofrom h2o.estimators.gbm import H2OGradientBoostingEstimatordef main(data_path, col_target, col_fields, output_path): h2o.init() df = h2o.load_dataset(data_path) df[col_target] = df[col_target].asfactor() model = H2OGradientBoostingEstimator( distribution='bernoulli', ntrees=100, max_depth=4, learn_rate=0.1) model.train(y=col_target, x=col_fields, training_frame=df) model_file = model.download_mojo( path=output_path, get_genmodel_jar=True)if __name__ == '__main__': data_path = '/path/to/the/dataset' output_path = '/path/to/save/mojo' # 预测列 col_target = 'CAPSULE' # 输入特征 col_fields = ['AGE', 'RACE', 'DCAPS', 'VOL', 'GLEASON'] main(data_path, col_target, col_fields, output_path) 执行上面这段代码, 在输出目录output_path下得到一Jar包, 该Jar包包含训练好的模型代码, 拷贝该Jar包及h2o-genmodel.jar包于Drill节点UDF路径下. 下面再封装一Drill UDF, 方便Drill调用训练好的模型进行预测. UDF封装注意, 部署封装的UDF时, 需将输入参数(即特征)转化为Java中Double类型, UDF代码参考如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@FunctionTemplate( name="binomal_prediction", scope=FunctionTemplate.FunctionScope.SIMPLE, nulls=FunctionTemplate.NullHandling.NULL_IF_NULL)public static class BinomalPrediction implements DrillSimpleFunc &#123; /** * 以下输入参数(即特征列), 包含年龄,种族,相关分子标记等, 具体参考上面的 * Python脚本, 基于输入特征进行预测 */ @Param Float8Holder age; @Param Float8Holder race; @Param Float8Holder dcapes; @Param Float8Holder vol; @Param Float8Holder gleason; @Workspace // `model`于`setup()`方法中实例化, 于`eval()`方法中进行模型预测 hex.genmodel.easy.EasyPredictModelWrapper model; @Output BitHolder out; @Override public void setup() &#123; String modelFile = "/path/to/mojo"; try &#123; model = new hex.genmodel.easy .EasyPredictModelWrapper(hex.genmodel.MojoModel) .load(modelFile); &#125; catch (Exception e) &#123; // 异常处理略 &#125; &#125; @Override public void eval() &#123; hex.genmodel.easy.RowData row = new hex.genmodel.easy.RowData(); row.put("AGE", age.value); row.put("RACE", race.value); row.put("DCAPS", dcaps.value); row.put("VOL", vol.value); row.put("GLEASON", gleason.value); try &#123; hex.genmodel.easy.prediction.BinomialModelPrediction p = model.predictBinomial(row); if (p.label.equals("l")) &#123; out.value = 1; &#125; else &#123; out.value = 0; &#125; &#125; catch (Exception e) &#123; // 异常处理略 &#125; &#125;&#125; 预测查询使用封装好的UDF及导出的训练模型, 可以对样本数据进行预测分析, 参考如下: 12345678910-- 调用Drill UDF, UDF注册名为`binomal_prediction`, 具体实现请参考上面的Java代码SELECT binomial_prediction( `age`, `race`, `dcaps`, `vol`, `gleason`) AS predictionFROM dfs.model_data.`data_sample.csv`LIMIT 5; prediction True False True True False 看完, 如果感觉”云里雾里”, “不明觉厉”. 请直接看代码即可, 代码比文字更具有说服力.]]></content>
      <categories>
        <category>Distributed System</category>
      </categories>
      <tags>
        <tag>Apache Drill</tag>
        <tag>Big Data</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flink学习手札之State篇]]></title>
    <url>%2Fbigdata%2Fflink%2Fstate%2F</url>
    <content type="text"><![CDATA[Youtube上观看的Flink学习笔记, 有段时间了, 由于是边看视频边记得笔记, 逻辑有些乱, 还请见谅! 有时间再重新整理下! Flink状态语义Flink自带的DataStream Operators、Sources、Sinks具有状态, 用于缓冲Record或维护部分结果状态. 如Window Operator可为ProcessWindowFunction, 收集输入数据Record, 也可为 ReduceFucntion,ProcessFunction会记住调度计时器输出结果, 以及一些Sink函数维持事务状态提供恰好一次语义性. Operator StateFlink支持三种类型的Operator State: list state, list union state, broadcast state list state list union state broadcast state 状态原语Flink支持多种状态原语(State primitives): 状态原语 常见方法 ValueState[T] value(); update(value: T) ListState[T] add(value: T); addAll(values: java.util.List[T]); get(): Iterable[T]; update(value: java.util.List[T]) MapState[K,V] get(key: K); put(key: K, value: V); contains(key: K); remove(key: K) etc. (iterators method etc..) ReducingState[T] add(value: T); get(): Iterable[T] //(single entry); （提供了ListState[T]相同方法,除了 addAll()及update()) AggregatingState[I, O] (与ReducingState类似, 但使用AggregateFunction进行聚合) get(): Iterable[T] //(single element) 状态后端 状态后端 说明 MemoryStateBackend 不宜用于生产环境,低延迟,容易造成gc暂停,堆内存溢出,受限于TaskManager内存,TM故障易丢失状态 FsStateBackend 存储本地状态至TM JVM堆内存,写入状态至远程文件系统,受限于TaskManager内存,有GC pauses RocksDBStateBackend 存储所有状态至本地RocksDB实例,适用于状态量数据庞大应用,支持增量Checkpoint,数据写磁盘序列化/反序列化开销大 State Operator性能取决于多重因素,State数据类型、StateBackend、State Primitives. StateBackend对状态对象进行序列化反序列化. 对于RocksDBBackend使用MapState[K,V]比ValueState[HashMap[K,V]]更加高效, 如果数据元素经常频繁加入列表很少访问,使用 ListState[T]比ValueState[List[T]]更加高效. 建议: 仅每次调用函数时更新状态. Checkpoint和函数调用同步, 多重状态更新并未带来额外好处, 反而会增加单次函数调用更新多重状态带来的序列化开销. RocksDBStateBackend中ListState实现,在读取数据构造Iterable前反序列化所有list entries,但是增加单个值至ListState很廉价,仅需对追加的值进行序列化即可. RocksDBStateBackend中MapState在进行读写时,仅有要读写的KV值才被序列化/反序列化. 遍历MapState时,仅有实际被访问的KV值被RocksDB预先反序列化. 应用示例代码, 参考如下: 12345678910val env = StreamExecutionEnvironment.getExecutionEnvironmentenv.enableCheckpointing(10000L) // 10 Seconds checkpoint interval// Set Maxium Parallelism of Keyed State Operatorsenv.setMaxParallelism(512) // App maximum parallelismval alerts: DataStream[(String, Double, Double)] = keyedSensorData .flatMap(new TemperatureAlertFunction(1.8)) .setMaxParallelism(1024) // Set maximum parallelism for this operator and override// Setting a unique identifier for an operatoralerts.uid("TempAlert") Operator唯一性标识符和最大并行度, 均Baked into a savepoint, 不能更改. 如果标识符或Operators最大并行度变更, 不能成功从Savepoint重启. (任务必须重新部署上线)计算Flink算子(Operator)最大并行度, 逻辑参考如下:一Operator默认最大并行度取决于第一版应用Operator的并行度, 通常最大并行度为: 128 , (如果并行度小于128, 否则使用下面条件取最小值); min { nextPowerOfTwo(parallelism + (parallelism / 2)), 2^15} Queryable StateQueryable State并不适用于应用重启或应用拓展(rescaling), 仅当应用运行时才可访问. QS仅支持 keyed state, 适用于重要查询, 如实时Dashboards或其它监控程序. 示例代码, 参考如下: 12345678910111213141516// Configuring keyed state to be queryableoverride def open(parameters: Configuration): Unit = &#123; val lastTempDescriptor = new ValueStateDescriptor[Double]("lastTemp", classOf[Double]) lastTempDescriptor.setQueryable("lastTemperature") lastTempState = getRuntimeContext.getState[Double](lastTempDescriptor)&#125;val tenSecMaxTemp: DataStream[(String, Double)] = sensorData.map(r =&gt; (r.id, r.temperature)) .keyBy(_._1) .timeWindow(Time.seconds(10)) .max(1)// Write a DataStream into a queryable state sinktenSecMaxTemp .keyBy(_._1) .asQueryableState("maxTemperature") 任何JVM应用程序均可通过Flink运行的QueryableStateClient, QS开发时需添加依赖 flink-queryable-state-client-java, 如何使用, 以下代码为一个小例子: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546object TemperatureDashboard &#123; val proxyHost = "127.0.0.1" //TaskManger host address val proxyPort = 9069 // QSClient Proxy listening port, 9069 default val jobId = "d2447b1a5e0d952c372064c886d2220a" //Acquire it by Rest API,logs or Web UI val numSensors = 5 val refreshInterval = 10000 def main(args: Array[String]): Unit = &#123; val client = new QueryableStateClient(proxyHost, proxyPort) val futures = new Array[CompletableFuture[ValueState[(String, Double)]]](numSensors) val results = new Array[Double](numSensors) val header = (for (i &lt;- 0 until numSensors) yield "sensor_" + (i + 1)) .mkString("\t| ") println(header) // print header line of dashboard table while (true) &#123; for (i &lt;- 0 until numSensors) &#123; futures(i) = queryState("sensor_" + (i + 1), client) &#125; for (i &lt;- 0 until numSensors) &#123; results(i) = futures(i).get().value()._2 &#125; val line = results.map(t =&gt; f"$t%1.3f").mkString("\t| ") println(line) Thread.sleep(refreshInterval) &#125; client.shutdownAndWait() &#125; def queryState(key: String, client: QueryableStateClient): CompletableFuture[ValueState[(String, Double)]] = &#123; client.getKvState[String, ValueState[(String, Double)], (String, Double)]( JobID.fromHexString(jobId), "maxTemperature", key, Types.STRING, new ValueStateDescriptor[(String, Double)]( "", // state name not relevant here Types.TUPLE[(String, Double)]) ) &#125;&#125;]]></content>
      <categories>
        <category>Distributed System</category>
      </categories>
      <tags>
        <tag>Big Data</tag>
        <tag>Apache Flink</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cascading实战之SubAssembly篇]]></title>
    <url>%2Fbigdata%2Fcascading%2Fsubassembly%2F</url>
    <content type="text"><![CDATA[本文将介绍Cascading中SubAssembly相关概念及使用. Cascading中管道(Pipe)构成部分, 也称管道子组件(Pipe SubAssembly), 通过使用这些自带的SubAssembly或者自定义的SubAssembly, 可以很方便地构建一Cascading Pipe. Cascading自带SubAssemblyCascading中, 包含以下自带的SubAssembly: cascading.pipe.assembly.Coerce, 可以通过使用Corece将Field转换成另一类型, 示例代码如下: 12// 将字符串类型(String)的`timestamp`转换成Long类型pipe = new Coerce(pipe, new Fields("timestamp"), Long.class); cascading.pipe.assembly.Discard, 丢弃元组中特定Fields, 示例代码如下: 1pipe = new Discard(pipe, new Fields("timestamp")); cascading.pipe.assembly.Retain, 保留元组中特定Fields, 示例代码如下: 1pipe = new Retain(pipe, new Fields("year", "month")); cascading.pipe.assembly.Rename, 为特定Field重命名, 示例代码如下: 1pipe = new Rename(pipe, new Fields("timestamp"), new Fields("datetime")); cascading.pipe.assembly.Unique, 对元组去重, 保留唯一性元组, 该SubAssembly内部使用GroupBy及FirstNBuffer实现, 示例代码如下: 1pipe = new Unique(pipe, new Fields("year", "month"), Fields.ALL); AggregateBy, 与MapReduce中Combiner有些类似, 对Map端聚合进行优化, AggregateBy通过Functor进行优化, AggregateBy.Functor存在以下方法签名: 12345678public interface AggregateBy.Functor extends Serializable &#123; // 获取待聚合、已声明的Fields Fields getDeclaredFields(); // 传入Tuple和Context进行聚合 Tuple aggregate(FlowProcess flowProc, TupleEntry args, Tuple context); // 获取聚合结果元组 Tuple complete(FlowProcess flowProc, Tuple context);&#125; AggregateBy使用一名为LRU(Least Recently Used)的内部Buffer缓存聚合值, 该LRU缓存存在阈值(Threshold), 当阈值满后存入计算中的聚合值, 当LRU满了若检测到新的Group要聚合, 则移除老的Entry. 以下聚合器均为AggregateBy子类: MinBy, 求组中最小值 MaxBy, 求组中最大值 SumBy, 对组中元组求和 AverageBy, 求组中元组平均值 CountBy, 对组中元组计数 FirstBy, 求组中第一项值, 注意并不存在LastBy 示例代码如下: 12345678// `SumBy`聚合器使用示例Pipe inPipe = new Pipe("AggregateBy");// 以雇员`EmployeeName`进行分组, 对雇员薪资进行求和(求和部分为涨薪总和`TotalRaise`), // Value部分为涨薪部分`Raise`inPipe = new SumBy(inPipe, new Fields("EmployeeName"), new Fields("Raise"), new Fields("TotalRaise"), Double.class);// 打印所有结果元组inPipe = new Each(inPipe, new Debug()); Cascading自定义SubAssembly以下代码, 示意了如何创建一自定义SubAssembly: 123456789101112131415161718192021import cascading.operation.Debug;import cascading.pipe.Each;import cascading.pipe.Every;import cascading.pipe.GroupBy;import cascading.pipe.Pipe;import cascading.pipe.SubAssembly;import cascading.tuple.Fields;public class SubAssemblyEx extends SubAssembly &#123; public SubAssemblyEx(Pipe inPipe) &#123; inPipe = new Each(inPipe, new SentenceFunction()); inPipe = new Each(inPipe, new Debug()); inPipe = new GroupBy(inPipe, new Fields("document"), new Fields("sentnum")); inPipe = new Every(inPipe, new TokenBuffer(), new Fields("docname", "sentnum", "wordnum", "word")); inPipe = new Each(inPipe, new Debug()); setTails(inPipe); &#125;&#125; SubAssemblyEx有关测试代码, 如下: 12345678910111213141516171819public class SubAssemblyExTest &#123; public void main(String[] args) &#123; Fields fieldDeclarationInput = new Fields("document", "text"); Fields fieldDeclartionOutput = new Fields("docname", "sentnum", "wordnum", "word"); Scheme inputScheme =new TextDelimited(fieldDeclarationInput, true, "\t"); Scheme outputScheme = new TextDelimited(fieldDeclartionOutput, "\t"); Tap srcTap = new FileTap(inputScheme, args[0]); Tap sinkTap = new FileTap(outputScheme, args[1], SinkMode.REPLACE); Pipe inPipe = new Pipe("InPipe"); Pipe pipeProc = new SubAssemblyEx(inPipe); Flow flow = new LocalFlowConnector(); flow.connect("process", srcTap, sinkTap, pipeProc); flow.complete(); &#125;&#125; 如果想使用多个独立的Pipe SubAssembly, 参考代码如下: 1234567891011121314public class SubAssemblyTailsEx extends SubAssembly &#123; // 返回两个独立的Pipe Assembly public SubAssemblyTailsEx(Pipe inPipe) &#123; Pipe pipeSentence = new Pipe("pipeSentence", inPipe); pipeSentence = new Each(pipeSentence, new SentenceFunction()); Pipe pipeToken = new Pipe("pipeToken", pipeSentence); pipeToken = new GroupBy(pipeToken, new Fields("document"), new Fields("sentnum")); pipeToken = new Every(pipeToken, new TokenBuffer(), new Fields("docname", "sentnum", "wordnum", "word")); setTails(pipeSentence, pipeToken); &#125;&#125; SubAssemblyTailsEx测试代码如下: 12345678910111213141516171819202122232425262728293031public class SubAssemblyExTest &#123; public void main(String[] args) &#123; Fields fieldDeclarationInput = new Fields("document", "text"); Fields fieldDeclartionOutput = new Fields("docname", "sentnum", "wordnum", "word"); Scheme inputScheme =new TextDelimited(fieldDeclarationInput, true, "\t"); Scheme outputScheme = new TextDelimited(fieldDeclartionOutput, "\t"); Tap srcTap = new FileTap(inputScheme, args[0]); Tap sinkTap = new FileTap(outputScheme, args[1], SinkMode.REPLACE); Fields fieldSentenceOutput = new Fields("document", "sentnum", "sentence"); Fields sentenceOutputScheme = new TextDelimited(fieldSentenceOutput, "\t"); Tap sentenceSinkTap = new FileTap(sentenceOutputScheme, args[2], SinkMode.REPLACE); Pipe inPipe = new Pipe("InPipe"); SubAssembly pipeSplit = new SubAssemblyTailsEx(inPipe); Pipe pipeSentence = new Pipe(pipeSplit.getTails()[0]); Pipe pipeToken = new Pipe(pipeSplit.getTails()[1]); FlowDef flowDef = FlowDef.flowDef() .setName("TextFlow") .addSource(inPipe, srcTap) .addTailSink(pipeSentence, sentenceSinkTap) .addTailSink(pipeToken, sinkTap) FlowConnetor flowConnector = new LocalFlowConnector(); Flow flow = flowConnector.connect(flowDef); flow.complete(); &#125;&#125;]]></content>
      <categories>
        <category>Distributed System</category>
      </categories>
      <tags>
        <tag>Big Data</tag>
        <tag>Cascading</tag>
        <tag>MapReduce</tag>
        <tag>Apache Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云中漫步, Apache Phoenix UDF实战]]></title>
    <url>%2Fbigdata%2Fhbase%2Fphoenix-udf%2F</url>
    <content type="text"><![CDATA[本文将介绍Apache Phoenix中自定义函数(UDF, User Defined Function)使用. 用户自定义函数(UDF)可以访问HBase表整行数据, 通过HBase扫描每一项KV(Key-Value)值中一部分触发回调(Callback), 通常传入UDF中evaluate方法的Tuple为Row的当前状态. 配置注册自定义函数(UDF)需要变更HBase配置文件hbase-site.xml中几项配置, 参考如下: 属性名 值 phoenix.functions.allowUserDefinedFunctions true hbase.dynamic.jars.dir ${hbase.rootdir}/lib hbase.local.dir ${hbase.tmp.dir}/local/ UDF代码实战假如有这样一需求: 根据输入字符串判定是否存在元音字母, 将该逻辑封装为一UDF, 查询数据时调用该UDF即可. 参考代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import org.apache.hadoop.hbase.io.ImmutableBytesWritable;import org.apache.phoenix.compile.KeyPart;import org.apache.phoenix.expression.Expression;import org.apache.phoenix.expression.function.ScalarFuction;import org.apache.phoenix.schema.tuple.Tuple;import org.apache.phoenix.schema.types.PBoolean;import org.apache.phoenix.schema.types.PDataType;import org.apache.phoenix.schema.types.PVarchar;import java.sql.SQLException;import java.util.List;public class HasVowelsFunction extends ScalarFunction &#123; private static final String FUNC_NAME = "hasVowels"; @Override public PDataType getDataType() &#123; return PBoolean.INSTANCE; &#125; @Override public String getName() &#123; return FUNC_NAME; &#125; public HasVowelsFunction() &#123; &#125; public HasVowelsFunction(List&lt;Expression&gt; children) throws SQLException &#123; super(children); &#125; @Override public boolean evaluate(Tuple tuple, ImmutableBytesWritable ptr) &#123; Expression child = children.get(0); if (!child.evaluate(tuple, ptr)) &#123; return false; &#125; String inputStr = (String) PVarchar.INSTANCE.toObject(ptr, child.getSortOrder()); if (inputStr == null) &#123; return true; &#125; boolean vowelFound = false; for (char chr: inputStr.toCharArray()) &#123; if (vowelFound) &#123; break; &#125; switch(chr) &#123; case 'a': case 'e': case 'i': case 'o': case 'u': ptr.set(PBoolean.INSTANCE.toBytes(true)); vowelFound = true; break; default: &#125; &#125; if (!vowelFound) &#123; ptr.set(PBoolean.INSTANCE.toBytes(false)); &#125; return true; &#125; /** * 刚开始写Phoenix UDF时, 对以下俩方法感到疑惑, 点开源码, 看到以下 * 注释, 于是顺手把注释给拷贝过来, 以防下次懵逼. * * Determines whether or not a function may be used to form * the start/stop key of a scan * @return the zero-based position of the argument to traverse * into to look for a primary key column reference, or * &#123;@value #NO_TRAVERSAL&#125; if the function cannot be used to * form the scan key. */ public int getKeyFormationTraversalIndex() &#123; return NO_TRAVERSAL; &#125; /** * Manufactures a KeyPart used to construct the KeyRange given * a constant and a comparison operator. * @param childPart the KeyPart formulated for the child expression * at the &#123;@link #getKeyFormationTraversalIndex()&#125; position. * @return the KeyPart for constructing the KeyRange for this * function. */ public KeyPart newKeyPart(KeyPart childPart) &#123; return null; &#125; public OrderPreserving preservesOrder() &#123; return OrderPreserving.NO; &#125;&#125; UDF部署注册UDF, 首先需将UDF打成的Jar包放到HDFS中(路径随意), 参考指令如下, 默认Phoenix拷贝UDF的Jar包至${hbase.local.dir}. 1$ hdfs dfs -copyFromLocal udf-vowel.jar /hbase/lib/ 注册为Phoenix自定义函数, 参考指令如下: 123jdbc:phoenix:localhost:2181:/hbase&gt; CREATE FUNCTION hasVowels(varchar) RETURN BOOLEAN AS 'HasVowelsFunction' USING JAR '/hbase/lib/udf-vowel.jar'; 注册Phoenix自定义函数, 参考语法如下: 12CREATE [TEMPORARY] FUNCTION &#123;function_name&#125;RETURN &#123;phoenix_data_type&#125; AS &#123;class_name&#125; USING JAR &#123;hdfs_jar_path&#125; 显然, 注册UDF时, Phoenix存储元数据于SYSTEM.FUNCTION系统表中, 这些元数据包括如UDF Jar包路径、函数名、返回类型、函数参数个数等信息. UDF限制 目前仅支持ScalarFunction, 暂时不支持自定义聚合函数(UDAF)、自定义表生成函数(UDTF). 每次执行UDF时, 动态的Class Loader拷贝UDF Jar包至Phoenix客户端路径 ${hbase.local.dir}下, 当删除UDF时Jar包需手动删除. 由于Jar包于HBase RegionServer上加载, 任何UDF变更意味着重新打成Jar包,并添加至 hbase.dynamic.jars.dir(即${hbase.rootdir}/lib). 如果RegionServer宕机, 需重新部署UDF. 查询UDF函数, 需手动查询系统表SYSTEM.FUNCTION .]]></content>
      <categories>
        <category>Distributed System</category>
      </categories>
      <tags>
        <tag>Big Data</tag>
        <tag>Apache Phoenix</tag>
        <tag>Apache HBase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云中漫步, 浅析Apache Phoenix事务]]></title>
    <url>%2Fbigdata%2Fhbase%2Fphoenix-txn%2F</url>
    <content type="text"><![CDATA[本文将对Apache Phoenix事务进行剖析. ACID 原子性(Atomicity) 一致性(Consistency) 隔离性(Isolation) 持续性(Durability) 事务控制 提交(Commit) 回滚(Rollback) 存储点(Savepoint). 可以通过回滚恢复的数据库状态. 事务设置(Set Transaction), 如有些数据库支持通过SET TRANSACTION子句设置事务名, 通过事务名便于区分和理解. Phoenix事务关于HBase对于事务支持, 可以参考官方文档. 通常HBase同一RowKey的Cell数据位于同一RegionServer, HBase支持Region级别的Cell数据(或Rows上批量)原子性操作, 通过checkAndPut、checkAndDelete、increment/append等维护Cell数据原子性, 通过MultiRowMutationEndPoint支持Region级别跨行等批量操作. 但HBase并不支持跨Region、跨表或基于多RPC调用的原子性操作. HBase默认不支持完备的ACID语义, 但可通过一些第三方组件如Apache Tephra获取更加广泛的事务语义. 事务管理器于ZooKeeper中注册, 利用ZK进行协同, HBase与事务管理器间交互示意图如下: 通常事务管理器维护着一写指针(指向数据库写入ID), 为每一项事务提供唯一性事务ID并维护事务状态(In-Progress进行、Commited已提交、Invalid无效事务), 必要时解决事务冲突问题. 事务管理器简单而快速、保存所有必要状态至内存中并持久化于预写日志(WAL)中. 可以配置事务管理器处于HA高可用状态, 一主(活跃)一备(备用), 以便发生故障时快速转移. 开启事务(示意图如下), 读指针、写指针及当前状态, 当客户端调用开启事务, 事务管理器孵化一新事务, 写指针自增并追加事务日志. 将事务状态存入内存, 在一定程度上可提高事务性能. 提交事务时(示意图如下), 如果事务成功, In-Progress指针自减, Commited指针自增, 最终写入事务日志记录事务完成. 客户端通过RPC调用事务管理器开启事务, 事务管理器开启事务并将状态从New改为In-Progress, 当客户端执行完如Put/Delete等操作时, 客户端通过调用Commit RPC提交更新至HBase, 事务管理器接收更新并检测事务冲突, 若无冲突将更新写入HBase并记录版本号. 若客户端提交更新失败, 初始化Abort(放弃操作), 若Abort成功, 事务完整、可回滚; 如Abort失败, 事务无效并将其写入日志. Phoenix事务生命周期示意图如下: 多版本并发控制多版本并发控制(MVCC, Multiversion concurrency control), 用于处理并发事务. 通过对每位用户数据及时写快照, 只有当事务完成或提交时用户才能看到这些变更, 任何数据更新写入新快照同时记录新的版本数, 并确保所有版本数据不会覆写老数据. HBase使用MVCC进行数据读取, 避免行锁, HBase中多版本读写大致过程如下: 数据读取: 每次进行读操作时记录数据读取时间戳于Read Point 所有写入及已写入数值(Write Number)不大于已完成数值, 即此时Read Point数值最大 将写入数值不大于读取时Read Point的特定数据行(或列)对应Data Cell返回 数据写入: 获取行锁后, 每次执行写入操作记录写入数值(Write Number) 将步骤1获取的写入数值存储至每项Data Cell的Write Store中 通过声明写入数值, 标志着写入操作完成 乐观并发控制乐观并发控制(OCC, Optimistic Concurrency Control), 适用于事务间互不干扰情形, 避免了锁表、锁行开销. 如果数据正由其它事务修改, OCC在事务提交前会验证每一项数据修改, 然后回滚索引变更. OCC适用于短期事务、分区分割等场景. 事务管理器TephraApache Tephra作为一事务管理器, 可以为分布式存储如HBase提供事务管理, 如多版本控制器和事务回滚. Tephra使用快照隔离, 利用HBase的数据版本为事务读写提供多版本并发控制(MVCC), 通过为每一个用户保留数据快照进行多本版并发控制. Tephra事务控制允许跨HBase表、Region, 允许RPC调用, 支持ACID语义. 配置默认Phoenix没有启用事务, 为开启事务, 需在HBase配置文件hbase-site.xml中启用参数phoenix.transactions.enabled, 参考配置如下, 为使配置生效需重启RegionServer. 12345678910111213141516&lt;property&gt; &lt;name&gt;phoenix.transactions.enabled&lt;/name&gt; &lt;value&gt;true&lt;/value&gt;&lt;/property&gt;&lt;!-- 指定事务快照路径 --&gt;&lt;property&gt; &lt;name&gt;data.tx.snapshot.dir&lt;/name&gt; &lt;value&gt;/tmp/tephra/snapshots&lt;/value&gt;&lt;/property&gt;&lt;!-- 指定事务超时时间 --&gt;&lt;property&gt; &lt;name&gt;data.tx.timeout&lt;/name&gt; &lt;value&gt;60&lt;/value&gt;&lt;/property&gt; 配置完毕, 开启事务管理器Tephra, 参考指令如下: 12$ # Phoenix安装包路径bin目录下存在Tephra二进制可执行文件$ ./bin/tephra start 开启事务可以在建表时设置事务或后续更新表时支持事务, 在建表时开启事务参考语句如下: 1234567891011-- 建表时开启事务SQL语法CREATE TABLE table_name (column(s) data type(s)) TRANSACTIONAL=true;-- 创建供应商表时开启事务CREATE TABLE SUPPLIER( SUPPLIER_ID BIGINT NOT NULL PRIMARY KEY, SUPPLIER_NAME VARCHAR(30),CITY VARCHAR(40), STATE VARCHAR(30), ZIP INTEGER(10), COUNTRY VARCHAR(100)) TRANSACTIONAL=true; 在更新数据表时开启事务, 参考语句如下: 12345-- 在更新数据表时开启事务, SQL语法ALTER TABLE table_name SET TRANSACTIONAL=true;-- 如在CUSTOMER表上开启事务ALTER TABLE CUSTOMER SET TRANSACTIONAL=true; 注意, 若在非事务表上启用事务, 该表后续不能改回非事务状态(事务表). 提交事务当Phoenix处于事务执行模式, 任何查询中调用的Statement将初始化一新事务, 数据处于Raw状态直至提交. 可以通过!commit指令提交事务, 以下仅为示例脚本: 123456789-- 假定Phoenix处于事务执行模式, 开启新事务SELECT * FROM ORDERS;-- 插入、删除部分数据UPSERT INTO ORDERS VALUES (10250,'2015-5-7', 108, 50,'A1100');DELETE FROM ORDERS WHERE ORDER_ID='10248';-- 提交事务!commit Phoenix事务限制 需手动清理无效事务列表. 失败或不合法事务会被加入一无效事务列表中, 该列表由Tephra维护, 发生重大合并时需手动清理该列表. Tephra开发者后续会着手解决这个问题, 毕竟多数数据库支持自动清除无效事务. 在事务表上创建异步索引(如执行CREATE INDEX ASYNC子句)前, 需对数据做重大归并(Major Compaction), 否则索引中会出现事务未提交或无效事务. 创建事务表时数据版本数(值)需设置合理, 否则会导致部分重要日志数据丢失.]]></content>
      <categories>
        <category>Distributed System</category>
      </categories>
      <tags>
        <tag>Big Data</tag>
        <tag>Apache Phoenix</tag>
        <tag>Apache HBase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云中漫步, Apache Phoenix之性能优化篇]]></title>
    <url>%2Fbigdata%2Fhbase%2Fphoenix-tuning%2F</url>
    <content type="text"><![CDATA[本文将对Apache Phoenix性能优化进行小结. Phoenix性能优化建议: 在进行数据加载操作时, 优先考虑Phoenix批量加载; 创建索引时, 默认索引创建为一同步过程(非异步), 如果数据表很大, 可能比较耗时, 此时可以考虑异步创建索引; 开启Phoenix Tracing服务, 全方位监测Phoenix各项Metrics, 确保HBase集群或Phoenix服务健壮性; 可以利用一些第三方Benchmark、性能测试工具, 如Pherf等, 对Phoenix进行性能测试等, 以便更好地进行优化. Phoenix批量加载Apache Phoenix通过MapReduce作业, 允许批量加载CSV或JSON数据集至Phoenix表中, Phoenix批量加载工具内部为数据表生成对应HFile, 吞吐量高、高效利用集群资源, 比安装包路径下bin/psql.py脚本(该脚本使用HBase Put API)好用, 进行批量操作时也可以指定索引表名. 启用批量加载参考指令如下: 123456$ # 设置环境变量$ export HADOOP_CLASSPATH = $(hbase mapredcp):/path-to-hbase-conf$ # 加载CSV数据集至Phoenix表$ hadoop jar phoenix-&lt;version&gt;-HBase-&lt;hbase-version&gt;-client.jar org.apache.phoenix.mapreduce.CsvBulkLoadTool --table ORDERS --input orders.csv$ # 加载JSON数据集至Phoenix表$ hadoop jar phoenix-&lt;version&gt;-HBase-&lt;hbase-version&gt;-client.jar org.apache.phoenix.mapreduce.JsonBulkLoadTool --table ORDERS --input orders.json 批量加载其它相关参数如下: 参数 说明 —input 数据输入路径, 必须指明 —zookeeper ZK Quorum URI —schema 数据表Schema —table 数据表, 必须指明 —index-table 索引表 —import-columns 数据列, 通过逗号分割 —ignore-errors 忽视Job中产生的任何错误 —output 临时HFile输出路径 —delimiter 仅用于CSV数据集, 默认分隔符为逗号 —quote 仅用于CSV, 默认为双引号(Double Quote) —arrary-delimiter 数组元素分隔符, 默认为冒号(:) 注意事项 默认每个列族批量加载HFile超过32个,会抛出IOException异常,可以适当增加Region大小(默认为10GB),或修改HBase配置文件hbase-site.xml中hbase.mapreduce.bulkload.max.hfiles.perRegion.perFamily参数. 批量加载JSON数据集时, JsonBulkLoadTool任务并不允许JSON嵌套, JSON中列表内部映射为Phoenix中数组类型. 当导入CSV数据时, 若列为数组类型, 可使用不同分隔符分割数组元素, 数组默认分隔符为冒号. 如果目的表为新建的Phoenix表, 请确保该表已预分割(Pre-split), 因为Job中Reducer数量取决于表中Region数量. 进行批量加载时, 若使用参数—output指定HFile输出路径, 请确保执行该指令时具有对应的用户权限, 如HFile须由”hbase”用户生成等. Phoenix Tracing Server为更好地监测Apache Phoenix, Phoenix集成了Apache HTrace, HTrace作为一分布式Tracing组件, 支持对HBase等组件进行Tracing. Phoenix支持Tracing客户端及服务端, 并提供一Web UI界面可视化这些Traces信息. 首先了解下Tracing中几个相关概念: Trace, 用户初始化请求于TraceScope, Trace管理Span的生命周期. Span, 每一项Trace由多项Span组成, 每一项Span由一伪随机数标识, 对应一RPC或执行块(Block), Span可深度嵌套, 每一项Span具拥有其对应父Span信息, Span可跨网段. Span的开始、结束时间、描述信息及其它相关信息具有声明. Span Receivers, 或者说采集器, 从Trace源采集Span并写入存储, 如LocalFileSpanReceiver、StandardOutSpanReceiver、ZipkinSpanReceiver、TraceMetricSource等. 配置Hadoop Metrics框架通过使用MetricsSource及MetricsSink生产并消费Metrics. Phoenix提供一自定义Sink, 可接收客户端及服务端Trace等信息于默认系统表SYSTEM.TRACING_STATS中. 为启用Tracing, 需在客户端和服务端进行配置. 客户端配置参考如下: 1234567891011# Metrics Sinkphoenix.sink.tracing.class=org.apache.phoenix.trace.PhoenixMetricsSinkphoenix.sink.tracing.context=tracing# 每10秒从所有Source采样*.period=10# Tracing频率, 可以将以下配置写入hbase-site.xml中phoenix.tracing.frequency=[never | always | probability]# 当Tracing频率设置为 `probability`时, 可配置其阈值phoenix.trace.probability.threshold = 0.05 也可通过代码进行配置, 参考如下: 12345Properties props = new Properties();props.setProperty("phoenix.trace.frequency", "probability");props.setProperty("phoenix.trace.probability.threshold", 0.5)final Connection conn = DriverManager.getConnection("jdbc:phoenix:localhost", props); 服务端配置参考如下: 12345678# Metrics Sinkphoenix.sink.tracing.class=org.apache.phoenix.trace.PhoenixMetricsSinkphoenix.sink.tracing.context=tracing# 确保接收Server的Tracehbase.sink.tracing.class=org.apache.phoenix.trace.PhoenixMetricsSinkhbase.sink.tracing.writer-class=org.apache.phoenix.trace.PhoenixTableMetricsWriterhbase.sink.tracing.context=tracing 默认所有Trace写入系统表SYSTEM.TRACING_STATS, 如需更改, 修改HBase配置文件hbase-site.xml中参数phoenix.trace.statsTableName即可, 如下: 1234&lt;property&gt; &lt;name&gt;phoenix.trace.statsTableName&lt;/name&gt; &lt;value&gt;&#123;your_tracing_table&#125;&lt;/value&gt; &lt;/property&gt; 运行可以通过以下指令, 在Phoenix终端中开启或禁用Tracing: 12345# 启用Tracingjdbc:phoenix:PHOENIX-N1:2181&gt; TRACE ON;# 禁用Tracingjdbc:phoenix:PHOENIX-N1:2181&gt; TRACE OFF; 也可通过运行以下Python脚本开启Tracing Server, 并通过一Web UI界面查看这些Traces, 如Trace分布、计数、Timeline、依赖等. 12# 在Phoenix安装包路径下键入以下指令$ ./bin/traceserver.py start 执行以上指令, 运行一Jetty Server(默认监听端口8864), 如需更改Tracing Server监听端口, 修改HBase配置文件hbase-site.xml中以下参数即可: 12345&lt;!-- 默认端口为8864, 可自行修改 --&gt;&lt;property&gt; &lt;name&gt;phoenix.traceserver.http.port"&lt;/name&gt; &lt;value&gt;8864&lt;/value&gt;&lt;/property&gt; Trace请求被封装至MetricsRecord并写入数据表(默认系统表SYSTEM.TRACING_STATS)中, 可以通过以下指令查看表中数据: 123456$ bin/sqlline.pyjdbc:phoenix:PHOENIX-N1:2181&gt; SELECT * FROM SYSTEM.TRACING_STATS;# 查看系统表 SYSTEM.TRACING_STATS 的Schemajdbc:phoenix:PHOENIX-N1:2181&gt; !describe SYSTEM.TRACING_STATS 异步创建索引Phoenix创建索引默认为一同步过程(非异步), 比较耗时. 随着Phoenix后续不断优化, 也支持异步创建索引, 主要通过MapReduce任务实现, 异步创建索引参SQL语法如下: 1CREATE INDEX index_name ON schema_name.table_name (columns) ASYNC 也可通过命令行(本质上运行相关Jar包)异步创建索引, 参考如下: 123456$ # 设置环境变量$ export HADOOP_CLASSPATH = $(hbase mapredcp):/path-to-hbase-conf$ hadoop jar phoenix-&lt;version&gt;-HBase-&lt;hbase-version&gt;-client.jar \ org.apache.phoenix.mapreduce.index.IndexTool \ --schema MY_SCHEMA --data-table MY_TABLE --index-table ASYNC_IDX \ --output-path /hdfs/path/for/hfiles 执行完以上指令后, Phoenix内部将索引状态标记为INACTIVE, 当MapReduce任务执行完后, 索引状态变为ACTIVE, 此时可接收查询.]]></content>
      <categories>
        <category>Distributed System</category>
      </categories>
      <tags>
        <tag>Big Data</tag>
        <tag>Apache Phoenix</tag>
        <tag>Apache HBase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shapeless初体验之Poly与Type Class篇]]></title>
    <url>%2Fshapeless%2Fpoly%2F</url>
    <content type="text"><![CDATA[本文将接着介绍Shapeless中Poly用法, 希望你能Get到Poly的一些使用技巧. 牛刀小试假定有这样一个需求, 存在产品A和产品B, A与B的属性存在差异, 现在希望设计一泛型接口对A(或B)进行属性判定并转换成B(或A). 没看明白需求? 没关系, 下面使用代码量化下 12345678910111213141516171819// 假定存在产品A和B, 产品属性存在差异 (当然实际业务场景中产品属性更复杂些, 本例进行了简化)// 假定产品A存在以下三个属性: 产品名称, 价格, 是否有评分 (当然实际业务场景, 价格使用BigDecimal更合适)case class ProductA(name: String, price: Double, hasScore: Boolean)// 假定产品B存在以下三个属性: 产品名称, 价格是否实惠, 排名(或评分等级)case class ProductB(name: String, isExpensive: Boolean, rank: Double)// 现在希望存在类似于以下接口, 以便产品A转换成产品BProductA("Some Product", 106.99, true).mapTo[ProductB](SomeConversionRules)// 为了简化说明, 假定 产品A -&gt; 产品B 转换逻辑, 伪代码参考如下val productA = ProductA(name, price, hasScore)productA match &#123; case (name, price, hasScore) =&gt; // 假定超过 $100 认为偏贵 val isExpensive = if (price &gt; 100d) true else false val rank = if (hasScore) 1d else 0d ProductB(name, isExpensive, rank) case _ =&gt; // Do Nothing&#125; 由于是设计一泛型接口, 所以不能直接使用上面的模式匹配逻辑代码, 上面的模式匹配代码也仅仅只是做个说明. 泛型是个好东西, 特别是面临快速代码复用迭代时. 明确了产品A到产品B的转换逻辑, 可以先开始写 SomeConversionRules 代码 12345678910111213/** * 使用Shapless中的`Poly1`. 单例对象 `SomeConversionRules` 中的各隐式值 * 你可以先简单理解成 ProductA -&gt; ProductB (或ProductB -&gt; ProductA) * 各自对应属性类型间转换关系 */ object SomeConversionRules extends Poly1 &#123; // double -&gt; boolean implicit val doubleCase: Case.Aux[Double, Boolean] = at(_ &gt; 100d) // boolean -&gt; double implicit val booleanCase: Case.Aux[Boolean, Double] = at(if(_) 1d else 0d) // string -&gt; string implicit val stringCase: Case.Aux[String, String] = at(identity)&#125; 技巧本例将使用隐式转换与类型类设计接口. 首先, 回到产品A到产品B的映射关系上, 先简单定义一个 ProductMapper 特质 1234trait ProductMapper[A, B, P] &#123; // 定义 `apply()` 工厂方法, ProductA -&gt; ProductB ( A -&gt; B) def apply(product: A): B&#125; 现在利用隐式方法实例化 ProductMapper (本例使用隐式转换, 好处在于灵活, 对于同一接口源码而言, 上下文确定, 对于实现productA.mapTo[ProductB], 可以减少很多不必要的显示接口调用, 相对灵活) 12345678910111213141516171819// Generic Product Mapperimplicit def genericProductMapper[ A, B, P &lt;: Poly, ARepr &lt;: HList, BRepr &lt;: HList] ( implicit aGen: Generic.Aux[A, ARepr], bGen: Generic.Aux[B, BRepr], mapper: hlist.Mapper.Aux[P, ARepr, BRepr]): ProductMapper[A, B, P] = &#123; new ProductMapper[A, B, P] &#123; //注意 `bGen.from` 与 `aGen.to` 调用的是 `Generic[T]` 特质中方法 def apply(a: A): B = bGen.from(mapper.apply(aGen.to(a))) &#125;&#125; 其中, Generic Shapeless源码参考如下: 1234567891011121314151617181920object Generic &#123; /** `Aux[T, Repr0]` 实际上为一 `Generic[T]` 特质 * 实际上 `Aux[T, Repr0]` 中类型参数 `Repr0` 也可替换为 `U` * 即 `Aux[T, U]`, 只需保证 `U` 为&#123;T&#125;泛型表征, 可组合于&#123;Coproduct&#125;与&#123;HList&#125;类型 */ type Aux[T, Repr0] = Generic[T] &#123; type Repr = Repr0 &#125; def apply[T](implicit gen: Generic[T]): Aux[T, gen.Repr] = gen implicit def materialize[T, R]: Aux[T, R] = macro GenericMacros.materialize[T, R]&#125;trait Generic[T] extends Serializable &#123; /** The generic representation type for &#123;T&#125;, which will be composed of &#123;Coproduct&#125; and &#123;HList&#125; types */ type Repr // T -&gt; Repr def to(t : T) : Repr // Repr -&gt; T def from(r : Repr) : T&#125; hlist.Mapper 源码参考如下: 1234567891011121314151617181920212223trait Mapper[HF, In &lt;: HList] extends DepFn1[In] with Serializable &#123; type Out &lt;: HList &#125;object Mapper &#123; def apply[F, L &lt;: HList](implicit mapper: Mapper[F, L]): Aux[F, L, mapper.Out] = mapper type Aux[HF, In &lt;: HList, Out0 &lt;: HList] = Mapper[HF, In] &#123; type Out = Out0 &#125; implicit def hnilMapper1[HF]: Aux[HF, HNil, HNil] = new Mapper[HF, HNil] &#123; type Out = HNil def apply(l : HNil): Out = HNil &#125; implicit def hlistMapper1[HF &lt;: Poly, InH, InT &lt;: HList, OutT &lt;: HList] (implicit hc : Case1[HF, InH], mt : Mapper.Aux[HF, InT, OutT] ): Aux[HF, InH :: InT, hc.Result :: OutT] = new Mapper[HF, InH :: InT] &#123; type Out = hc.Result :: OutT def apply(l : InH :: InT): Out = hc(l.head) :: mt(l.tail) &#125;&#125; 现在实现 productA.mapTo[ProductB] 中 mapTo 方法主逻辑, 可以考虑通过隐式类拓展ProductMapper 并通过生成器模式实现 mapTo 方法 123456789implicit class ProductMapperOperation[A](product: A) &#123; class Builder[B] &#123; def apply[P &lt;: Poly](poly: P)(implicit pm: ProductMapper[A, B, P]): B = pm.apply(product) &#125; // 使用生成器模式 def mapTo[B]: Builder[B] = new Builder[B]&#125; 效果12scala&gt; ProductA("Some Product", 106.99, true).mapTo[ProductB](SomeConversionRules)res0: ProductB = ProductB("Some Product", true, 1.0) 以上代码只是个小例子, 该接口适用场景: 产品A与产品B存在关联(比如产品属性间存在关联逻辑), 或者开发时版本迁移问题(不同版本中可能存在同一产品属性间Migrate问题) 希望你能Get到Shapeless中Poly的一些使用技巧, 或者类型类与隐式转换在泛型接口设计上的一些思考.]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>JVM And JVM Languages</tag>
        <tag>Shapeless</tag>
        <tag>Generic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cascading实战之自定义操作(Custom Operations)篇]]></title>
    <url>%2Fbigdata%2Fcascading%2Fcustops%2F</url>
    <content type="text"><![CDATA[本文将介绍如何编写Cascading自定义操作. 常见用例分析尽管Cascading自带很多实用的Operations, 但有时须编写自定义Operation, 常见用例如下: 加载某些外部数据时(通常也可使用prepare()方法), 可能需要编写自定义操作, 如不同数据类型(如在StopList上使用HashJoin或CoGroup管道). 注意, 可以通过使用cascading.hadoop.tap.DistCacheTap将文件存入Hadoop分布式缓存中充当Source而非Sink. 如某种复杂的过滤或函数要求, 通常可以使用Expression类, 但有时为了性能和可维护性, 需要开发者自行实现. 某些情况下, Cascading并不提供特定数据结构或持久化类, 如在图处理方面可能需编写Custom Operations. 有时, 你需要一过滤器或函数对多个Field进行简单的比较或计算, 可以使用ExpressionFilter或ExpressionFunction, 这些类使用灵活、允许实现自定义操作. 但请注意Janino编译器使用情况, Janino作为一迷你Java编译器, 有时会产生很大的”Footprint”, 通常Janino将输入作为字符串传入, 将传入的Java程序编译成字节码, 绑定输入输出变量然后执行. 常见自定义Operation实现Filter编写一自定义过滤器, 通常该Filter需继承cascading.operation.BaseOperation, 并重写以下方法: cleanup() flush() getFieldDelcaration() getNumArgs() isSafe() prepare() 现在来看个简单示例, 编写一自定义Filter, 接收元组为行号和文本, 过滤包含特定文本元组, 参考代码如下: 1234567891011121314151617181920212223242526import cascading.flow.FlowProcess;import cascading.operation.BaseOperation;import cascading.operation.Filter;import cascading.operation.FilterCall;import cascading.tuple.Fields;import cascading.tuple.TupleEntry;public class SampleFilter extends BaseOperation implements Filter &#123; String filterWord = ""; static Fields fieldInputs = new Fields("line_num", "line"); public SampleFilter(String word) &#123; // 期望传入两个Field参数 super(2); filterWord = word &#125; /** * 由于SampleFilter实现了Filter接口, 只需实现`isRemove()`方法即可 */ public boolean isRemove(FlowProcess flowProcess, FilterCall call) &#123; // 获取参数的 TupleEntry TupleEntry arguments = call.getArguments(); return arguments.getString(1).contains(filterWord); &#125;&#125; 测试代码, 参考如下: 1234567891011121314151617public class TestFilter &#123; public static void main(String[] args) &#123; Scheme mainScheme = new TextDelimited( new Fields("line_num", "line" ), true, "," ); Tap source = new FileTap(mainScheme, args[0] ); Tap sink = new FileTap(mainScheme, args[1], SinkMode.REPLACE); Pipe inPipe = new Pipe("InPipe"); inPipe = new Each(inPipe, new SampleFilter("test")); Flow flow = new LocalFlowConnector() .connect(source, sink, inPipe ); flow.complete(); &#125;&#125; Function与Filter有些类似, Cascading函数需继承类cascading.operation.BaseOperation, 重写以下方法: cleanup() flush() getFileDeclaration() getNumberArgs() isSafe() prepare() operate() 通常Cascading中Function拥有以下三个方法: prepare(), 为输出元组分配上下文(Context) operate(), 具体执行逻辑 cleanup(), 释放内存 以下这段实例代码, 读取文本文档并将文档切割成语句, 该函数运用于一Tuple Stream, 假定其中每一项Tuple代表一文档, 输出文本文件包含文档名、语句编号以及每行语句. 12345678910111213141516171819202122232425262728293031323334353637383940public class SentFunc extends BaseOperation&lt;Tuple&gt; implements Function&lt;Tuple&gt; &#123; static Fields fieldDeclaration = new Fields("document","text"); static Fields fieldOutput = new Fields("document","sentnum", "sentence"); public SentFunc() &#123; super(2, fieldOutput); &#125; @Override public void prepare(FlowProcess flowProcess, OperationCall&lt;Tuple&gt; call) &#123; call.setContext(Tuple.size(3)); &#125; public void operate(FlowProcess flowProcess, FunctionCall&lt;Tuple&gt; call) &#123; TupleEntry arguments = call.getArguments(); String[] sentences = NLPUtils.getSentences(arguments.getString(1)); int sentCounter=0; for (String sent: sentences)&#123; // 获取之前创建的元组 Tuple result = call.getContext(); // 元组成员为: 文档名、 语句编号、语句 result.set(0,arguments.getString(0)); result.set(1,sentCounter); result.set(2,sent); // 返回结果元组 call.getOutputCollector().add(result); sentCounter++; &#125; &#125; @Override public void cleanup(FlowProcess flowProcess, OperationCall&lt;Tuple&gt; call ) &#123; call.setContext(null); &#125;&#125; 其中NLPUtils.getSentences()方法, 参考代码如下: 1234567public static String[] getSentences(String text) &#123; String[] sentences = text.split("[.?!]"); for (int i=0; i&lt; sentences.length; i++) &#123; sentences[i] = sentences[i].trim(); &#125; return sentences;&#125; Aggregator实现Cascading中Aggregator接口, 需实现以下三个方法: start() aggregate() complete() 实现自定义聚合器, 通常有以下俩种方式: 实现Aggregator接口, 并实现以上三个方法 与实现自定义Cascading函数有些类似, 需重写prepare()、cleanup()等方法 下面看个简单例子, 假定产品销售数据如下(第一行为列名, 数据列分别为店名、产品名称、售出数量、退回数量), 现在需计算每种产品实际售出量. 1234567StoreName,ProductName,Sold,ReturnedStoreA,Product1,10,2StoreB,Product1,20,5StoreA,Product2,100,20StoreB,Product2,50,1StoreA,Product3,20,10StoreB,Product3,10,3 参考代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import cascading.flow.FlowProcess;import cascading.operation.Aggregator;import cascading.operation.AggregatorCall;import cascading.operation.BaseOperation;import cascading.operation.Operation;import cascading.tuple.Fields;import cascading.tuple.Tuple;import cascading.tuple.TupleEntry;public class SampleAggregator extends BaseOperation&lt;SampleAggregator.Context&gt; implements Aggregator&lt;SampleAggregator.Context&gt; &#123; public class Context &#123; long value = 0; &#125; public SampleAggregator() &#123; // 期望传入两个参数 super(2, new Fields("actual_sold")); &#125; public SampleAggregator(Fields calcFields)&#123; super(2, calcFields); &#125; public void start(FlowProcess flowProcess, AggregatorCall&lt;Context&gt; aggregatorCall) &#123; aggregatorCall.setContext(new Context()); &#125; public void aggregate(FlowProcess flowProcess, AggregatorCall&lt;Context&gt; aggregatorCall) &#123; TupleEntry arguments = aggregatorCall.getArguments(); Context context = aggregatorCall.getContext(); context.value += (arguments.getInteger(0) - arguments.getInteger(1)); &#125; public void complete(FlowProcess flowProcess, AggregatorCall&lt;Context&gt; aggregatorCall) &#123; Tuple result = new Tuple(); Context context = aggregatorCall.getContext(); result.add(context.value); aggregatorCall.getOutputCollector().add(result); &#125;&#125; 测试代码如下: 123456789101112131415161718192021222324252627282930public class TestAggregator &#123; public static void main(String[] args) &#123; Scheme sourceScheme = new TextDelimited( new Fields("store_name","product_name", "number_sold","number_returned"), true, "," ); Tap source = new FileTap(sourceScheme, args[0]); Scheme sinkScheme = new TextDelimited( new Fields("product_name", "actual_sold") ); Tap sink = new FileTap(sinkScheme, args[1], SinkMode.REPLACE); Pipe assembly = new Pipe( "total" ); assembly = new GroupBy(assembly, new Fields("product_name")); assembly = new Every(assembly, new Fields("number_sold","number_returned"), new SampleAggregator(new Fields("actual_sold")), Fields.ALL); FlowConnector flowConnector = new LocalFlowConnector(); Flow flow = flowConnector.connect(source,sink,assembly); flow.complete(); &#125;&#125; 第二种聚合器实现方式, 参考代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 public class SampleAggregator2 extends BaseOperation&lt;SampleAggregator2.Context&gt; implements Aggregator&lt;SampleAggregator2.Context&gt; &#123; public class Context &#123; long value = 0; Tuple tuple = Tuple.size(2); &#125; public SampleAggregator2() &#123; super(2, new Fields("actual_sold")); &#125; public SampleAggregator2(Fields calcFields) &#123; super(2, calcFields); &#125; @Override public void prepare(FlowProcess flowProcess, OperationCall&lt;SampleAggregator2.Context&gt; aggregatorCall) &#123; aggregatorCall.setContext(new SampleAggregator2.Context()); &#125; @Override public void cleanup(FlowProcess flowProcess, OperationCall&lt;SampleAggregator2.Context&gt; aggregatorCall) &#123; aggregatorCall.setContext(null); &#125; public void start(FlowProcess flowProcess, AggregatorCall&lt;SampleAggregator2.Context&gt; aggregatorCall) &#123; Context context = aggregatorCall.getContext(); context.value = 0; context.tuple.clear(); &#125; public void aggregate(FlowProcess flowProcess, AggregatorCall&lt;SampleAggregator2.Context&gt; aggregatorCall) &#123; TupleEntry arguments = aggregatorCall.getArguments(); Context context = aggregatorCall.getContext(); context.value += (arguments.getInteger(0)-arguments.getInteger(1)); &#125; public void complete(FlowProcess flowProcess, AggregatorCall&lt;SampleAggregator2.Context&gt; aggregatorCall) &#123; Context context = aggregatorCall.getContext(); Tuple result = context.tuple; result.add(context.value); aggregatorCall.getOutputCollector().add(result); &#125;&#125; BufferBuffer可以视为基于内存的聚合器(Aggregator), 与聚合器类似, 执行于一系列元组, 也可接收迭代器迭代. 以下这段代码, 将上述SentFunc中生成语句进行分词, 这些语句可以根据空格、冒号、分号进行分词. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.Iterator;import com.ai.utils.NLPUtils;import cascading.flow.FlowProcess;import cascading.operation.BaseOperation;import cascading.operation.Buffer;import cascading.operation.BufferCall;import cascading.tuple.Fields;import cascading.tuple.Tuple;import cascading.tuple.TupleEntry;public class TokenBuffer extends BaseOperation implements Buffer &#123; static Fields fieldDeclaration = new Fields("document", "sentnum", "sentence"); static Fields fieldOutput = new Fields("documentname", "sentnumber", "wordnum", "word"); public TokenBuffer() &#123; super(3, fieldOutput); &#125; public void operate(FlowProcess flowProcess, BufferCall bufferCall) &#123; int sentnum = 0; TupleEntry group = bufferCall.getGroup(); Iterator&lt;TupleEntry&gt; arguments = bufferCall.getArgumentsIterator(); Tuple result = Tuple.size(4); int tokenCount = 0; while(arguments.hasNext()) &#123; Tuple tuple = arguments.next().getTuple(); String tokens = NLPUtils.getToken(tuple.getString(2)); for (int i = 0; i &lt; tokens.length; i++)&#123; String token = tokens[i]; if (token == null || token.isEmpty()) continue; tokenCount++; result.set(0, group.getString("document")); result.set(1, sentnum); result.set(2, tokenCount); result.set(3, token); bufferCall.getOutputCollector().add(result); if (i == tokens.length - 1) &#123; if (!NLPUtils.isAbbreviation(token)) &#123; sentnum++; tokenCount = 0; &#125; &#125; &#125; &#125; &#125;&#125; 其中NLPUtils.getTokens()方法, 代码参考如下: 123public static String[] getTokens(String sentence) &#123; return sentence.split("[("[("[ ,;:]+");&#125; 其中NLPUtils.isAbbreviation()方法, 参考代码如下: 123456789101112131415static HashSet&lt;String&gt; abbrevs = new HashSet&lt;String&gt;();static &#123; loadTestData();&#125;public static boolean isAbbreviation(String token) &#123; token = token.toUpperCase(); if (abbrevs.contains(token)) return true; return false;&#125;private static void loadTestData() &#123; // 加载样本数据至abbrevs该HashSet中&#125; 测试代码, 参考如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import cascading.flow.Flow;import cascading.flow.local.LocalFlowConnector;import cascading.operation.Debug;import cascading.pipe.Each;import cascading.pipe.Every;import cascading.pipe.GroupBy;import cascading.pipe.Pipe;import cascading.scheme.Scheme;import cascading.scheme.local.TextDelimited;import cascading.tap.SinkMode;import cascading.tap.Tap;import cascading.tap.local.FileTap;import cascading.tuple.Fields;import com.ai.learning.SentFunc;import com.ai.learning.TokenBuffer;public class TestBuffer &#123; public static void main(String[] args) &#123; Fields fieldDeclarationInput = new Fields("document","text"); Fields fieldDeclarationOutput = new Fields("documentname","sentnumber","wordnum", "word"); Scheme inputScheme = new TextDelimited(fieldDeclarationInput, true,"\t"); Scheme outputScheme = new TextDelimited(fieldDeclarationOutput,"\t"); Tap docTap = new FileTap(inputScheme, args[0]), SinkMode.REPLACE); Tap sinkTap = new FileTap(outputScheme, args[1], SinkMode.REPLACE); Pipe inPipe = new Pipe("InPipe"); inPipe= new Each(inPipe, new SentFunc()); inPipe = new GroupBy(inPipe, new Fields("document"), new Fields("sentnum")); inPipe = new Every(inPipe, new TokenBuffer(), fieldDeclarationOutput); Flow flow = new LocalFlowConnector .connect("process", docTap, sinkTap, inPipe); flow.complete(); &#125;&#125; Assertion以下代码, 实现了一简单断言, 判断输入文件中Field是否为空: 123456789101112131415161718192021222324252627282930313233import cascading.flow.FlowProcess;import cascading.operation.ValueAssertion;import cascading.operation.ValueAssertionCall;import cascading.operation.assertion.BaseAssertion;import cascading.tuple.TupleEntry;public class SampleAssertion extends BaseAssertion implements ValueAssertion &#123; public SampleAssertion() &#123; super("argument '%s' failed Sample Assertion, in tuple: %s"); &#125; @Override public void doAssert(FlowProcess flowProcess, ValueAssertionCall assertionCall) &#123; TupleEntry input = assertionCall.getArguments(); int pos = 0; for(Object value : input.getTuple()) &#123; if(checkForEmptyString(value)) fail(input.getFields().get(pos), input.getTuple().print()); pos++; &#125; &#125; private boolean checkForEmptyString(Object value) &#123; if (value == null || value.toString().isEmpty()) return true; return false; &#125;&#125; 测试代码: 12345678910111213141516171819public class TestAssertion &#123; public static void main(String[] args) &#123; Scheme mainScheme = new TextDelimited( new Fields("name", "address", "phone"), true, "," ); Tap source = new FileTap(mainScheme, args[0]); Tap sink = new FileTap(mainScheme, args[1], SinkMode.REPLACE); Pipe inPipe = new Pipe("InPipe"); inPipe = new Each(inPipe, new Debug()); inPipe = new Each(inPipe, AssertionLevel.STRICT, new SampleAssertion()); Flow flow = new LocalFlowConnector() .connect(source, sink, inPipe); flow.complete(); &#125;&#125; 小结 通常, 一个管道中定义了一操作符实现某种功能特性. Operations通常可分为两类: 在单元组上执行(Each)以及分组元组上执行(Every). 缓冲器(Buffers)和聚合器(Aggregators)操作对象为一系列元组(分组元组). 元组可变, 但Operations不应修改这些元组, 须拷贝一份并传入Pipeline下一操作符中. 处理元组时, 不要修改, 否则可能会抛出异常. 当然为提高性能, 也可缓存元组. 注意复用已分配内存, 如在prepare()方法中分配、存储于上下文(Context)中、并在cleanup()方法中释放. 有时, 某些函数可能会运行俩次, 可通过重写isSafe()方法、返回false解决.]]></content>
      <categories>
        <category>Distributed System</category>
      </categories>
      <tags>
        <tag>Big Data</tag>
        <tag>Cascading</tag>
        <tag>MapReduce</tag>
        <tag>Apache Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云中漫步, Apache Phoenix索引剖析]]></title>
    <url>%2Fbigdata%2Fhbase%2Fphoenix-idx%2F</url>
    <content type="text"><![CDATA[本文将介绍Apache Phoenix二级索引相关概念及使用. 二级索引为高效访问数据, HBase表数据默认基于RowKey字典序排列并在RowKey基础上维护一特殊的索引, 以便加快数据访问. 由于HBase不支持二级索引, 有时候需要考虑替代方案, 幸运地是Phoenix支持二级索引, 可以在Phoenix表间构建多重索引, 二级索引在提升数据检索效率和提升灵活度同时, 也增加了与服务端数据同步上的复杂性. Apache Phoenix通过使用自定义协处理器于多项索引间同步数据. 对于给定查询而言, Phoenix查询计划器和优化器会选择最优查询计划, 如查询中包含索引列, Phoenix内部使用索引表重写查询来获取数据. 如果Phoenix表中存在只写或仅追加行, 可以通过设置表属性IMMUTABLE_ROWS为true(置于CREATE TABLE子句前或ALTER TABLE子句后), 减少数据在写入同时维护索引带来的Overhead; 若选择不设置该属性, 当数据变更时将在服务端维护自增索引. Phoenix支持全局索引和局部索引. 全局索引全局索引适用于读取密集型任务, 当进行Put/Delete等写入操作值数据表和索引时存在部分性能影响, HBase协处理器可以提供Hooks将预读写日志及RegionServer的不同活动及时通知它们(数据表和索引), 这些Hooks有助于写入必要数据至索引表中. 全局索引适用于如Scan类查询, 因为Phoenix会重写Query并选择最优查询计划如从索引表而非数据表获取数据. 全局索引内部构成示意图如下: 索引创建语法如下: 12345CREATE INDEX index_nameON table (expression)INCLUDE (column_refs)[ASYNC][table_options] [SPLIT ON (constant)] 如在表customer上构建索引, 参考如下: 1jdbc:phoenix:PHOENIX-N1:2181&gt; CREATE INDEX customer_state_indx ON customer (state); 开启HBase Shell, 查看索引表: 123$ hbase shellhbase(main):001:0&gt; scan 'customer_state_indx' 发现索引表RowKey格式为: {index_column} {primary_table_rowkey}. 一旦索引创建, Phoenix会将索引表与主表同步, 由于该过程同步(非异步), 可能需要等待一段时间才能查询数据. 查看索引状态, 参考指令如下: 1jdbc:phoenix:PHOENIX-N1:2181&gt; !tables customer_state_indx 索引状态, 有以下几种, 只要当索引处于ACTIVE状态时, Phoenix才可使用索引表, 否则使用主表进行查询. BUIDLING USABLE UNUSABLE ACTIVE INACTIVE DISABLE REBUILD 创建全局索引时, 注意区分Immutable表和Mutable表. 每张HBase表, 隐式而言, 属于Mutable表; 但有些表如存储时间序列数据表, 通常为仅追加、写入表, 不会频繁Update, 这种情况下, 可设置表属性(参数)IMMUTABLE_ROWS=true, 参考语句如下: 1jdbc:phoenix:PHOENIX-N1:2181&gt; ALTER TABLE ORDERS SET IMMUTABLE_ROWS = true; 由于上面将ORDERS表设置为Immutable表, 因而在查询每位顾客消费金额时将对全表扫描, 如下: 现在, 在ORDERS表上创建二级索引, 如下: 1jdbc:phoenix:PHOENIX-N1:2181&gt; CREATE INDEX CUSTOMER_ORDER_INDX ON ORDERS (CUST_ID, ORDER_ID) include (amount); 然后执行相同聚合SQL语句, 查询每位顾客消费金额, 可以看到在CUSTOMER_ORDER_INDX上执行全表扫描, 但执行效率更高, 因为跳过了客户端排序. 对于Immutable表而言, 索引维护在客户端, 即Phoenix内部基于主表和输入数据更新索引表, 写入顺序为主表然后索引表. 当然将表设置为Immutable表并不能防止表更新, 如果数据表有更新(如Update等操作), 可能会产生数据不一致状况. 对于Mutable表而言, Phoenix通过自定义RegionObservers及WAL Observers, 当主表产生Mutation(如执行Put/Delete操作)时, 会对索引表更新并写入, 在协处理器内部多线程并行写. 如果索引表写入失败, 索引更新失败, Phoenix支持以下几种故障处理策略: 可以禁用失败索引, 不在Query中使用, 故障发生后会自动重建索引, 重建成功后, 索引处于ACTIVE状态. Kill对应RegionServer, 通过该种方式重放预写日志(WAL)进行恢复. 如果写入索引表时发生故障, 可以通过回放预写日志(WAL)重试、恢复; 若写入数据表失败, 客户端需重试Mutation避免数据不一致. 局部索引局部索引基于Region, 对于本地索引而言, 主表和索引表(实际上无独立索引表)数据均位于同一Region中, 适用于写入密集型任务, 避免网络交换压力.局部索引主要组件构成, 示意图如下, 由于没有独立的索引表, 索引表元数据信息存储于系统表SYSTEM.CATALOG中. 由于局部索引存储于同一主表中不同列族, 无需独立表, 索引表数据存储于L#0列族中, Phoenix中局部索引表RowKey为: region_startkey + index_id + index_column_value + master_table_rowkey. 局部索引与RegionServer交互示意图如下: 局部索引创建指令参考如下: 12-- 在 ITEM 表上增加局部索引jdbc:phoenix:PHOENIX-N1:2181:/hbase&gt; CREATE LOCAL INDEX ITEM_SUPPLIER_LINDX ON ITEM(supplier_id); 执行上面这句SQL, 发现表中新增一列族L#0, 其中L代表局部索引而0为默认列族名, 如果在创建局部索引中包含其他列族中列, 如”cf1:c”, 可能多出几个列族如L#cf1(存储”c”列中KV值). 函数式索引函数式索引(Functional Index)提供了可以通过表达式(Expression)在表上一列或多列创建索引的能力, 在表上计算表达式同时, 会在索引表上同步生成对应UPSERT指令. 通过在数据写入时存储已计算好的Expression, 可避免部分数据读取开销, 包含该Expression的查询会重定向至索引表并获取对应数据信息. 创建函数式索引参考指令如下: 123-- 在SUPPLIER表上创建函数式索引, -- 当SELECT查询包含UPPER(SUPPLIER_NAME)这一Expression时, 会重定向至索引表而非SUPPLIER表CREATE INDEX SUPPLIER_UPPER_NAME_INDEX ON SUPPILER (UPPER(SUPPLIER_NAME)) INCLUDE (STATE) Covered Index除了在Key列创建二级索引外, 还可以包含数据表中其他列至索引中, 当所有查询中列均可从索引中获取时, 有助于提高读性能, 避免频繁地调用数据表. Covered Index创建指令参考如下: 12345-- 创建Covered Index语法CREATE INDEX INDX_NAME ON TABLE_NAME (COL1, COL2...) INCLUDE (COLX, COLY);-- 在ORDERS表上创建索引, 以CUST_ID和ORDER_ID作为Key列, AMOUNT作为包含列CREATE INDEX CUSTOMER_ORDER_INDEX ON ORDERS(CUST_ID, ORDER_ID) INCLUDE (AMOUNT); Covered Index创建, 虽然在主表和索引表上存在数据冗余问题, 但性能提升上可以抵消这种存储开销. 索引一致性 如果数据表为Immutable(IMMUTABLE_ROWS=true)、非事务表, 任何数据写入或索引表时发生的故障, 需由客户端处理(如采取重启等方式解决问题), 当数据表写入成功但索引写入失败, 索引将处于数据不一致状态. 事务表总是处于一致性状态. 对于局部索引而言, 数据和局部索引可能处于非一致性状态, 但Phoenix确保同步, 由于局部索引处于同一RegionServer, 因而整个过程非常快. 自Phoenix 4.X系列版本, 局部索引位于数据表中不同列族, HBase默认ACID语义可保证数据一致性. 若数据表为Mutable、非事务表, 当Query产生一Failure时, 数据或索引处于不一致状态, 如果数据表写入成功, 但索引写入滞后, 有以下几种参考配置可以改变这种状况: Phoenix默认允许数据表写入, 而不允许索引表. 当Phoenix开启一后台进程重建索引时, 索引表被标记为DISABLED状态, 该过程中无需显式配置, 一旦索引表与数据表同步, 索引表状态更新为ACTIVE. 数据表禁止后续写入直至索引自动重建、索引同步, 在该种情况下, 索引仍被标记为ACTIVE并接收查询, 直到与数据表同步时才接收新的写入. 当Block写入数据表、索引写入产生Failure时, 可以设置phoenix.index.failure.block.write属性;可设置phoenix.index.failure.handling.rebuild参数, 当发生故障需要重建索引时, 由于该参数默认为true, 因为Phoenix默认会在后台重建索引. 手动重建、禁止索引表写入, 适用于索引奔溃需要重建情形, 当写入索引失败时, Phoenix更新索引状态为REBUILD. 可设置phoenix.index.failure.handling.rebuild参数为false, 禁止Phoenix自动重建索引, 显式重建索引, 参考指令如下: 12-- 如果使用 ASYNC 关键字, 创建索引会开启MapReduce任务构建, 而非同步重建索引ALTER INDEX IF EXISTS INDEX_TABLE ON DATA_TABLE REBUILD [ASYNC]]]></content>
      <categories>
        <category>Distributed System</category>
      </categories>
      <tags>
        <tag>Big Data</tag>
        <tag>Apache Phoenix</tag>
        <tag>Apache HBase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cascading实战之性能优化篇]]></title>
    <url>%2Fbigdata%2Fcascading%2Ftuning%2F</url>
    <content type="text"><![CDATA[Hadoop及MapReduce性能优化, 一直是广大数据开发人员所关心的问题, 本文仅对Cascading开发提供部分性能优化建议. 如上图所示, Cascading性能调优, 粗略地可分为三部分性能优化: Cascading调优(对应图中最上面两层)、Hadoop性能优化以及底层操作系统、硬件调优. Cascading性能优化涉及代码逻辑层Data Flow构建、Pipeline和Operator设计和选型、Taps和Sehemes定制、Connectors选取等, 由于Cascading本身运行于Hadoop之上, 所以还需考虑数据分区、Reducer数量、Buffer大小设置等其它Hadoop配置调优. 本文仅对前两部分(Cascading及Hadoop调优部分)进行说明、小节. Cascading优化小节 首先尽可能并行运行Cascading应用程序. 其中会涉及到Pipeline分割, 对于并行数据输入可能产生的冗余读取问题, 可以考虑顺序化处理避免数据冗余问题. 尽可能减少处理的数据量. 通过减少一些不必要处理的数据, 从而减少一些不必要的网络I/O及磁盘I/O. 磁盘I/O源于数据持久化于Taps(包括checkpoint)、网络I/O源自运行的Reducers等. 常见参考措施如下: 明确要处理的数据量. 如输入Taps的数据集大小、数据格式、通常数据处理的Record数量等. 尽早执行过滤操作. 通常大数据处理任务按”流水线”方式处理, 尽早执行数据过滤, 可较少后续要处理的数据量, 提升整体性能. 尽早移除不相关的Fields. 如使用输入、输出Selector移除无光数据, 也可使用Retain组装(指定要保留的数据): 123Pipe main = new Pipe("main");main = new Each(main, ...);pipe = new Retain(pipe, new Fields("name", "address", "zip")); 尽可能移除冗余数据. 假如一Stream元组存在唯一主键, 可使用Unique移除冗余数据: 123Pipe pipe = new Pipe("main");pipe = new Each(pipe, ..., new CustomFunction(), new Fields("key", "value"));pipe = new Unique(pipe, new Fields("key")); 借鉴MapReduce中Combiner思想, 先在Map端聚合部分数据, 然后在Reducer端合并, 减少Reducer端输入数据量. 说简单点, 尽可能利用Cascading中Combiner技巧. 防止Join时数据倾斜.通常Join在Reducer端进行, 假如存在数据倾斜, 通常存在多个Reducer比其它Reduer处理的数据量大, 对于Hadoop任务而言, 运行最长的任务决定整体运行时间. 为防止数据倾斜, 可考虑使用Cascading Filter对倾斜的Keys值进行分割, 然后在数据子集上并行Join. Join时, 尽量使用如HashJoin等内存优化型Join. 如进行Join操作时, 可以考虑Map端Join、或MapReduce时考虑将小表放在左边以便加载至内存等. 谨慎使用CoGroup、GroupBy. 这俩Operator均运行于Reducer端, 这意味着这些Operator的Mapper将执行一Full Hadoop Job, 产生磁盘I/O、比较耗时. 谨慎评估使用这些Operator, 以便提升任务的执行效率. 合理分区. Hadoop基于数据目录读取输入数据, 合理分区, 有助于提升数据读写效率, 减少一些不必要的磁盘I/O开销. Cascading中存在几种Tap, 有助于减少I/O开销, 如GlobHfs: 123456// 假定某电商数据按时间分区, `GlobHfs`允许Unix形式"glob"读取HDFS目录中数据、或正则匹配// 本例中仅读取该电商2015年第一季度数据String inPath = "/ecomm/2015/q1/*";GlobHfs sourceGlob = new GlobHfs(sourceTextLineSchema, inPath);// `MultiSourceTap`, 作为一组合Tap, 将多项Tap高效地视为同一Tap, 通常这些Tap共享同一SchemeTap sourceTap = new MultiSourceTap(sourceGlob); Checkpoint优化. Checkpoint常用于容错, 对于常见的复杂计算、Join或涉及大量I/O开销操作, 可考虑使用Checkpoint. 当数据任务从Checkpoint重启、恢复时, 要求下游Pipeline提前感知文件格式, 如提供Taps中Fields列表给需要Checkpoint的用户等. 由于Checkpoint会序列化至磁盘, 刷写临时文件至磁盘, 推荐使用快速而高效的序列化格式进行序列化, 如使用SequenceFile等: 1234567891011121314151617import cascading.scheme.hadoop.SequenceFile;// 略去Taps、路径path等其它代码Fields checkpointFields = new Fields(...);Scheme seqScheme = new SequenceFile(checkpointFields);Tap checkpointTap = new Hfs(seqScheme, path);// 定义Pipeline, 进行数据处理Pipe pipe = new Pipe("main");Checkpoint checkpoint = new Checkpoint("checkpoint-one", pipe);// 略去Pipeline具体处理逻辑// 于下一Pipeline中添加Checkpoint, 便于容错、恢复Pipe nextPipe = new Each(checkpoint, checkpointFields, ...);FlowDef flow = new FlowDef() ... .addCheckpoint(checkpoint, checkpointTap); 合理设计Data Flow. 每次调试Cascading程序时, 注意评审生成的DOT文件, 可视化这些DOT文件, 评估生成的数据处理流程(Data Flow), 及时进行优化、提高并行度等. JVM调优. 如尽可能复用对象, 减少GC, 如在Cascading任务中调用prepare()方法将可复用对象存于Context中; 合理使用容器类型, 较少内存消耗、提升执行效率; JVM参数调优, 如初始堆、最大堆参数设置等. Hadoop优化小节 适当增加Reducer数量. Reducer数过少, 并行度低, 影响MapReduce或Cascading任务运行效率, 可适当增加Reducer数量, 提高并行度. Cascading中通常在Pipeline中设置Reducer数: 1pipe.getStepConfigDef().setProperty("mapred.reduce.tasks", 13); 合理设置Mapper数量. Mapper数量由Hadoop配置参数dfs.block.size(Hadoop 2.X系列为dfs.blocksize)大小和输入数据大小决定, 或者说Mapper数量等于输入数据大小总量除以该配置参数大小. Block大小可全局增长, 也可通过以下命令行适当增加: 1$ hadoop fs -D fs.local.block.size=&lt;size&gt; -put &lt;local_file&gt; &lt;hdfs_file&gt; 也可在Cascading程序中进行配置: 123properties.set("dfs.block.size", 256*1024*1024);// 也可在Pipeline中适当增加BlockSize大小, 以下代码设置BlockSize为256MBpipe.getStepConfigDef().setProperty("dfs.block.size", 256*1024*1024); 谨慎使用自定义Writables. Writable通常用于在Mapper与Reducer间快速而高效地进行序列化和传输, 由于自定义Writable会产生其它的Payload信息于Record, 建议谨慎使用自定义的Writable类型. 可以考虑使用Hadoop Token(信令), Hadoop Token通过替换自定义Writable中部分元数据信息(如Key中部分元数据, 后续可映射回实际Writable类型, 如保持原先长度、类型等),可以快速而高效地对自定义Writable类型进行编码. 通常Cascading中并不需要太多自定义Writable类型, 元组本身较为灵活、可嵌套, 便于组合成复杂类型, 对于Cascading而言, 除非特定业务场景, 通常无需使用自定义Writable类型. 监控和避免数据溢出. 当内存Buffer满了(通常会清空并刷写至磁盘为其它输入数据预留存储空间), 可能会发生数据溢出. 通常, Hadoop中数据溢出发生于Mapper端和Reducer端: Mapper端当数据累积准备发送至Reducer端时; Reducer端当数据达到并在聚合前进行排序时. 可以参考以下日志, 判定数据是否溢出: 12345678910111213141516171819202122232425262716:44:01 INFO input.FileInputFormat: Total input paths to process : 216:44:01 INFO mapred.JobClient: Running job: job_201510112103_000116:44:08 INFO mapred.JobClient: map 0% reduce 0%16:44:18 INFO mapred.JobClient: map 40% reduce 10%16:44:27 INFO mapred.JobClient: map 60% reduce 20%16:44:34 INFO mapred.JobClient: map 80% reduce 30%16:44:40 INFO mapred.JobClient: map 100% reduce 70%16:44:44 INFO mapred.JobClient: map 100% reduce 100%16:44:46 INFO mapred.JobClient: Job complete: job_201412332103_000116:44:46 INFO mapred.JobClient: Counters: 1716:44:46 INFO mapred.JobClient: Job Counters16:44:46 INFO mapred.JobClient: Launched reduce tasks=416:44:46 INFO mapred.JobClient: Launched map tasks=416:44:46 INFO mapred.JobClient: Data-local map tasks=4…16:44:47 INFO mapred.JobClient: FileSystemCounters16:44:47 INFO mapred.JobClient: FILE_BYTES_READ=89412000016:44:47 INFO mapred.JobClient: HDFS_BYTES_READ=37206000016:44:47 INFO mapred.JobClient: FILE_BYTES_WRITTEN=37390000016:44:47 INFO mapred.JobClient: HDFS_BYTES_WRITTEN=164756000016:44:47 INFO mapred.JobClient: Map-Reduce Framework…16:44:47 INFO mapred.JobClient: Map input records=150124…16:44:47 INFO mapred.JobClient: Reduce output records=9123516:44:47 INFO mapred.JobClient: Spilled Records=1803… 日志中表明存在1803项Records在排序阶段、Reduer阶段运行前溢出至磁盘. 以下两项配置, 与数据溢出相关: io.sort.mb(Hadoop 2.X系列为mapreduce.task.io.sort.mb): 排序时分配的Buffer大小 io.sort.spill.percent(Hadoop 2.X系列为mapreduce.task.io.sort.spill.percent): 当达到一定比例(默认75%)Buffer大小时发生溢出 如果JVM 内存参数设置够大、合理, 可以有效避免或较少数据溢出, 从而提升Cascading或MapReduce任务执行效率. 尽可能使用压缩. 对数据进行压缩, 可大大较少磁盘存储开销及I/O开销, 当然缺点在于增加了CPU计算开销. 如果Hadoop生产集群CPU计算能力强(适用于计算密集型作业), 采用数据压缩带来的这点CPU开销可以忽略. 由于Hadoop将数据Split至Data Blocks中, 建议使用可以切割(Splittable, 可并行读取)的数据压缩格式, 如bzip2、LZO等, 提高性能. 如果采用不可分割的数据压缩格式, 该数据将作为一个整体从头到尾读取, Hadoop将整块数据提交至Mapper或Reducer处理, 运行效率低. 选择合适的数据存储格式. 通常你会选择使用文本格式(如CSV、TSV、JSON等)对数据进行存储, 但文本格式数据比较耗存储, 相对于Avro、Protobuf、Thrift、SequenceFile、ORC、Parquet等Binary格式数据读写效率低. 这些Binary格式数据, 可以快速而高效地进行序列化和反序列化, 请结合具体业务逻辑选取合适的数据存储格式. 适当增加副本数量(或提高复制因子). 假如某些业务场景数据非常重要, 为保证高可用, 可能保存多份数据副本: 12$ # 假如集群中存在20个DataNode, 以下指令能保证每个节点下具有一份/data/ecomm/crucialdata数据副本$ hadoop fs -setrep -R -w 20 /data/ecomm/crucialdata JVM复用. Hadoop每次运行一Mapper或Reducer时, 将开启一JVM进程. 这些JVM实例存在初始化开销, 可通过以下设置减少JVM初始化时间(重置JVM而非结束或重启)、多次复用JVM: &lt;property&gt; &lt;!-- Hadoop 2.X系列对应配置参数为 mapreduce.job.jvm.numtasks --&gt; &lt;name&gt;mapred.job.reuse.jvm.num.tasks&lt;/name&gt; &lt;value&gt;-1&lt;/value&gt; &lt;/property&gt; 适当增加内存. 对于一些比较耗时的聚合计算(如AggregateBy等), 可以考虑适当增加Buffer大小; 对于一些常见的In-Memory Join, 也可适当增加内存, 提高执行效率. 利用监测与调优工具. 如Concurrent Driven产品, 有助于对Cascading和Hadoop任务进行诊断检测以及性能调优.]]></content>
      <categories>
        <category>Distributed System</category>
      </categories>
      <tags>
        <tag>Big Data</tag>
        <tag>Cascading</tag>
        <tag>MapReduce</tag>
        <tag>Apache Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云中漫步, 邂逅Apache Phoenix]]></title>
    <url>%2Fbigdata%2Fhbase%2Fphoenix-intro%2F</url>
    <content type="text"><![CDATA[Apache Phoenix由Salesforce.com开源, 于2014年5月成为Apache顶级项目, Phoenix最初作为Salesforce内部项目主要为HBase等大数据组件提供支持易用性、High Level级别的SQL支持. Apache Phoenix充分利用HBase作为存储数据库, 支持低延迟OLTP处理分析, 便于与Hadoop其它生态组件集成, 如Hive、Pig、Spark、Flume等. Apache Phoenix支持标准SQL及JDBC API, 支持完整ACID(原子性、一致性、隔离性及持续性)语义, 也兼容如Schema读取、延迟绑定等NoSQL数据库特性. SQL ON HBASE Apache Phoenix架构示意图如下, Phoenix提供C/S服务, 服务端使用自定义HBase协处理器处理索引、Join、事务、Schema及元数据管理, 服务端拥有自定义Observer和Endpoint协处理器支持这些特性; 客户端拥有解释器、关系型代数及查询计划组件用于解析给定SQL语句并基于代价(Cost-based)优化模型选择最佳优化计划, 然后执行并内部转化为SCAN、PUT、DELETE等HBase操作. 其中服务端返回的数据结果被映射为Java中的ResultSets. Apache Phoenix与HBase通信示意图如下: Apache Phoenix与其它SQL on Hadoop组件比较如下: Phoenix主要特点 支持事务 Apache Phoenix支持事务, 支持所有事务级别的ACID语义. 通过Apache Tephra支持HBase行级别事务语义, Tephra通过多版本并发控制实现提供并发事务间快照隔离. 支持二级索引 二级索引不同于主索引, 其值可能存在冗余, 通常对访问频繁、主索引排序困难的大表建二级索引. HBase不支持二级索引, 行键有序、其访问模式也是基于行键, Phoenix支持二级索引, 可以大大提高数据检索效率, 减少对HBase表全局扫描. 支持自定义函数(UDF) Phoenix支持自定义函数(UDF), 自定义函数可以是临时函数也可以是持久化函数, 自定义临时函数适应于特定用户连接、对于其它用户连接不可访问; 自定义持久化函数对应元数据信息存储于系统表中(如SYSTEM.FUNCTION等); Phoenix也支持租户特定函数, 此类函数存在于特定租户会话或连接中, 其它租户不可访问. 支持视图 Phoenix支持标注SQL中视图语法, 视图支持这一特征对于HBase表很关键, 可以通过视图方式创建多张虚拟表复用底层同一张物理表数据. 多租户 Apache Phoenix支持多租户场景, 可以通过特定租户配置属性创建表, 该特定租户在连接时注入租户ID, 建立连接后便可访问租户数据. 虽然租户可以看到普通表中所有数据, 但只能看到多租户表中自身表数据. Query Server Phoenix Query Server支持其它Java客户端, 通过自带的独立Server暴露一Thin Client, Thin Client通过使用JSON与Phoenix查询服务器(Phoenix Query Server, 简称PQS)交互, PQS作为一HTTP服务支持JSON和Protocol Buffer, PQS默认使用Protocol Buffer(比JSON使用更加高效), Thin Client底层由Apache Calcite’s Avatica组件实现. Skip Scan Skip Scan通过使用组合多列索引查找唯一值, Skip Scan适用于Range查询或基于给定一系列Key值全局扫描, Skip Scan充分利用HBase过滤器中的SEEK_NEXT_USING_HINT枚举, 基于过滤器给定提示(Hint)指定下一个需要Seek的键, 并存储每列中需要查找的一系列Key值详细信息, 每次传入一Key, 会判断是否在组合中, 若不在, 继续迭代下一Key值. 支持数据类型Phoenix提供一系列数据类型, 支持原始类型和复杂类型, 每种数据类型内部映射成Java或SQL对应类型, 对于数值类型和时间类型的Unsigned(无符号)版本仅支持正值. 有时候需要考虑无符号时间类型数据, 如数据值被org.apache.hadoop.hbase.utils.Bytes序列化时. Phoenix数据类型映射关系如下: Data Type Java Mapping 备注 TINYINT java.lang.Byte SMALLINT java.lang.Short INTEGER java.lang.Integer BIGINT java.lang.BigInteger FLOAT java.lang.Float DOUBLE java.lang.Double BOOLEAN java.lang.Boolean True/False, 内部映射成0/1 DECIMAL java.math.BigDecimal 可以指定精度并拓展 VARCHAR java.lang.String 可变长度, 内部映射成UTF-8 CHAR java.lang.String 固定长度, 内部映射成UTF-8 BINARY byte[] 固定长度字节数组 VARBINARY byte[] 可变长度字节数组 TIME java.sql.Time 默认格式 yyyy-MM-dd hh:mm:ss, 内部表示为基于GMT的Epoch(单位为ms) ARRAY java.sql.Array 除了VARBINARY其它原始类型均可声明为单纬数组 原始数据类型HBase中所有数据均被存储为Bytes, 与HBase相反, Phoenix提供了一自定义DataType映射为java.sql.Types中定义的不同类型. 每种数据类型均有编码器和解码器在Raw Bytes和Java原始类型间转化, Phoenix支持的原始数据类型有: boolean、char、varchar、decimal、int、short、long、float、double、date等时间类型. 对于每种数值类型均有对应的Unsigned(无符号)版本处理原始类型值. 复杂数据类型与其它NoSQL数据库支持复杂数据类型如结构体Struct、Array、Map等不同, Phoenix目前仅支持Array类型. CRUDApache Phoenix中每张数据表至少包含一个列族, Phoenix作为HBase的SQL层引擎, 和多数列式数据库一样, 在数据建模方面需注意”Query First”, 基于查询访问模式梳理Schema. 在建表时注意反模式的运用, 因为如果和关系型数据库一样正常建表、表间Join开销大. 当Apache Phoenix执行UPSERT语句(UPDATE/INSERT, 与Cassandra中UPSERT语句类似), Phoenix解析对应SQL语句并转化为HBase Put操作, 当Region Server接收到请求后, 首先写入预写日志(WAL)及Memstore(写入预读写日志为保证数据持续性), 只有数据写入WAL和Memstore后才视为写入完成. 当Phoenix执行SELECT语句时, 首先通过解析器解析, 然后准备一系列查询计划并综合多种考虑因素(如表索引、代价模型等)从中选出最优计划, 由一系列HBase Scan操作物化, 通过线程池ExecutorService并行执行, 最终在客户端聚合结果. 命令行CRUD可以通过安装包中的sqlline.py脚本启动Apache Phoenix命令行终端, 如下: 1$ python sqlline.py PHOENIX-N1:2181:/hbase Phoenix CRUD操作, 示例如下, 注意user表中, id为主键, 列first_name和last_name被映射为列族d中列, 如果没有指定列族, 数据列内部默认映射为列族0中列, 建表时可以通过定义DDL属性 DEFAULT_COLUMN_FAMILY=your_column_family_name 覆写默认列族. 12345678910111213141516171819-- CREATEjdbc:phoenix:PHOENIX-N1:2181:/hbase&gt; CREATE TABLE user( id INTEGER NOT NULL PRIMARY KEY, d.first_name VARCHAR, d.last_name VARCHAR);-- UPSERT, 以下SQL将转化成HBase Put操作jdbc:phoenix:PHOENIX-N1:2181:/hbase&gt; UPSERT INTO user VALUES(1, 'Emma', 'Roberts');jdbc:phoenix:PHOENIX-N1:2181:/hbase&gt; UPSERT INTO user VALUES(2, 'Bella', 'Thorne');-- DELETEjdbc:phoenix:PHOENIX-N1:2181:/hbase&gt; DELETE FROM user WHERE id=2;-- ALTERjdbc:phoenix:PHOENIX-N1:2181:/hbase&gt; ALTER TABLE user ADD salary DECIMAL;-- SELECTjdbc:phoenix:PHOENIX-N1:2181:/hbase&gt; SELECT * FROM user; Java代码CRUDApache Phoenix, Java代码CRUD参考如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class PhoenixJdbc &#123; public static void main(String[] args) &#123; Connection connection = null; Statement statement = null; ResultSet rs = null; PreparedStatement ps = null; try &#123; Class.forName("org.apache.phoenix.jdbc.PhoenixDriver"); connection = DriverManager.getConnection("jdbc:phoenix:PHOENIX-N1:2181:/hbase"); System.out.println("Connection established...."); statement = connection.createStatement(); statement.executeUpdate( "create table user (id INTEGER NOT NULL PRIMARY KEY, d.first_name VARCHAR,d.last_name VARCHAR)"); statement.executeUpdate("upsert into user values (1,'Emma','Roberts')"); statement.executeUpdate("upsert into user values (2,'Bella','Thorne')"); connection.commit(); ps = connection.prepareStatement("select * from user"); rs = ps.executeQuery(); System.out.println("Table Values"); while (rs.next()) &#123; Integer id = rs.getInt(1); String name = rs.getString(2); System.out.println("\tRow: " + id + " = " + name); &#125; &#125; catch (SQLException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if (ps != null) &#123; try &#123; ps.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; if (statement != null) &#123; try &#123; statement.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; if (connection != null) &#123; try &#123; connection.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Distributed System</category>
      </categories>
      <tags>
        <tag>Big Data</tag>
        <tag>Apache Phoenix</tag>
        <tag>Apache HBase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cascading实战之基本概念篇]]></title>
    <url>%2Fbigdata%2Fcascading%2Fbasic%2F</url>
    <content type="text"><![CDATA[本文将介绍Cascading基本概念. Data FlowCascading数据处理模型基于Data Stream与数据操作(如过滤、聚合、断言、函数处理等), Cascading API允许开发者组装管道子组件(SubAssembly, 如Stream分割、分组、合并及Join等)定义数据处理流(Data Flow). 下面以酿酒流程为例, 处理流程示意如下, 首先对酿造原料进行发酵, 对发酵酒精进行过滤, 经过多道工艺(如增加调料、改进口感等)处理, 最后得到醇香可口的佳酿. 对应Cascading代码, 参考如下: 1234567891011121314151617Scheme liquidFlowScheme = new TextDelimited(new Fields("liquid"), true, ",");String sourceContainerLocation = "The Path To Source Container";Tap sourceContainer = new FileTap(liquidFlowScheme, sourceContainerLocation);Scheme drinkScheme = new TextDelimited(new Fields("drink"), true, ",");String sinkContainerLocation = "The Path To Sink Container";Tap sinkContainer = new FileTap(drinkScheme, sinkContainerLocation);Pipe pipe = new Each(pipe, new Filter());Pipe topPipe = new Each(pipe, new AddFlaver1());Pipe midPipe1 = new Each(pipe, new AddFlaver2());Pipe midPipe2 = new Each(pipe, new AddFlaver3());Pipe bottomPipe = new Each(pipe, new AddFlaver4());Pipe outPipe = new Merge(topPipe, midPipe1, midPipe2, bottomPipe);Flow flow = new LocalFlowConnector().connect(sourceContainer, sinkContainer, outPipe);flow.complete(); Cascading本身利用高级API模拟待处理的Data Flow, 无需过多暴露底层处理复杂性(如MapReduce实现等). 在详细介绍Cascading前, 需了解以下几个概念: Tuple, 元组, 即Data Record, Cascading将所有待处理数据视为元组, 与MapReduce、Spark中RDD(当然有些特殊的RDD除外, RDD本身的KV键值对通常以元组形式出现)数据处理类似 Pipe, 执行数据操作的数据流, 通常这些数据操作包括如数据过滤、聚合、转换、计算及汇总等 Pipe Assembly, 管道子组件, 常用于连接管道分支 Tap, Data Source(数据源)或Data Sink(通常指结果数据持久化的地方, 可以是文件系统, 也可为数据库), Taps须与管道子组件绑定, 如Data Source Tap常作为管道输入数据, Data Sink Tap作为管道结果输出数据 Flow, 包含Tap与管道子组件的系统, 通常多项数据集于Flow中计算、转换并输出 Cascade, 一系列Flow, 如果某项Flow依赖其它Flow输出, 该Flow并不会立即执行, 需待条件满足后执行 Record抽象本节将介绍Cascading中Record相关抽象, 即Cascading处理数据流基本数据结构与Schema. Tuple元组, 本身比较常见, 可以通过偏移(即下标)和名称(如Named Tuple)进行访问, 元组本身可以允许不同数据类型. 元组有些类似于数据库中Record概念, 如每列可以基于序数位置访问. 由于Java语言本身并不支持元组(Scala与Python等语言对元组支持已嵌入语言级别), 需要通过对象封装或以类的形式实现, Cascading中元组常见方法参考如下: 1234567891011121314// 如创建一元组result, 该元组对象Size为3// Tuple result = Tuple.size(3)public static Tuple size(int size);// 通过下标位置访问元组中元素// 如 tuple.getObject(0) 访问元组中第一项Field(对应Record中第一列)public Object getObject(int pos);// 基于下标访问元组中元素public boolean getBoolean(int pos);public String getString(int pos);public float getFloat(int pos);public double getDouble(int pos);public int getInteger(int pos); Fields可以通过Fields访问元组中元素, Fields存储了Field元数据(如名称、类型、类型变换、比较器等), Fields代表了元组中成员名或充当元组的Selector引用元组中元素值. 一Fields实例可能包含了一系列Field名与位置(元组下标)信息, Field值也可为Comparable以便进行排序. 实例化Fields比较简单, 代码参考如下: 1Fields fields = new Fields("id", "ssn", "gender", "name"); Fields可充当元组元数据, 便于控制和Map待处理数据. Fields既可充当声明器也可充当选择器, 声明器声明特定类型或特定值Field, 选择器用于选取元组中给定引用Field. Cascading中存在一Field Sets概念, 用于控制元组传入或处理, 参考如下: cascading.tuple.Fields.ALL, 代表当前所有可用的Field cascading.tuple.Fields.UNKNOWN, 声明Field时并不知晓Field名称或数量, 是用于处理任意长度元组中Field声明 cascading.tuple.Fields.ARGS, 适用于Fields作为输入参数执行某些Operation cascading.tuple.Fields.RESULT, 适用于Fields作为某些Operation输出结果而选用时 cascading.tuple.Fields.GROUP, 适用于对Fields进行分组(如进行GroupBy)时 Feilds也支持类型转换, 如将字符串类型的timestamp字段转换成Long类型, 代码参考如下: 12345// Cascading通过`cascading.tuple.coerce.Coerce`进行类型转换pipe = new Coerce(new Fields("timestamp"), Long.class);// 或者也可通过Field声明时指定类型, 如下Fields field = new Fields("id", Long.class); TupleEntryTupleEntry适用于需要将Field元数据封装至元组中. 当TupleEntry创建后其Fields不可变更, 但其Tuple实例可以修改或替换, 元组中元素不可增加或移除(原因在于TupleEntry内部存储了一Map&lt;String, Integer&gt;, 该Map与Fields实例相关). TupleEntry允许通过Field名访问元组, TupleEntry中Fields形成元组的元数据(如定义了列名及数据类型等)并充当元组的Selector. TupleEntry使用, 参考代码如下: 123Fields selector = new Fields("id", "ssn");Tuple tuple = Tuple.size(2);TupleEntry tupleEntry = new TupleEntry(selector, tuple); SchemeScheme不仅可用于读取数据, 也可用于解析和转换数据, 换句话说, Scheme适用于Data Source和Data Sink数据定义. Cascading中存在以下几种预定义Scheme: TextLine, 可按行分割(换行符通常为CR, CR LF, NL) TextDelimited, 文本可按分割符分割, 如CSV或TSV文件, 可跳过Header, SequnceFile, Hadoop SequnceFile, binary形式KV键值对 NullScheme, 当需要Scheme时充当占位符, 需要时可作为Scheme参数 Cascading中较为常见的Scheme有TextLine, TextLine存在以下构造器: 123456// 如果`sourceFields`仅有一项Field, 仅返回随后元组的文本行public TextLine(Fields sourceFields) &#123; /* 构造器实现略 */&#125;;public TextLine(Fields sourceFields, Fields sinkFields) &#123; /* 构造器实现略 */&#125;;// `charsetName`, 字符集, 支持字符集为: UTF-8、UTF-16BE、UTF-16LE、UTF-16、ISO-8859-1、US-ASCII等public TextLine(Fields sourceFields, Fields sinkFields, String charsetName) &#123; /* 构造器实现略 */&#125;; TextDelimited, 对应Scheme可按分隔符分割, 如CSV或TSV等, 这些Scheme也支持跳过Header, TextDelimited类为TextLine子类. TextDelimited默认并不会写入Header, 如果构造器中指定hasHeader为true, skipHeader与writeHeader也将设置为true. TextDelimited也支持写入Header至文件中, Header中Field名称直接取自Field声明, 如果Fields声明为Fields.ALL或Fields.UNKNOWN, 将直接使用Field声明中Field名作为Header中Field名称. TextDelimited构造器, 参考如下: 12345678public TextDelimited(boolean hasHeader, String delimiter) &#123; /* 构造器实现略 */&#125;;public TextDelimited(boolean hasHeader, String delimiter, String quote) &#123; /* 构造器实现略 */&#125;;public TextDelimited(Fields fields) &#123; /* 构造器实现略 */&#125;;public TextDelimited(Fields fields, boolean skipHeader, boolean writeHeader, String delimiter) &#123; /* 构造器实现略 */&#125;;public TextDelimited(Fields fields, boolean skipHeader, boolean writeHeader, String delimiter, String quote) &#123; /* 构造器实现略 */&#125;; TextDelimited使用, 示例代码如下: 12345// 没有Header, 默认按TAB分割Scheme scheme = new TextDelimited();// 有Header, 按逗号分割(即CSV文件)Scheme scheme = new TextDelimited(true, ","); SequenceFile, Hadoop序列化文件, 包含Binary形式KV键值对, 可进行高效读写. SequenceFile构造器, 参考如下: 1public SequenceFile(Fields fields) &#123; /* 构造器实现略 */ &#125;; WritableSequenceFile为SequenceFile子类, 可用于读写Hadoop Writable对象, 写时将KV键值对序列化至Sequence File, 读时KV键值对封装至Cascading元组并传入管道子组件(Pipe SubAssembly)中. WritableSequenceFile构造器, 参考如下: 123456public WritableSequenceFile(Fields fields, Class&lt;? extends Writable&gt; valueType) &#123; /* 构造器实现略 */ &#125;;public WritableSequenceFile(Fields fields, Class&lt;? extends Writable&gt; keyType, Class&lt;? extends Writable&gt; valueType) &#123; /* 构造器实现略 */ &#125;; WritableSequenceFile使用, 示例代码如下: 12345Tap tapValue = new Hfs(new WritableSequenceFile( new Fields("sink_text"), Text.class), getOutputPath("value"), SinkMode.REPLACE); 元组也可通过Scheme描述, Scheme包含了Field定义, 如People的Scheme包含姓名、年龄、性别、联系方式、地址等, 代码参考如下: 1Scheme peopleScheme = new TextLine(new Fields("name", "gender", "age", "phone_number", "address")); 也可通过Fields与Types数组形式组合Scheme, 代码参考如下: 12345Fields[] pFields = new Fields[] &#123;new Fields("name"), new Fields("gender"), new Fields("age"), new Fields("phone_number"), new Fields("address")&#125;;Type[] pType = new Type[] &#123;String.class, String.class, Integer.class, Long.class, String.class&#125;;// 注意Field名与类型对应Scheme pScheme = new TextLine(new Fields(pFields, pType)); 也可通过Fluent接口形式指定Fields中某项成员类型, 如: 123456Fields pFields = new Fields("name", "gender", "age", "phone_number", "address");pFields.applyType("name", String.class) .applyType("gender", String.class) .applyType("age", Integer.class) .applyType("phone_number", Long.class) .applyType("address", String.class); 数据流控本节主要介绍Cascading数据流处理相关概念, 如Flow、Pipe、Cascade等, Cascading主要通过定义Pipe、Flow或Cascade控制整个Data Flow处理流程. Tap在管道组件(Pipe Assembly)执行前, 需与Tap进行绑定, 即Data Source与Data Sink, Tap主要用途如下: Source Tap提供数据用于下游消费 Sink Tap用于持久化数据 Tap即可充当Source也可充当Sink Cascading中存在以下几种Tap类型: Hfs, 该Tap可访问Hadoop File(文件URL通常为 hdfs:///path/to/your/data) Lfs, Hfs子类, 可访问本地文件, 这些文件通常存储于Hadoop集群中, 但可通过本地文件名访问而非HDFS名 Dfs, Hfs子类, 可访问HDFS文件, 但通常使用Hfs FileTap, 访问本地文件而非Hadoop集群文件 Tap使用, 示例代码如下: 12345Scheme sourceScheme = new TextLine(new Fields("text_field"));Scheme sinkScheme = new TextLine(new Fields("dep", "stats"));String inputPath = "Input Path Here";Tap source = new HfS(sourceScheme, inputPath);Tap sink = new Hfs(sinkScheme, SinkMode.REPLACE); 其中SinkMode可用于处理输出数据, 如防止覆写等, SinkMode存在以下几种选项: KEEP, 如果文件存在写入失败 REPLACE, 替换文件 (Hadoop模式下先删除整个路径然后重建目录并重新分配文件) UPDATE, 如果文件系统允许(Hadoop模式下不允许UPDATE, 主要在于HDFS文件为Immutable, 可追加写入但不可修改), 可复用文件 Pipe数据通过管道传输,转换和计算, Pipe可用于执行数据转换、Join、分组、合并、分割等计算, 基于数据操作, Cascading中管道可分为以下几种: Cascading中Operation类型可以粗略地分为以下几类: Filter, 对数据进行过滤 Function, 执行特定数据转换或计算方法 Aggregator, 对数据集进行聚合、汇总 Buffer, 在一定数量的数据集执行数据计算 Assertion, 断言, Assertion适用于单元组Pipe(如Each)和分组元组Pipe(如Every)等. EachEach管道常用于处理单元组, Each主要包括Filter与Function. Each示例代码参考如下: 12// 基于正则过滤inPipe = new Each(inPipe, new RegexFilter("ECOMM")); EveryEvery管道, 执行于一组元组之上(非单元组), 通常这些分组由GroupBy管道确定(GroupBy或CoGroup管道均可产生Every Pipe). 这些分组元组可以一次处理一项(Aggregator)或一次性处理所有(Buffer). Every示例代码参考如下: 123// 对分组元组进行计数inPipe = new GroupBy(inPipe, new Fields("group"));inPipe = new Every(inPipe, Fields.ALL, new Count(new Fields("TotalRecords")), Fields.ALL); 分组与排序GroupBy常用于分组, 也可用于二级排序(除非特别指定, 否则默认不会开启二级排序). 如图所示, 假定薪资数据数据源(部门,姓名,薪资,涨幅)如下所示, 需以部门分组, 薪资排序, 代码参考如下: 123456Pipe payroll = new Each("payroll", new Fields("division", "name", "salary", "raise"), new Identity());Fields groupFields = new Fields("division");Fields sortFields = new Fields("salary");Pipe assembly = new GroupBy(payroll, groupFields, sortFields); Join与MergeMerge可用于Pipe合并, 如图所示, 人力资源数据处理中存在两Pipe, 其中一Pipe负责读取库内现有数据(暂未更新), 另一Pipe读取更新后的数据, 现在需要合并两Pipe, 代码参考如下: 12345678Pipe lhs = new Each("hrdata", new Fields("name", "address", "phone"), new Identity());Pipe rhs = new Each("hrdata_update", new Fields("name", "address", "phone"), new Identity());// Merge PipePipe merge = new Merge(lhs, rhs); Cascading中Join Pipe包括CoGroup与HashJoin. CoGroup对输入元组按照给定Key(可能为一项也可能为多项)分组, 然后按照分组Key执行Join或聚合, 有些类似于SQL中JOIN. 接着以上面的人力资源数据与薪资为例, 以Name字段作为连接键进行Join, 示意图如下: 代码参考如下: 1234567891011Pipe lhs = new Each("hrdata", new Fields("name", "address", "phone"), new Identity());Pipe rhs = new Each("payroll", new Fields("name", "division", "salary"), new Identity());Fields joinKey = New Fields("name");// 需对薪资数据中Name字段重命名, 否则会造成冲突导致程序报错无法运行Fields resultFields = new Fields("name", "address", "phone", "name2", "division", "salary");Pipe join = new CoGroup(lhs, joinKey, rhs, joinKey, resultFields); HashJooin作为一高度优化的Join, 将右边Stream加载至内存(如果满足条件, 性能比CoGroup要好, 原因在于如果整项数据集能加载至内存, HashJoin将变成Map端Join), 如果该Stream数据量过大可能会溢出部分数据至磁盘并产生内存错误. 同样以上面的数据为例, 假如薪资数据集可以加载至内存, 此时可以考虑使用HashJoin, 示意图如下: 代码参考如下: 123456789101112131415161718Pipe lhs = new Each("hrdata", new Fields("name", "address", "phone"), new Identity());Pipe rhs = new Each("payroll", new Fields("name", "division", "salary"), new Identity());Fields joinKey = New Fields("name");Fields resultFields = new Fields("name", "address", "phone", "name2", "division", "salary");Pipe join = new HashJoin(lhs, joinKey, lhs, joinKey, resultFields);// 也可设置Spill参数SpillableProps props = SpillableProps.spillableProps() .setCompressSpill(true) .setMapSpillThreshold(50 * 1000);props.setProperties(join.getConfigDef(), ConfigDef.Mode.REPLACE); Flow将一项或多项管道组件与Taps进行绑定, 可构成一Flow, Flow可编译为一项或多项MapReduce任务(或Tez、Apache Flink Task, 取决于后端计算引擎). Flow可视为执行于Pipe元组数据流的一系列数据操作(执行用户定义的数据处理流程). 一Flow可有多项输入输出, 每项Tap也可接收或产生一系列元组. Flow也可用于创建执行图(Execution Graph), Execution Graph通常为一系列处理器(Processor, 即与Operations绑定的管道Pipe)和连接组合, 代表着数据传输和转发流, Exection Graph通常为有向无环图(DAG, Directed Acyclic Graph), 即两个Pipe间数据流为单向(不可形成环), 整个Graph也不可形成环, 示意图如下: FlowConnectorFlowConnector将Cascading执行图(Execution Graph)转化为可执行的Job, Cascading中主要存在以下几种类型的FlowConnector: LocalFlowConnector HadoopFlowConnector Hadoop2TezFlowConnector FlowConnector使用, 示例代码如下: 12345FlowConnector flowConnector = new FlowConnector();FlowDef flowDef = FlowDef.flowDef() .addSource(inPipe, srcTap) .addTailSink(inPipe, sinkTap)flowConnector.connect(flowDef).complete(); FlowConnector使用特定的FlowPlanner构建执行图(Execution Graph), 该FlowPlanner可用于向底层运行框架如Hadoop或Tez等发出请求并执行Flow. Flow可复用代码, 也可与现有的MapReduce任务进行交互, 如封装已运行的MapReduce任务于Flow中, 构建复杂的Data Flow, 编写端到端的数据应用等. CascadeCascading中一Cascade可连接一系列Flow, 允许多项Flow作为一逻辑单元执行. 当单个Flow变得过大时, 可以考虑拆分为多项Flow, 以便提高代码可读性与模块化, 这些拆分的Flow可以通过Cascade进行连接. 一项简单的Cascade示意图如下: 参考代码如下: 12345678// flowOne与flowTwo具体实现略, // 其中flowOne输出为flowTwo输入Flow flowOne = ...Flow flowTwo = ...Cascade cascade = new CascadeConnector() .connect(flowOne, flowTwo);cascade.complete();]]></content>
      <categories>
        <category>Distributed System</category>
      </categories>
      <tags>
        <tag>Big Data</tag>
        <tag>Cascading</tag>
        <tag>MapReduce</tag>
        <tag>Apache Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Query Engine大作战 -- Apache Drill之基本概念篇]]></title>
    <url>%2Fbigdata%2Fdrill%2Fintro%2F</url>
    <content type="text"><![CDATA[本文将介绍Apache Drill相关概念, 如Drill基本组成, 架构等. Apache Drill, 作为一低时延查询引擎, 非常适合交互式查询, 支持集成BI工具如Tableau等. 大数据生态组件中, Apache Impala, Hive LLAP以及Presto也适合交互式查询, 运行效率远超Hive/Pig, 尽管Impala很快, 但由于Impala采用C++开发, 部署和构建, 相对于其它组件, 并非易事. Drill支持多种文件格式, 采用Java开发, 适合广大Java开发人员, 与其它查询引擎不同, Apache Drill不仅可以读取HDFS上数据, 还可以读取其它存储系统文件, 如Amazon S3, Kafka, MapR-FS等. Apache Drill与Impala, Presto组件不同之处在于, Drill在查询数据前, 并不要求开发人员定义元数据. 尽管Drill也可使用Hive元数据, 但Drill可直接查询数据文件, 无需指定元数据, 等待元数据刷新. 查询非存储需要注意的是Drill并非数据库, Drill作为一低延时查询引擎, 本身并不提供存储服务. Drill支持多种外部存储系统, 如HDFS, Amazon S3, MapR-FS等, 并不限制用户存储选型(如非得使用HDFS作为数据源等). Drill视数据文件为Table, 由于文件是顺序化扫描, 因而Drill不支持索引, 不存在CREATE INDEX子句, 与多数大数据查询引擎类似, 通常这些查询引擎使用分区代替索引, 以便快速地对数据进行定位查找. 由于HDFS中新增文件是Immutable类型(仅追加写入, UPDATE之类的更新较少), Drill并不支持INSERT, UPDATE, DELETE等操作. 每项文件均有自身的Schema, Drill也称Shema-Free或Schema-On-Read式查询引擎, Drill没有创建表、列或索引Schema的DDL(数据定义语言, Data Definition Language). 结合以上几点, Apache Drill仅为一大数据查询引擎, 适合对多种异构数据, 不同存储系统数据进行查询, 不适合存储也不提供存储. Drill拓扑术语Apache Drill相关拓扑(或Data Flow)术语对应速查表如下: Drill 对应MapReduce 对应Spark Query Job Job Major Fragment Map 或 Reduce Stage Minor Fragment Mapper, Reducer Stage Operator N/A Task Exchange Shuffle Shuffle Drill架构Drill主要包含以下四个组件: Drill客户端, Drill客户端连接Foreman, 提交SQL语句, 并接收Query最终执行结果 Foreman, Drill Server, 用于维护用户会话状态, 处理查询. Drill客户端连上Drill后, 会随机连接一个Drillbit作为Foreman Worker Drillbit, 实际执行Query组件 Zookeeper Server, 对Drill集群中的Drillbit进行协调 如上图所示, Drill运行于数据节点, Drill通过HDFS客户端API从HDFS上读取数据, 由于Drillbit与数据位于同一节点, 读为本地读(同一节点同一Rack), Drill使用Zookeeper进行协同, 每项Drillbit向Zookeeper进行注册, 以便被其它Drillbit以及Drill客户端发现. Drill也可通过Zookeeper进行配置(如存储及数据格式配置等)以及准入控制等. 可以通过Drill客户端(如JDBC/ODBC接口, 命令行等)或BI工具(如Tableau), 连接Drill, 客户端通过连接Zookeeper获取Drillbit运行状况, 然后随机连接一个Drillbit(即Foreman), 执行对应Query. 小结下Drill执行Query的处理流程: 首先, 通过Drill客户端连接Drill集群(不同数据节点的Drillbit通过Zookeeper协同), 然后通过Zookeeper定位Drillbit, 随机连上一个Drillbit充当Foreman, 通过Foreman解析SQL, 然后分发Work至其他Woker Drillbit (等效于MapReduce中Map阶段) Drillbit从文件系统读取数据, 执行Query处理, 处理完后发送结果至Foreman, Foreman进行结果归并 (等效于MapReduce中Reduce阶段) Foreman返回结果至Drill客户端 低时延特性Apache Drill作为一低时延的查询引擎, 主要存在以下三种机制减少时延. 代码生成通常, 多数大数据组件如Spark或Hadoop会分发应用代码至各节点运行, 如MapReduce分发应用代码至每项Mapper或Reducer, 而Spark中每项应用拥有独立的一组Executor执行Task. Apache Drill并不会进行代码分发, 主要原因有以下几点: Drill使用功SQL作为输入语言, 避免了执行特定应用代码 每次进行查询时, Drill在每项Drillbit上生成Java代码并运行, 单个Drillbit可处理一定数量的查询 Drill将SQL语句转换成物理执行计划, 发送至Drillbit, 为获取最佳性能, 每项Operator将自身对应物理计划转换成Java代码, 然后进行批量数据处理计算. 本地代码生成, 不仅避免了复杂的代码分发, 也是基于Drill Schema读取的一种方式. Drill 代码生成主要用于过滤, 聚合, Join及其它计算. 只用当Operator观测到第一个Batch数据时, 才能知晓每列的数据类型, 只有知道了列的数据类型, 才可以判断是否执行整型还是浮点型数值计算. 不同的Scan操作可能会观测到不同版本的文件Schema, 因为每项Fragment可能会有不同的Schema及生成代码. Apache Drill并不能提前进行代码生成, 同一代码并非适用于所有Fragment. Long-Lived DrillbitMapReduce与Hive拓展性不错, 但批量计算耗时长, 除了与MapReduce Shuffle写磁盘有关外, 还有一点: YARN资源分配问题, YARN需为每一项Mapper以及Reducer开启一新的Process, 处理完后再销毁, 对于流水线式的数据批处理任务而言, 无疑增加了启动开销及其它系统资源消耗. Spark执行效率高, 一方面是基于内存计算, 另一方面在于每项Spark应用会复用同一组Executor, 减少了JVM启动开销. Apache Drill做法与Impala以及Hive LLAP(Live Long AND Process)有些类似, Impala通过使用Impalad进程, 长时间保活, 避免了频繁的销毁与创建, 执行效率高. 通常, Apache Drill每个节点分配一Executor(即Drillbit), 由于Drillbit是长时间运行, 当Drillbit接收到数据便可立即执行. 当然, 这种方式也带来了一个缺点: 缺乏资源隔离, 比如执行一Query时占用内存过多可能会导致其他Query分配不到内存, 换句话说消耗内存过多的Query可能会拖慢其它Query执行, 特别是当Apache Drill负载过重时. Apache Drill提供了准入控制功能, 可减少这种问题产生. 网络交换Apache Drill基于内存计算, 无需像MapReduce那样将临时数据写磁盘, 可直接通过网络将Drillbit上游数据发送至下游Drillbit即可. Drill Operator中用于处理数据的Buffer, 基于Netty网络层, Drill通过特定的握手机制实现Backpressure, 当下游消费端跟不上上游生产端时, 向生产端发信号要求放缓. 尽管, Apache Drill使用网络交换避免数据刷写磁盘, 但Drill有时也需写磁盘, 如执行Buffer操作符时, 比如排序, 哈希聚合, 哈希Join等, 需将其对应输入数据缓存, 如果内存放不下了, Drill会Spill部分数据写入磁盘, 虽然Spill可保持Query完整, 但Spill本身相对于内存处理慢很多. 如果Query执行慢于预期, 可能原因有以下几点:数据倾斜某些Operator, 等待输入数据, 执行条件不充分执行Buffer Operator时, 数据Spill至磁盘可以借助Apache Drill提供的Query Profile进行问题定位与排查. Query执行细节本节将探讨Drill Query执行细节, 或者说Drill Query是如何进行的. SQL 会话状态Drill作为查询引擎, 支持SQL, 通常SQL是有状态的, 每次数据库执行SQL, 均伴随着用户会话, 通过Drill客户端随机连接一Drillbit(即Foreman), 所有后续查询将于同一Drillbit提交, 以便复用会话状态. 换句话说, Foreman会话维护连接状态. 通常, Drillbit维护的状态包含: 数据库(如通过USE DATABASE语句指定DB) 或 Workspace(如通过USE WORKSPACE指定) 会话选项, 如通过UPDATE SESSION指定的会话选项 正在执行的Query状态 (Drill可并行执行多项Query) 临时表, 如通过CREATE TEMPORARY TABLE AS语句创建的临时表 用户会话状态, 伴随着连接, 连接关闭, 会话终止. 如果由于网络原因导致失去Drill连接, 重连时需要重建用户会话, 因而Drill客户端并不支持自动重连(假如Drill客户端支持自动重连, Query运行正常, 下次也可能运行失败, 如会话状态缺失导致等). 准备阶段Drill运行SQL语句, 通常包含以下两大步骤: 准备阶段, 将SQL解析, 翻译, 将抽象语法树转换成逻辑计划, 然后转换成物理执行计划 执行物理计划, 产生结果 准备阶段, 也可细分为以下几个阶段: 解析SQL语句为抽象语法树(AST)或内部解析树 对内部解析树执行语义分析, 如所选数据库名称, Schema, 表和列以及Drill定义函数等 将SQL解析树转换成逻辑计划 基于代价优化模型, 将逻辑计划转换成物理计划 将物理计划转换成执行计划, 分发Work至Woker Drillbit Drill使用Apache Calcite进行SQL解析与翻译(对应以上步骤1-4), Drill查询生命周期参考如下: 解析与语义分析解析阶段, 主要检查SQL语法, 如果存在SQL语法错误, Drill将显示一长串错误消息表明具体错误原因. 接着进行命名查找, 尽管在准备阶段, Drill已知晓数据库和表, 但Drill并不知道列名, 不知道列的数据类型(直到运行Query时才知道列的数据类型), 因而Drill仅在运行时才能发现类型错误. 此时, Drill会接受所有列名, 即使表中不存在的列名. 主要原因在于准备阶段, Drill并不知晓这一系类可用的列, 表也只是一系列数据文件, 甚至存在新版文件包含请求列, 而老版文件不存在情形. Drill作为一Schema-On-Read引擎, 能解决基于元数据系统(如Hive等)并不能解决的问题. 逻辑计划与物理计划Drill使用Apache Calcite进行SQL解析, 翻译并转换成逻辑计划, 如Drill判定用户进行表间Join, 在下一步执行物理计划时, 基于开销模型(或代价模型,Cost-Based), 选取开销最小的Join操作符执行Join. 通过Drill Web Console可查看每项Query Profile, Query Profile包含了Query逻辑计划与物理计划的可视化信息. 查询计划, 基本上可视为基于Major Fragment分组的一些列操作符, 这些操作符包括如: 扫描文件, 过滤, 执行Join等. 通常, 这些操作符也可组合成管道(Pipeline). 由于Drill是分布式的, 数据有时需要在不同的Drillbit间交换(对应MapReduce或Spark中Shuffle), 比如执行GROUP BY时, 从所有扫描操作符收集数据行, 然后发送至Drillbit进行分组聚合. 无需交换的一系列操作符, 也称Major Fragment, 在Drill Web Console中, 同一Fragment的操作符使用相同颜色标明. 每个Major Fragment开启一扫描或交换接收器, 以交换发送器或发送至Drill客户端结束. 这些操作符构成了一解析树, 根节点为Screen Operator(与Drill客户端对话), 叶节点为读取数据的Scan Operator. 数据从叶节点流至临时节点, 并最终将结果流转至根节点(Screen Operator). 从内部节点角度来看, 数据源也称上游, 目标数据也称下游, Drill Web Console中上游朝下, 下游朝上. 分发基于物理计划分发Work至Woker Drillbit, 由于每项Major Fragment单线程执行, Drill基于Major Fragment分发, 比如扫描文件时, Drill将Fragment切分为Slice, 如扫描文件夹时每一输入文件对应一Slice或对应每项文件的HDFS Block, 最终结果为一系列Slice(也称Minor Fragment), 作为Drill运行的最小工作单元. Drill分发这些Minor Fragment至Worker Drillbit执行, 这些Fragment可并行处理, Drill基于哈希键(用于Join或分组)对数据进行分组. Drill单独切分每项Major Fragment, 如果Query越复杂, 比如有10个Major Fragment, Drill将利用系统70%的内核进行并行处理, 由于每项Query可并行处理, 特殊情况Drill将创建更多的线程(可能超过系统允许创建最大线程数), 有可能导致应用崩溃. 可以通过启用Drill准入控制功能, 限制Query数量. Drill使用Zookeeper进行Drillbit协同, 假如新增一Drillbit至Drill集群, 只要新增Drillbit向Zookeeper进行注册, Drill便可使用该Drillbit执行Query. Major Fragment(对应Screen Operator)其实并不特殊, 因为最终会产生Minor Fragment, 这些Minor Fragment最终运行于Drillbit. 语句执行Drill执行完查询计划后, 开始执行, Drill中存在以下两种抉择: 返回计划给用户 (即执行EXPLAIN PLAN语句返回结果) 于Drill集群中执行计划 (通用方式) Foreman负责编排查询过程, 具体职责参考如下: 等待执行 (等待资源分配, 输入数据等) 发送Fragment至Drillbit执行 监控执行进度, 进行监测以防发生故障 追踪Fragment, 等待完成 等所有Major Fragment完成后, 关闭查询并写入Query Profile (可以通过Drill Web Console查看) Drill执行每项Query时, 使用状态机对每项Fragment进行追踪, Drill Web Console收集相关信息并展示Query状态, 当Query完成时, 最终状态将写入Query Profile. 可以通过研究整个Query的Profile信息, 以便后续进行Query优化等. 数据表征Drill以Minor Fragment形式分发Work至Drillbit, 每项Minor Fragment包含一系列Operator, 通常叶Fragment包含一项或多项扫描操作符. 现在问题来了, Drill执行Query时, 数据行如何进行处理? Drill作为一大数据查询引擎, 如果逐行进行数据处理, 十分低效. 尽管Drill也可逐行处理数据, 但Drill会对行进行分组为Record Batch, 每项Record Batch大小为几千行到65536行, Record Batch作为Shuffle交换的单位以及将结果数据返回给Drill客户端的单位. JDBC或ODBC Driver接收Record Batch, 进行遍历并返回每一行. 假定某项Query数据包含一百万行, Drill可能读取数据集并细分为20个Record Batch(假定每个Batch 5万条Record), Minor Fragment流转Record Batch于每项Operator, 当Batch到达Fragment顶部时, 将发送给下一Minor Fragment进行处理. Drill作为一列式查询引擎, 基于列存储数据, 这些基于列的数据也称值向量. 行可简单视为值向量的索引, 因而这些Record Batch也可简单视为值向量集. Drill Web Console中Query Profile通常会显示每项Operator或Fragment处理的Record Batch数量; 开发Drill拓展程序时, 需与Drill中值向量及Record Batch交互. Apache Drill后期将使用SIMD(Single Instruction Multiple Data, 单指令多数据流)技术, 加快Query执行效率, 现阶段使用SIMD主要存在以下两个问题:Drill使用SQL数据类型, 包含Null空值, 而SIMD指令并不支持Null值Drill基于SQL, SQL通常逐行处理而非列, 使用SIMD技术处理列存在难点]]></content>
      <categories>
        <category>Distributed System</category>
      </categories>
      <tags>
        <tag>Apache Drill</tag>
        <tag>Big Data</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Query Engine大作战 -- Apache Drill之用户接口篇]]></title>
    <url>%2Fbigdata%2Fdrill%2Fdbc%2F</url>
    <content type="text"><![CDATA[Apache Drill主要提供以下几种用户编程接口: JDBC ODBC REST 本文将对这几种用户接口进行说明与代码实战. RESTApache Drill提供REST用户接口, Drill的REST API支持Web Console URL, 如: 1http://hostname:8047/some-function 通过Drill REST API可以获取以下信息: Cluster (cluster.json), 获取Drillbits信息 Options (options.json), 获取系统数据类型、名称、会话选项等信息 Query (query.json), 执行查询, 可以通过POST请求执行Query Profiles (profiles.json), 获取运行Query的Profile信息 Staus (status.json), 获取Drill状态(Status) Storage (storage.json), 获取可插拔的存储配置, 允许创建、修改或删除这些存储配置, 可以通过POST请求进行变更 REST接口主要存在以下俩点限制: REST接口不适合大数据集查询 REST接口本身无状态, 不能使用USE或ALTER SESSION等指令 本节将使用Python作为Drill REST API调用的编程语言, 目前Python可通过drillpy或pydrill连接Apache Drill, 这俩Python模块均对Drill REST接口进行了封装. Drillpydrillpy与Python中DBAPI标准兼容, 可以与其它模块中数据库连接进行交互, drillpy安装指令参考如下: 1$ pip install drillpy drillpy连接Drill执行Query, 基本步骤如下: 首先创建连接(connection)对象 然后创建Cursor对象 通过在Cursor对象上调用execute()方法执行Query 通过调用fetchone(), fetchmany()或fetchall()方法获取查询结果, fetchall()及fetchmany()均返回DataFrame, fetchone()返回一Pandas Series对象 示例代码, 参考如下: 1234567891011from drillpy import connecthost = 'DRILL HOST'db = 'YOUR DB NAME'# 默认端口为 8047conn = connect(host=host, db=db, port=8047)cursor = conn.cursor()query_string = 'YOUR SQL QUERY HERE'query_result = cursor.execute(query_string)result_df = query_result.fetchall() 如果Query中含有参数, 参考代码如下: 12345# param_one与param_two参数值任意, 此处仅为示例代码param_one = 'Args One'param_two = 16 query_string = 'SELECT * FROM table_test WHERE field_one = ? AND field_two = ?'query_result = cursor.execute(query_string, (param_one, param_two)) Pydrillpydrill与Python中DBAPI标准不兼容, 该模块也对Drill REST接口进行封装, 鲁棒性更佳, 除了简单执行Query外还可访问其它Drill REST接口提供的信息. 除了执行Query, pydrill还支持以下功能: 访问Drill查询计划(Query Plan)及其它相关信息 访问Drill使用相关统计信息 激活可插拔的Drill存储并获取相关信息, 也可禁用这些可插拔的Drill存储 pydrill也可将查询结果直接转换为Pandas中的DataFrame, pydrill安装指令参考如下: 1$ pip install pydrill pydrill连接Drill执行Query, 基本步骤与drillpy有些类似: 首先创建连接对象, 可通过isActive()方法验证连接建立是否成功 执行Query 遍历查询结果或转换为DataFrame 示例代码, 参考如下: 12345678910111213from pydrill.client import pydrillhost = 'YOUR DRILL HOST'# 端口默认为 8047drill = pydrill(host=host, port=8047)# 检测是否成功建立连接, 若连接建立失败抛出异常if not drill.is_active(): raise ImproperlyConfigured('Please make sure Drill is running')query_string = 'YOUR SQL QUERY HERE'query_result = drill.query(query_string)# 将查询结果转换为 DataFramedf = query_result.to_dataframe() JDBC使用Drill JDBC接口, 需拷贝Drill JDBC Driver至Server主机, Drill默认包含了JDBC Driver(参考路径为$DRILL_HOME/jars/jdbc-driver/drill-jdbc-all-version.jar). 通常Drill的JDBC连接URL为: 12# 请将YOUR-HOST替换为Drill主机名或IP地址, 端口默认为31010jdbc:drill:drillbit=YOUR-HOST:31010 如果要连接分布式环境中Drill主机, 需给出ZooKeeper节点地址及端口, URL形式参考如下. 如果存在多个ZK节点, Drill将随机连接其中一个然后随机选取一Drillbit, 如果所选ZK节点下线或宕机了, Drill将连接其它ZK节点. 12345# 此处仅给出ZK节点及Schema配置# 除了这两项配置外, 还传入其它配置, 其它配置项略jdbc:drill:zk=zkhost1:2818, zkhost2:2181, zkhost3:2181;schema=mongdb JDBC连接URL中, 还可传入以下配置项(这些配置项值须与drill-override.conf中配置保持一致): Cluster ID, 同drill-override.conf配置中集群名, 默认为drillbits1, Port, 连接端口, 默认为31010 Schema, 可选, 连接默认可插拔存储 Tries, 连接尝试次数, 默认值为5 Directory, Drill集群ZK Root Znode, 默认为root Java程序可通过Drill JDBC连接Drill执行Query, 基本过程如下: 设置Drill JDBC Driver 通过调用DriverManager.getConnection()方法创建Connection对象 通过调用connection.createStatement()方法创建Statement对象 在Statement对象上调用executeQuery()方法执行Query 遍历查询结果, 进行后续处理 代码参考如下: 12345678910111213141516171819202122232425import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.Statement;public class DrillJDBCTest &#123; public static void main(String[] args) &#123; String conn = "jdbc:drill:drillbit=localhost:31010"; String queryString = "SELEC * FROM ecomm.some_table"; try &#123; Class.forName("org.apache.drill.jdbc.Driver"); Connection connection = DriverManager.getConnection(conn); Statement st = connection.createStatement(); ResultSet rs = st.executeQuery(queryString); // 遍历查询结果 while(rs.hasNext()) &#123; System.out.println(rs.getString(1)); &#125; &#125; catch(Exception e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; Python代码可以通过JayDeBeApi模块连接Drill并调用JDBC接口, 示例代码参考如下: 123456789101112131415161718192021import jaydebeapiimport pandas as pddriver = 'org.apache.drill.jdbc.Driver'conn_string = 'jdbc:drill:drillbit=localhost:31010'user_name = 'USER NAME'passwd = 'SOME PASSWORD'driver_path = '/path/to/drill-jdbc-all-version.jar'conn = jaydebeapi.connect(driver, conn_string, [user_name, passwd], driver_path)cursor = conn.cursor()query_string = 'SELECT * FROM ecomm.table_one LIMIT 100'cursor.execute(query_string)cursor.fetchall()# 执行Query并返回一DataFramedf = pd.read_sql(query_string, conn) ODBCApache Drill提供ODBC接口, 使用Drill ODBC接口须安装ODBC Driver, ODBC Driver安装过程可以参考Drill官方文档. Mac或Unix机上除了安装ODBC Driver外, 还需安装ODBC Driver管理器(如iODBC等). Drill ODBC Driver(即MapR ODBC Driver)安装完后, 需安装以下三项配置文件(安装完ODBC Driver后这些文件通常会拷贝至/opt/mapr/drill/Setup/ 目录下), 须拷贝这三项配置文件至用户主目录下并重命名为隐藏文件. .odbc.ini, 包含用户ODBC 数据源定义 .mapr.drillodbc.ini, 包含了Driver配置 .odbcinst.ini, 可选, ODBC Driver定义 然后需设置以下环境变量指向这些配置文件: 123export ODBCINI=~/.odbc.iniexport MAPRDRILLINI=~/.mapr.drillodbc.iniexport LD_LIBRARY_PATH=/usr/local/lib 如需连接分布式环境下Drill, 须指定以下变量: ZKQuorum, 逗号分割的ZK节点列表 ZKClusterID, Drillbit集群名, 须在drill-override.conf文件中有定义, 默认为drillbits1 Python代码可以通过pyODBC模块连接Drill并调用ODBC用户接口, 示例代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445import reimport pyodbcimport pandas as pdcnf = """Driver = /opt/mapr/drillodbc/lib/universal/libmaprdrillodbc.dylibConnectionType = DirectZKQuorum = ZKClusterID =Catalog = DRILLAuthenticationType = No AuthenticationAdvancedProperties = CastAnyToVarchar=trueHandshakeTimeout = 5QueryTimeout = 180TimestampTZDisplayTimezone = utcExcludedSchemas = sys,INFORMATION_SCHEMANumberOfPrefetchBuffers = 5HOST = localhostPORT = 31010"""cnf_lst = [re.sub(r'(\t+|\s+)=\s+', '=', i) \ for i in cnf.split('\n') if i != '']cnf = ';'.join(cnf_lst)user_id = 'USER ID'passwd = 'SOME PASSWORD'conn = pyodbc.connect(cnf, UID=user_id, PWD=passwd, autocommit=True)conn.setdecoding(pyodbc.SQL_CHAR, encoding='utf-8')conn.setdecoding(pyodbc.SQL_WCHAR, encoding='utf-8')conn.setencoding(encoding='utf-8')query_string = 'SELECT * FROM ecomm.table_one LIMIT 100'cursor = conn.cursor()cursor.execute(query_string)query_result = cursor.fetchall()n = 5# 执行Query并返回一DataFramedf = pd.read_sql(query_string)df.sample(n)]]></content>
      <categories>
        <category>Distributed System</category>
      </categories>
      <tags>
        <tag>Apache Drill</tag>
        <tag>Big Data</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flink学习手札之DataStream API初探]]></title>
    <url>%2Fbigdata%2Fflink%2Fdstream%2F</url>
    <content type="text"><![CDATA[Youtube上观看的Flink学习笔记, 有段时间了, 由于是边看视频边记的笔记, 逻辑有些乱, 还请见谅! 有时间再重新整理下! Data Source常见API Socket Based File Based socketTextStream(host,port) readFile(inputFormat:FileInputFormat[OUT], path:String) socketTextStream(host,port,delimiter) readFileStream(filePath:String, interval:Long, watchType: FileMonitoringFunction.WatchType) socketTextStream(host,port,delimiter,maxRetry) readFile(fileInputFormat, path, watchType, interval, pathFilter, typeInfo) FileMonitoringFunction.WatchType 说明 ONLY_NEW_FILES 仅处理新文件 PROCESS_ONLY_APPENDED 仅处理追加文件 PROCESS_WITH_APPENDED 不仅需要重新处理之前文件也需要处理追加文件 Data Sink常见API 方法 说明 writeAsText() - writeAsCsv() Row及Fields 分隔符也可指定 print()/printErr() 写入标准输出 writeUsingOutputFormat() 自定义OutputFormat,需继承OutputFomat进行序列化和反序列化 writeToSocket() 给定合理的序列化及格式化需定义SerializationSchema 物理分区 类型 示例 说明 Random Partitioning inputStream.shuffle() 随机分区 Reblancing Partitioning inputStream.rebalance() 使用round robin方式进行分发,便于处理数据倾斜 Rescaling inputStream.rescale() 仅发生于单节点,并不要求数据于网络间传输,于operations间分发数据,于数据子集上进行转换并归并 Broadcasting inputStream.broadcast() 分发数据于每个分区 Custom Partitioning inputStream.partitionCustom(partitioner, “someSkey”) inputStream.partitionCustom(partitioner, 0) //对于自定义分区器需有高效的Hash函数 时间语义 时间类型 说明 Event Time 生产设备事件触发时间,如IoT设备传感器捕获时间.这些事件事件在进入Flink前需嵌入Record中,处理时抽取出来并作为窗口衡量因素之一, EventTime可用于处理乱序事件 Ingestion Time 特定事件进入Flink时间,IngestionTime不能用于处理乱序事件,所有基于时间操作均需引用该时间戳 Processing Time 机器执行流式数据处理时间,进行事件处理时处理窗口仅考虑此时间戳.最简单的流式处理方式(并不要求处理机器与生产机器同步),在分布式环境中具有非确定性,依赖于系统流速 示例代码, 参考如下: 1234567val env: StreamExecutionEnvironment = StreamExecutionEnvironment.getExecutionEnvironment()// TimeCharacteristic.IngestionTime/ProcessingTimeenv.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime)/** 有俩种分配Watermark和时间戳的方式: 直接源自数据源属性; 使用Timestamp Assigner * Flink支持预定义的时间戳抽取器及Watermark生成器,可参考官方文档 */env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime) 窗口类型 类型 说明 Global Windows 永不终结除非指定触发器,如果不指定Trigger,并不会触发计算 Tumbling Windows 基于特定时间创建,固定窗口不重叠,适用于给定时间窗口计算 Sliding Windows 窗口重叠,窗口固定有滑动时间参数 Session Windows 基于输入数据确定窗口范围,窗口开始时间、大小灵活,会话窗口可关闭时间配置灵活 Transformation算子如: Map/FlatMap/Filter/Reducer/Fold/Aggregations/KeyBy, 示例代码参考如下: 12345678910inputStream.map &#123;el =&gt; el * 5&#125;inputStream.flatMap &#123; str =&gt; str.split("\\W")&#125;inputStream.filter&#123; _ != 0&#125;inputStream.reduce&#123; _ + _ &#125;inputStream.fold("init")((str, el) =&gt; &#123;str +"["+ el + "]"&#125;)// sum/min/max/minBy/maxBy etc.//`max`返回Stream最大值, 而`maxBy`返回Stream拥有最大值的key; 该规则同样适用于`min`/`minBy`inputStream.sum(0)inputStream.sum("some-attribute")inputStream.keyBy("some-key") 窗口相关, 如Window/WindowAll/Window Join, 示例代码参考如下: 1234567891011//`WindowAssigner`: Tumbling windows, Sliding windows, global &amp; session windowsinputStream.keyBy(0).window(TumblingEventTimeWindows.of(Time.seconds(10)))// 不可并行, 运行于non-partitioned数据流上inputStream.windowAll(TumblingEventTimeWindows.of(Time.seconds(10)))// Window Join. 5s窗口Join俩Stream,当inputStream第一个属性值与anotherStream第二个属性值相等时inputStream.join(anotherStream) .where(0) .equalTo(1) .window(TumblingEventTimeWindows.of(Time.seconds(5))) .apply &#123;...&#125; 类集合操作相关API, 如Union/Split/Select/Project, 示例代码参考如下: 1234567891011121314inputStream.union(stream1, stream2, ...)// Split Streamval spliter = (num: Int) =&gt; (num % 2) match &#123; case 0 =&gt; List("Even") case 1 =&gt; List("Odd")&#125;val splitStream: SplitStream[Int] = inputStream.split(spliter)// Select specific stream from the split streamval even = splitStream select "Even"val odd = splitStream select "Odd"val all = splitStream.select("Even", "Odd")// Projectval input: DataStream[(Int, Double, String, String)] = ???val out: DataStream[(String, String)] = input.project(3, 2) 外部连接器Flink外部连接器, 速查表参考如下: Kafka Connector RabbitMQ Connector Cassandra Connector ElasticSearch Connector File System Sink Connetor Twitter Connector 示例代码, 参考如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/************************************************************************************************************** * Kafka Connector 示例 **************************************************************************************************************/val topicName = "topic-name"val brokerList = "localhost:9092"val stringSchema = new SimpleStringSchema()val properties = new Properties()// kafka-0.8及以下版本需要指定ZKQuaromproperties.setProperty("bootstrap.servers", "kafka-bootstrap-host:9092")properties.setProperty("zookeeper.connect", "zkhost:2181") properties.setProperty("group.id", "consuming-group-id")// Consumer Sinkval input: DataStream[String] = env.addSource( new FlinkKafkaConsumer[String](topicName, stringSchema, properties))// Producer Sinkval stream: DataStream[String] = ???val producer = new FlinkKafkaProducer[String](brokerList, topicName, stringSchema)stream.addSink(producer)/***************************************************************************************************************** * ElasticSearch Connector * Embedded Node Mode: Sink使用`BulkProcessor`发送文档至ES,在发送前需设置Buffer的请求数 * Transport Client Node: 通过9300端口建立连接,需要指定所有的ES节点 *****************************************************************************************************************/val intput: DataStream[String] = ???val config = new HashMap[String, String]()config.put("bulk.flush.max.actions", "1")config.put("cluster.name", "cluster-name")val indexReqBuilder = new IndexRequestBuilder[String] &#123; override def createIndexRequest(element: String, ctx: RuntimeContext): IndexRequest = &#123; val json = new HashMap[String, AnyRef]() json.put("some-data", element) Requests.indexRequest().index("index-1").`type`("type-1").source(json) &#125;&#125;val esSink = new ElasticSearchSink(config, indexReqBuilder)// Embedded Node Modeinput.addSink(esSink)val transports = new ListBuffer[String]()transports.append(new InetSocketTransportAddress("es-node-1", 9300))transports.append(new InetSocketTransportAddress("es-node-2", 9300))transports.append(new InetSocketTransportAddress("es-node-3", 9300))tansports.toListval esSinkTransport = new ElasticSearchSink(config, transports, indexReqBuilder)// Transport Client Modeinput.addSink(esSinkTransport)/***************************************************************************************************************** * Streaming File Sink * 利用Checkpoint机制确保恰好一次及时消费语义性.当Sink写入一文件时,处于in-progress状态,RollingPolicy确定roll一文件, * 等下次checkpoint完成时, 通过重命名将文件追加状态转变为完成状态并关闭文件. * 当然在某种情况下追加文件并不会提交,`StreamingFileSink`确保数据不丢,但这些文件并不会自动清除 * 手动删除追加文件前,需检测它是否lingering还是将要提交, 当找到TaskIndex相同但ID更高的提交文件时,可以安全移除追加文件. * 依赖`flink-streaming-java`. 若应用禁用checkpoint,`StreamingFileSink`不会对文件从追加状态转变为完成状态. *****************************************************************************************************************/val lineReader = new TextInputFormat(null)// Filesystem Source, FileProcessingMode.PROCESS_CONTINUOUSLY|PROCESS_ONCE, 文件扫描时间周期msval lineStream = env.readFile[String](lineReader, "hdfs:///path/to/data", FileProcessingMode.PROCESS_CONTINUOUSLY, 30000L)val path = new Path("/path/to/base")val strEncoder = new SimpleStringEncoder[String]("UTF-8")val fSink: StreamingFileSink[String] = StreamingFileSink.forRowFormat(path, strEncoder).build()input.addSink(fSink)// Bulk-encoding mode in StreamingFileSink// 处于Bulk-encoding模式下不能选择`RollingPolicy`, Bulk-encoding只能选择结合`OnCheckpointRollingPolicy`, // 每次checkpoint时rolls in progress部分文件val avroWriter = ParquetAvroWriters.forSpecificRecord(classOf[AvroPojo])val fsSinkWithBulkEncoding = StreamingFileSink.forBulkFormat(path, avroWriter).build()input.addSink(fsSinkWithBulkEncoding)]]></content>
      <categories>
        <category>Distributed System</category>
      </categories>
      <tags>
        <tag>Big Data</tag>
        <tag>Apache Flink</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Query Engine大作战 -- Apache Drill之UDF篇]]></title>
    <url>%2Fbigdata%2Fdrill%2Fudf%2F</url>
    <content type="text"><![CDATA[本文将介绍Apache Drill中自定义函数(UDF, User Defined Function)及自定义聚合函数(UDAF, User Defined Aggregate Function)编写及代码实战. Drill UDFApache Drill中UDF可接收某列或Expression作为输入并返回计算结果, 返回值可以是基本类型, 也可以是复杂类型如数组或字典等. 添加依赖为正常使用Drill UDF, 需添加以下Maven依赖: 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.apache.drill.exec&lt;/groupId&gt; &lt;artifactId&gt;drill-java-exec&lt;/artifactId&gt; &lt;version&gt;THE-VERSION-OF-YOUR-DRILL&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.drill.contrib.function&lt;/groupId&gt; &lt;artifactId&gt;udf_template&lt;/artifactId&gt; &lt;version&gt;THE-VERSION-OF-YOUR-DRILL&lt;/version&gt;&lt;/dependency&gt; UDF实现Apache Drill中UDF实际功能由org.apache.drill.contrib.function.UDFTemplate提供, 该UDFTemplate包含很多样板代码, Drill并不直接执行该代码, UDFTemplate作为Drill生成代码的实现模板, 需结合UDF源码使用才能正常实现UDF功能. 实现一个简单的Drill UDF, 参考代码如下, 注意@FunctionTemplate中name不能为Drill中保留关键字、不能以数字开头, 若同一函数拥有不同版本接收不同输入, 这些版本的函数可以共享同一函数名(可以理解为允许方法重载); scope表明该函数是否为自定义函数(UDF)还是自定义聚合函数(UDAF); nulls变量表明该函数的空值处理策略. 1234567891011121314151617181920212223242526@FunctionTemplate( // 也可定义函数别名, 如: // names = &#123;"func_name_one", "func_name_two"&#125; name="your_function_name", // `SIMPLE`表明该函数为一自定义函数(UDF) scope=FunctionTemplate.FunctionScope.SIMPLE, // `NULL_IF_NULL`配置将跳过空行, 本例中Query结果中将以NULL代替空行 nulls=FunctionTemplate.NullHandling.NULL_IF_NULL)public class YourDefinedFunction implements DrillSimpleFunc &#123; @Param VarCharHolder yourInputNumber; @Output BitHolder isValid; @Override public void setup() &#123; // Do Something &#125; @Override public void eval() &#123; // 主逻辑实现略 &#125;&#125; 基于Apache Drill的模板系统, Drill要求开发者为输入参数定义Holder类型, Drill中常见Holder类型与SQL数据类型对应关系如下: SQL数据类型 Drill中对应Holder类型 INT IntHolder FLOAT Float4Holder DECIMAL Decimal9Holder DOUBLE Float8Holder BIGINT BigIntHolder VARCHAR VarCharHolder DATE DateHolder BOOLEAN BitHolder TIMESTAMP TimeStampHolder VARBINARY VarBinaryHolder TIME TimeHoder UDF编码实战下面看个简单例子, 编写一Drill UDF对信用卡号码进行合法性校验, 参考代码如下: 123456789101112131415161718192021222324252627282930313233343536import org.apache.commons.validator.routines.CreditCardValidator;import org.apache.drill.exec.expr.fn.impl.StringFunctionHelpers;@FunctionTemplate( name= "validate_credit_card", scope=FunctionTemplate.FunctionScope.SIMPLE, nulls=FunctionTemplate.NullHandling.NULL_IF_NULL)public class ValidateCreditCard implements DrillSimpleFunc &#123; @Param VarCharHolder cardNumber; // 每次迭代时均需使用`ccv`, 为提高性能, 可将该`CreditCardValidator` // 对象存储于 `@Workspace` 并在 `setup()` 方法中实例化 @Workspace CreditCardValidator ccv; @Output BitHolder out; public void setup() &#123; CreditCardValidator ccv = new CreditCardValidator(); &#125; // 信用卡号码合法性校验, 若信用卡号码合法输出值为1, 信用卡号码非法输出值为0 public void eval() &#123; String creditCardNumber = StringFunctionHelpers .toStringFromUTF8(cardNumber.start, cardNumber.end, cardNumber.buffer); if (ccv.isValid(creditCardNumber)) &#123; out.value = 1; &#125; else &#123; out.value = 0; &#125; &#125;&#125; UDF部署新版Apache Drill支持动态注册和注销Drill UDF, 无需重启Drillbits, 为动态注册UDF, 需配置以下路径(注意这些分布式文件系统中路径须对所有的Drillbits可见): Staging Directory, UDF注册前拷贝Jar包文件路径 Local Directory, 动态UDF Jar包文件临时路径, 当Drill关闭时会清空掉该路径 Registry Directory, UDF注册后Jar包拷贝路径 tmp directory, 该路径包含备份的Jar包 这些配置路径, 详见$DRILL_HOME/conf/drill-override.conf, 通常只需设置主路径, 然后让Drill在主路径下定义UDF路径即可, 参考配置如下: 1234567891011drill.exec.udf: &#123; retry­attempts: 5, directory: &#123; # Override this property if custom file system should be used to create # remote directories instead of default taken from Hadoop configuration fs: "hdfs:///", # Set this property if custom absolute root should be used for remote # directories root: "/app/drill" &#125;&#125; 设置完文件系统和主路径便可动态注册Drill UDF, 首先拷贝Jar包至Staging路径, 然后通过以下指令注册Drill UDF: 1CREATE FUNCTION USING JAR 'your_udf_jar_file'; 如果需要注销Drill UDF, 参考指令如下: 1DROP FUNCTION USING JAR 'your_udf_jar_file'; Drill UDAF实现一Drill自定义聚合函数, 与实现Drill UDF有些类似, 但需额外实现以下四个方法: add(), 该方法处理每项Record, 可以粗略的等效为UDF中eval()方法, 该方法用于实现主要聚合逻辑 output(), 该方法计算最终结果并输出 setup(), 该方法用于初始化变量等其它准备操作, 当首次调用UDAF时会调用该方法 reset(), 该方法可用于重置计数器或累计值, 当某列中数据类型发生改变或处理某项Section数据需要进行相关重置操作时, 可以调用该方法 Drill UDAF限制Apache Drill中UDAF存在以下限制: Apache Drill自定义聚合函数中含@Workspace注解(Annotation)的变量不能为复杂变量 含@Workspace注解的变量须为Drill中的Holders类型 含@Output或@Workspace注解的变量不能为可变长度或复杂变量 Apache Drill对于数值计算相关聚合函数存在一定限制, 如果想在@Workspace中使用非数值Holder, 可以考虑使用ObjectHolder(Drill后续版本可能会移除, 具体请参考官方文档), 如果数据集足够大以致Drill做哈希聚合时数据溢出至磁盘, 可能会导致Query失败. 可以参考以下指令禁用哈希聚合: 1ALTER SERSSION SET `planner.enable_hashagg`= false Apache Drill的UDAF须内部处理空值, 如将nulls变量设置为FunctionTemplate.NullHandling.INTERNAL; 还有一点, Drill自定义聚合函数中scope须设置为POINT_AGGREGATE, Apache Drill的UDAF函数模板参考如下: 12345@FunctionTemplate( name="correlation_function", scope=FunctionTemplate.FunctionScope.POINT_AGGREGATE, nulls=FunctionTemplate.NullHandling.INTERNAL) Drill UDAF代码实战下面使用Apache Drill编写一自定义聚合函数, 使用该UDAF计算Kendall(肯德尔)系数, 同序对(concordant pairs)和异序对(discordant pairs)之差与总对数(n*(n-1)/2)的比值定义为Kendall(肯德尔)系数. 相关变量及输出Holder, 声明如下: 1234567891011121314151617181920212223@Param Float8Holder xInput;@ParamFloat8Holder yInput;@WorkspaceFloat8Holder prevValueX;@WorkspaceFloat8Holder prevValueY;@WorkspaceIntHolder concordantPairs;@WorkspaceIntHolder discordantPairs;@WorkspaceIntHolder n;@OutputFloat8Holder tau; 其中同序对(concordantPairs)、异序对(discordantPairs)、prevValueX、prevValueY及参数n, 更新规则如下: 12345678910111213141516171819202122232425262728@Override public void add() &#123; double valueX = xInput.value; double valueY = yInput.value; if (n.value&gt;0) &#123; if ((valueX &gt; prevValueX.value &amp;&amp; valueY &gt; prevValueY.value) || (valueX &lt; prevValueX.value &amp;&amp; valueY &lt; prevValueY.value)) &#123; concordantPairs.value = concordantPairs.value + 1; prevValueX.value = xInput.value; prevValueY.value = yInput.value; n.value = n.value + 1; &#125; else if ((valueX &gt; prevValueX.value &amp;&amp; valueY &lt; prevValueY.value) || (valueX &lt; prevValueX.value &amp;&amp; valueY &gt; prevValueY.value)) &#123; discordantPairs.value = discordantPairs.value + 1; prevValueX.value = xInput.value; prevValueY.value = yInput.value; n.value = n.value + 1; &#125; else &#123; prevValueX.value = xInput.value; prevValueY.value = yInput.value; &#125; &#125; else if (n.value == 0) &#123; prevValueX.value = valueX; prevValueY.value = valueY; n.value = 1; &#125;&#125; 实现output()方法, 相对简单, 计算出同序对(concordantPairs)与异序对(discordantPairs)之差, 再除以总对数(n*(n-1)/2), 并将结果值赋给输出Holder tau即可. 1234567@Overridepublic void output() &#123; double result = 0.0; result = (concordantPairs.value - discordantPairs.value) / (0.5 * n.value * (n.value -1)); tau.value = result;&#125; 其中setup()及reset()函数实现很简单, 代码参考如下: 12345678910111213@Overridepublic void setup() &#123; // 不需要, 可以不实现&#125;// 重置所有变量和计数器值为0@Overridepublic void reset() &#123; prevValueX.value = 0; prevValueY.value = 0; concordantPairs.value = 0; discordantPairs.value = 0; n.value = 0;&#125;]]></content>
      <categories>
        <category>Distributed System</category>
      </categories>
      <tags>
        <tag>Apache Drill</tag>
        <tag>Big Data</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cascading实战之动态流控与组件交互篇]]></title>
    <url>%2Fbigdata%2Fcascading%2Fflow-control%2F</url>
    <content type="text"><![CDATA[本文将介绍Cascading开发过程中动态流控技巧及与其它外部组件交互应用. 动态流控Cascading中Flow可动态定义、控制, Cascading允许开发人员对数据处理流Flow进行动态编码控制, 如多次迭代运行Data Flow或控制Task执行顺序等. 存在以下几类算法需动态规划(控制): 图处理算法, 如Graph的路径、周期、分区等问题 NLP处理、强化相关算法 机器学习算法如随机梯度下降、”爬坡”算法等 常见递归算法, 如 Monte Carlo算法、Markov Chain迭代算法等 在实际开发中, 处理以上类型Task时, 需保存状态信息、内部计数器等, 便于下次迭代交互、提高计算效率. 本节将从: 计数器、动态定义Flow(FlowDef)及与已有MapReduce任务交互 三个方面对Cascading中动态”流控”(Flow Control)进行阐述. 计数器Flow中允许创建内部计数器(也称仪表), 当一个Operation传入FlowProcess对象时, 可在该FlowProcess对象上触发计数操作, 无需定义计数器, 仅需定义Group名和计数器名即可, 计数器初始化值为0, 计数器累加操作示意代码如下: 12345String counterGroup = "GroupName";String counterName = "CounterOne";// 计数器作用于FlowProcess, 并执行累加操作// FlowProcess实例化代码略flowProcess.increment(counterGroup, counterName, 1); 也可通过枚举定义计时器, 参考代码如下: 12345public enum COUNTERS &#123; COUNTER1, COUNTER2&#125;flowProcess.increment(COUNTER1, 1); 可以通过Flow读取计数器值, 参考代码如下: 12int counter = flow.getFlowStats() .getCounterValue(counterGroup, counterName); Cascading开发中, 可以通过计数器方式动态地控制Cascading中Flow迭代次数, 执行流程图参考如下: 代码参考如下: 12345678910111213141516171819// 构建FlowDef及Flow, 具体实现略FlowConnetor flowConnector = new LocalFlowConnector();String counterGroup = "GroupName";String counterName = "CounterOne";// 定义最大迭代次数以及计数器int maxIterations = 100;int updateCount = 0;boolean done = false;while(!done) &#123; flowConnector.connect(flowDef).complete(); // 计数器初始化为0 updateCount = flow.getFlowStats() .getCounterValue(counterGroup, counterName); maxIterations--; done = (maxIterations == 0 || updateCount == 0); &#125; FlowDef可以通过使用Fluent风格编程方式定义Flow, Fluent风格编程, 主要由Eric Evans和Martin Fowler于05年提出, “Fluent”风格编程也常被引用为Method Cascading, “Fluent”风格编程允许将一系列方法调用链(chain)起来, 形成单条Statement, 参考形式如下: 123// methodA的输出(即返回值)为methodB的输入, methodB的输出为methodC的输入// 与函数式编程的函数组合子有些类似, 但形式上更偏面向对象编程object.methodA().methodB().methodC(); 通过将对象object上调用的方法methodA、methodB、methodC链起来, 以提高代码可读性与可维护性. 其中methodA、methodB、methodC方法有些类似于函数式编程中的Monad概念, Monad可构成管道(Pipe)处理流中一部分并链起来(chain), 不可或缺. Cascading中也存在Fluent风格编程, 如FlowDef, 动态而”流畅”(Fluently)地构建数据处理Flow, FlowDef常见方法签名如下: 1234567FlowDef addSource(Pipe pipe, Tap sourceTap);FlowDef addSink(Pipe pipe, Tap sinkTap);FlowDef addTailSink(Pipe pipe, Tap tailSinkTap);FlowDef addTrap(Pipe pipe, Tap trapTap);FlowDef addToClassPath(String jarPath);FlowDef addCheckpoint(String name, Tap checkpointTap);FlowDef addAssemblyPlanner(AssemblyPlanner assemblyPlanner); 需要注意的是addAssemblyPlanner方法实际负责构建运行FlowConnector的Cascading代码, AssemblyPlanner实例提供了Cascading运行于Hadoop MapReduce、Tez、Apache Flink底层框架的方式. FlowDef示例代码如下: 1234567FlowDef flowDef = FlowDef.flowDef() .addSource(pipe, srcTap) .addTailSink(pipe, sinkTap);FlowConnetor flowConnector = new LocalFlowConnector();Flow flow = flowConnector.connect(flowDef);flow.complete(); 构建Flow时也可传入含Taps及Pipes的容器, 参考代码如下: 1234567891011List&lt;Pipe&gt; pipes = new ArrayList&lt;Pipe&gt;(2);pipes.add(pipeOne);pipes.add(pipeTwo);Map&lt;String, Tap&gt; taps = new HashMap&lt;String, Tap&gt;();taps.put("sourceTap", sourceTap);taps.put("sinkTap", sinkTap);FlowConnetor flowConnector = new LocalFlowConnector();Flow flow = flowConnector.connect(source, taps, pipes);flow.complete(); FlowDef中addSource、addSink、addTailSink等方法可以调用多次, 代码参考如下: 12345678FlowDef flowDef = FlowDef.flowDef() .addSource(pipeOne, sourceTap) .addSource(pipeTwo, anotherSourceTap) .addTailSink(tailPipe, sinkTap);FlowConnetor flowConnector = new LocalFlowConnector();Flow flow = flowConnector.connect(flowDef);flow.complete(); 与MR交互通常, 生产环境中可能运行多项MapReduce任务, 有时需要利用这些已有的MR来构建新的Data Flow, Cascading与现有MapReduce交互代码, 示例如下: 123456789101112131415// Hadoop JobConf配置, Job名、Mapper/Reducer、Key/Value类型设置JobConf mrcnf = new JobConf();mrcnf.setJobName("mr-job-one");mrcnf.setOutputKeyClass(LongWritable.class);mrcnf.setOutputValueClass(Text.class);mrcnf.setMapperClass(IdentityMapper.class);mrcnf.setReducerClass(IdentityReducer.class);// FlowOne -&gt; MapReduceFlow -&gt; FlowTwoFileInputFormat.setInputPath(mrcnf, flowOneSinkTap.getPath());FileOutputFormat.setOutputPath(mrcnf, flowTwoSourceTap.getPath());Flow mrFlow = new MapReduceFlow("mrflow", mrcnf);Cascade cascade = CascadeConnector(flowOne, mrFlow, flowTwo);cascade.complete(); 与外部组件交互本节将介绍Cascading如何与外部组件进行交互、集成. Cascading基于用户定义代码生成执行图(Execution Graph), 该Graph并不依赖于运行框架, 对应Job存在多种可选的组装计划器(Planners)及连接器(Connectors), 允许Cascading任务从一框架迁移至另一框架中运行, 做到了同一套代码, 可复用运行于多种框架. Cascading除了可运行于Hadoop之上(即MapReduce), 还可运行于Tez和Flink之上. Cascading On Flink, 灵活的网络栈, 支持低时延数据管道传输及转换、大规模可拓展; 内存安全; 基于内存计算的Operator、计算效率大大提升; 主动内存管理及自定义序列化栈, 支持Binary数据高效操作、防止JVM内存溢出及GC 暂停(GC Pauses). 以下这段代码为简单的WordCount (Cascading On Flink): 1234567891011121314151617181920public static void main(String[] args) &#123; Fields token = new Fields("token"); Fields text = new Fields("text"); RegexSplitGenerator splitter = new RegexSplitGenerator(token, "\\s+"); Pipe tokenPipe = new Each("token", text, splitter, Fields.RESULTS); Pipe wordCountPipe = new Pipe("wordcount", tokenPipe); wordCountPipe = new AggregateBy(wordCountPipe, token, new CountBy(new Fields("count"))); Tap input = new Hfs(new TextDelimited(text, "\n"), args[0]); Tap output = new Hfs(new TextDelimited(false, "\n"), args[1], SinkMode.REPLACE); FlowDef flowDef = FlowDef.flowDef.setName("wordcount") .addSource(tokenPipe, input) .addTailSink(wordCountPipe, output); FlowConnector flowConnector = new FlinkConnector(); Flow wordCountFlow = flowConnector.connect(flowDef); wordCountFlow.complete();&#125; Cascading On Tez, Tez计算引擎相比MapReduce, 做了很多优化, 如减少大量数据传输(如MapReduce中间数据不断刷写磁盘)开销等, 将整个Flow作为单个Job执行, 无需将临时文件刷写至HDFS. Cascading通过创建特定的Tez计划器、连接器、Flows、Taps等, 生成执行图(Execution Graph)用于分析特定模式, 创建特定的Processors提交至Tez引擎进行计算. Cascading On Hadoop, 注意Hadoop版本迁移问题, 如Hadoop 2.X系列使用YARN作为资源管理、调度工具, 而非之前版本的JobTracker与TaskTracker. 进行Cascading开发时, 须注意Hadoop版本迁移问题. FlowListener每项Flow与Cascade均可通过事件监听器执行回调(Callback), 适用于当Cascade或Flow开启、中断、完成、抛出异常时及时通知外部应用, Cascade或Flow生成事件可由客户端代码进行处理. 如当运行于Amazon EC2 Hadoop集群的Flow完成时, 可通过发送Amazon SQS消息通知另一应用获取Job结果或Shutdown集群等. 示例代码如下: 12345678910111213141516171819202122FlowListener listener = new FlowListener() &#123; public void onStarting(Flow flow) &#123; // 略去具体实现 &#125; public void onStopping(Flow flow) &#123; // 略去具体实现 &#125; public void onCompleted(Flow flow) &#123; // 略去具体实现 &#125; public boolean onThrowable(Flow flow, Throwable throwable) &#123; return false; &#125;&#125;flow.addListener(listener);assertFalse("No listener found", flow.hasListener());flow.removeListener(listener);assertTrue("Listener found", flow.hasListener()); 以下代码中, setSyslogger方法将发送Cascading Job消息(Flow开启、中断、完成等)至Unix风格Syslog Server(该UDP Server使用syslog4j): 1234567891011121314151617181920212223242526272829import org.productivity.java.syslog4j.Syslog;public void setSyslogger(Flow flow) &#123; FlowListener listener = new FlowListener() &#123; public void onStarting(Flow flow) &#123; Syslog.getInstance("udp").info(flow.getName() + "started at "+ new Date().toString()); &#125; public void onStopping(Flow flow) &#123; Syslog.getInstance("udp").info(flow.getName() + "stopped at "+ new Date().toString()); &#125; public void onCompleted(Flow flow) &#123; Syslog.getInstance("udp").info(flow.getName() + "completed at " + new Date().toString() + "with status " + flow.getFlowStats().getStatus().toString() ); &#125; public boolean onThrowable(Flow flow, Throwable throwable) &#123; return false; &#125; &#125;; flow.addListener(listener);&#125; 外部Jar包依赖Cascading开发中, 有时需使用外部Jar包依赖, 可添加这些依赖包至Java类路径中以便正常使用. 对于Cascading本地模式而言, 参考指令如下: 12$ # 请将external-dependency.jar替换为具体外部依赖Jar包$ java -cp your-job.jar:external-dependency.jar:cascading-lib/* com.your-company.your-jobs.MainJob 对于Cascading Hadoop模式而言, 有些复杂, 可考虑打成Uber Jar(或Fat Jar), Uber Jar中包含任务运行所需的所有依赖, 运行参考指令如下: 12$ hadoop jar your-jobs-uber-jar.jar com.your-company.your-jobs.MainJob \ /path/to/input /path/to/output 由于Uber Jar可能比较大, 可以参考以下指令将外部依赖Jar包传入: 12$ hadoop jar your-job.jar com.your-company.your-jobs.MainJob \ -libjar external-dependency.jar /path/to/input /path/to/output]]></content>
      <categories>
        <category>Distributed System</category>
      </categories>
      <tags>
        <tag>Big Data</tag>
        <tag>Cascading</tag>
        <tag>MapReduce</tag>
        <tag>Apache Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cascading实战之Cascade篇]]></title>
    <url>%2Fbigdata%2Fcascading%2Fcascade%2F</url>
    <content type="text"><![CDATA[本文将介绍Cascading中Cascade相关概念及使用技巧. Cascading中Cascade通常指一系列Flow, 不同独立的Flow可放在一起生成执行图(Execution Graph), 如果Cascade中有一项Flow依赖其他Flow输出, 该Flow并不会立即执行, 直至所依赖的Flow完成、输入数据满足条件才会执行. Flow Build或许你可能会问, 为何要使用Cascade, 而非含SubAssembly的Big Flow构建自定义、复杂的数据工作流(Workflow)? 但Cascade可以更好地解决以下问题: 为了更好地复用组件及Debug调试, 需要将Workflow分解成足够小而独立的逻辑单元 需要使用已有的MapReduce任务作为Workflow中一部分 需要使用外部组件交互作为Workflow中一部分 需要使用现有的Flow与新的Workflow进行交互、协调 将多项Flow连接起来, 形成Cascade, 参考代码如下, 注意传入的Flow顺序并不重要, Cascading通过使用CascadeConnector辨识Flow中依赖(基于这些Flow的Tap自动有序连接, 可以将这些Tap(通常为文件)视为Flow的连接, 一项Flow的输出可能为另一项Flow的输入, 基于这些Tap及Flow依赖关系, 可以有序地将Flow连起来), 如果这些Flow不存在Tap依赖, 可以并行执行. 12CascadeConnector connector = new CascadeConnector();Cascade cascade = connector.connect(flow1, flow2, flow3, flow4); 假如flow2和flow3分别依赖flow1输出, 而flow4输入数据依赖于flow2和flow3输出数据, 由于flow2和flow3彼此并不依赖可以并行运行, 若Data 1a和Data 1b数据比输入数据Input Data还要新则会跳过flow1(Data 2和Data 3与之类似), 整个Cascade中Flow执行示意图参考如下: Skip Flow执行Cascade时, 可以允许跳过执行某项Flow, 有时Workflow中某项Flow已经完成, 没有必要再重新运行可以选择跳过. Cascading中Flow跳过策略有以下两种: cascading.flow.FlowSkipIfSinkExists, 如果Sink Tap存在则跳过对应Flow, 如果Sink Tap的SinkMode值为REPLACE, 该Sink Tap也可视为Stale(陈旧). cascading.flow.FlowSkipIfSinkNotStale, 默认Flow跳过策略, 如果Sink资源比Feeding Source(数据生成源)要老或Sink并不存在, Sink Tap可以视为Stale(陈旧); 如果Sink Tap的SinkMode值为REPLACE, 该Sink Tap也可视为Stale. 也可实现自定义Skip策略, 只需实现cascading.flow.FlowSkipStrategy接口, 并实现boolean skipFlow(Flow flow)方法即可. 下面这段代码, 展示了如何跳过某项Flow(代码中Flow1使用语句分割器分割语句, Flow2在Flow1基础上对语句进行分词, 当两项Flow组成Cascade运行时, 若Flow1生成的语句输出已经存在, 基于FlowSkip策略, 此时会跳过Flow1. 可以参考第二次代码运行日志, 可以清楚地看到将跳过Flow1: “[pool-1-thread-1] INFO cascading.cascade.Cascade -[Flow2+Flow1] skipping flow: Flow1”). 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import cascading.cascade.Cascade;import cascading.cascade.CascadeConnector;import cascading.flow.Flow;import cascading.flow.FlowSkipIfSinkExists;import cascading.flow.FlowSkipStrategy;import cascading.flow.local.LocalFlowConnector;import cascading.pipe.Each;import cascading.pipe.Every;import cascading.pipe.GroupBy;import cascading.pipe.Pipe;import cascading.scheme.Scheme;import cascading.scheme.local.TextDelimited;import cascading.tap.SinkMode;import cascading.tap.Tap;import cascading.tap.local.FileTap;import cascading.tuple.Fields;public class TestCascade &#123; public void main(String[] args) &#123; // 输入文本 Fields fieldDeclarationInput = new Fields("document", "text"); // 基于文本断句(分句) Fields fieldDeclarationInterm = new Fields("document", "sentum", "sentence"); // 基于语句分词 Fields fieldDeclarationOutput = new Fields("docname", "sentnum", "wordnum", "word"); Scheme inputScheme = new TextDelimited(fieldDeclarationInput, true, "\t"); Scheme intermScheme = new TextDelimited(fieldDeclarationInterm, "\t"); Scheme outputScheme = new TextDelimited(fieldDeclarationOutput, "\t"); Tap srcTap = new FileTap(inputScheme, args[0]); Tap sink1Tap = new FileTap(intermScheme, args[1]); Tap sink2Tap = new FileTap(outputScheme, args[2], SinkMode.REPLACE); // Flow1基于输入文本分句, SentenceFunction封装了语句分割逻辑 Pipe pipe1 = new Pipe("InPipe1"); pipe1 = new Each(pipe1, new SentenceFunction); Flow flow1 = new LocalFlowConnector().connect("Flow1", srcTap, sink1Tap, pipe1); // Flow2在Flow1基础上对语句进行分词, TokenBuffer封装了分词逻辑 Pipe pipe2 = new Pipe("InPipe2"); pipe2 = new GroupBy(pipe2, new Fields("document"), new Fields("sentnum")); pipe2 = new Every(pipe2, new TokenBuffer(), fieldDeclarationOutput); Flow flow2 = new LocalFlowConnector().connect("Flow2", sink1Tap, sink2Tap, pipe2); CascadeConnector connector= new CascadeConnector(); Cascade cascade = connector.connect(flow2, flow1); // 指定FlowSkip策略 cascade.setFlowSkipStrategy(new FlowSkipIfSinkExists()); cascade.complete(); &#125;&#125; 第一次运行该程序时, 没有输出文件, 该Cascading程序运行日志参考如下: 12345678910111213141516171819202122232425262728[cascade Flow2+Flow1] INFO cascading.cascade.Cascade -[Flow2+Flow1] starting[cascade Flow2+Flow1] INFO cascading.cascade.Cascade -[Flow2+Flow1] parallel execution is enabled: true[cascade Flow2+Flow1] INFO cascading.cascade.Cascade -[Flow2+Flow1] starting flows: 2[cascade Flow2+Flow1] INFO cascading.cascade.Cascade -[Flow2+Flow1] allocating threads: 2[pool-1-thread-1] INFO cascading.cascade.Cascade -[Flow2+Flow1] starting flow: Flow1[pool-1-thread-1] INFO cascading.flow.Flow -[Flow1] at least one sink does not exist[flow Flow1] INFO cascading.flow.Flow -[Flow1] starting[flow Flow1] INFO cascading.flow.Flow - [Flow1] source: FileTap["TextDelimited[['document', 'text']]"]["/data/files/sent.txt"][flow Flow1] INFO cascading.flow.Flow - [Flow1] sink: FileTap["TextDelimited[['document', 'sentnum', 'sentence']]"]["/data/files/sent.txt"][flow Flow1] INFO cascading.flow.Flow -[Flow1] parallel execution is enabled: true[flow Flow1] INFO cascading.flow.Flow -[Flow1] starting jobs: 1[flow Flow1] INFO cascading.flow.Flow -[Flow1] allocating threads: 1[pool-2-thread-1] INFO cascading.flow.FlowStep -[Flow1] starting step: local[pool-1-thread-1] INFO cascading.cascade.Cascade -[Flow2+Flow1] completed flow: Flow1[pool-1-thread-2] INFO cascading.cascade.Cascade -[Flow2+Flow1] starting flow: Flow2[pool-1-thread-2] INFO cascading.flow.Flow -[Flow2] at least one sink is marked for delete[flow Flow2] INFO cascading.flow.Flow -[Flow2] starting[flow Flow2] INFO cascading.flow.Flow - [Flow2] source: FileTap["TextDelimited[['document', 'sentnum', 'sentence']]"]["/data/files/sent1.txt"][flow Flow2] INFO cascading.flow.Flow - [Flow2] sink: FileTap["TextDelimited[['documentname', 'sentnumber', 'wordnum', 'word']]"]["/data/files/tok1.txt"][flow Flow2] INFO cascading.flow.Flow -[Flow2] parallel execution is enabled: true[flow Flow2] INFO cascading.flow.Flow -[Flow2] starting jobs: 1[flow Flow2] INFO cascading.flow.Flow -[Flow2] allocating threads: 1[pool-5-thread-1] INFO cascading.flow.FlowStep -[Flow2] starting step: local[pool-1-thread-2] INFO cascading.cascade.Cascade -[Flow2+Flow1] completed flow: Flow2 第二次运行该程序时, 会跳过flow1, 因为语句分词阶段产生的临时文件已经存在(由第一次运行程序时产生), 该程序运行日志参考如下: 123456789101112131415161718[cascade Flow2+Flow1] INFO cascading.cascade.Cascade -[Flow2+Flow1] starting[cascade Flow2+Flow1] INFO cascading.cascade.Cascade -[Flow2+Flow1] parallel execution is enabled: true[cascade Flow2+Flow1] INFO cascading.cascade.Cascade -[Flow2+Flow1] starting flows: 2[cascade Flow2+Flow1] INFO cascading.cascade.Cascade -[Flow2+Flow1] allocating threads: 2[pool-1-thread-1] INFO cascading.cascade.Cascade -[Flow2+Flow1] starting flow: Flow1[pool-1-thread-1] INFO cascading.cascade.Cascade -[Flow2+Flow1] skipping flow: Flow1[pool-1-thread-2] INFO cascading.cascade.Cascade -[Flow2+Flow1] starting flow: Flow2[pool-1-thread-2] INFO cascading.flow.Flow -[Flow2] at least onesink is marked for delete[flow Flow2] INFO cascading.flow.Flow -[Flow2] starting[flow Flow2] INFO cascading.flow.Flow - [Flow2] source: FileTap["TextDelimited[['document', 'sentnum', 'sentence']]"]["/data/files/sent1.txt"][flow Flow2] INFO cascading.flow.Flow - [Flow2] sink: FileTap["TextDelimited[['documentname', 'sentnumber', 'wordnum', 'word']]"]["/data/files/tok1.txt"][flow Flow2] INFO cascading.flow.Flow -[Flow2] parallel execution is enabled: true[flow Flow2] INFO cascading.flow.Flow -[Flow2] starting jobs: 1[flow Flow2] INFO cascading.flow.Flow -[Flow2] allocating threads: 1[pool-2-thread-1] INFO cascading.flow.FlowStep - [Flow2] starting step: local[pool-1-thread-2] INFO cascading.cascade.Cascade -[Flow2+Flow1] completed flow: Flow2]]></content>
      <categories>
        <category>Distributed System</category>
      </categories>
      <tags>
        <tag>Big Data</tag>
        <tag>Cascading</tag>
        <tag>MapReduce</tag>
        <tag>Apache Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将集成开发环境(IDE)搬到浏览器中]]></title>
    <url>%2Flife%2Fide-cn%2F</url>
    <content type="text"><![CDATA[重磅! Bring Your IDE Into Your Browser. 对, 你没看错, 不是在浏览器中敲JS代码, 也不是运行WebAssembly代码, 而是真正的将你的IDE移植到浏览器中, 打造高效的开发环境! 前提首先, 你得有台云主机或VPS, 用于安装Cloud IDE(能在浏览器中运行的IDE, 不叫Cloud IDE叫啥?). 如果你只是在你本地环境搞, 没什么意义, 那还不如直接用本地PC IDE, 对不? 理由和大多数开发人员一样, 你可以: 通过SSH和FTP访问云主机或VPS 通过Jupyter Notebook/Jupyter Lab运行Python代码(或者其它Jupyter Notebook支持的语言) 通过远程桌面软件(如VNC等)访问云主机或VPS GUI环境 有没有意识到, 云主机或VPS GUI环境访问是使用时的一大”掣肘”. 主要有以下几点: 远程桌面软件不给力, VNC Sucks, 无论是商业版本的VNC(如RealVNC), 还是开源版本的VNC(如TigerVNC); 无论是Vinagre/AnyDesk/Ammyy Admin/TeamViewer, 还是号称”最好用”的NoMachine, 个人均有用过, 体验均不太好. 远程桌面软件, 存在滞后, 是个绕不过的”坎儿”. 你可以在本机虚拟机上装个远程桌面软件服务端, 然后本机装个客户端, 连上试下体验. 不说了, 请自行体验(如果你还感受不到, 可以同样的在本地虚拟机中装个Jupyter Notebook并运行, 然后在本机浏览器中访问Jupyter Notebook, 对比下体验. 很神奇). 拜托, 这还是本机直连环境, 不是外网啊. 并非所有人都是Posix(Unix/Linux/MacOS) Geek, 也并非所有人都是VIM/Emacs党, CLI(命令行)爱好者. 对于IDE “重度依赖者”而言, 从IDE切换到VIM, 确实是件”头疼”的事儿. 工具, 顺手即可, 不必较真. 与时俱进, 时代在变, 软件和操作系统应该为人服务, 而不是人适应机器. 给云主机或VPS装个Cloud IDE, 有何不可? 云主机或许, 你还有着更深的疑虑. 为何要有自己的云主机或VPS? 身在大天朝的攻城狮们, 肯定会毫不犹豫的回答你, “科学上网”, “天天向上”. 天朝的GFW, 真的是”Great Firewall”, 她可是会学习的哦, 她很聪明, 请不要做些不理智的事儿! (如果你还没感受到, 请看下你购买的VPN, 现在能用的还有几个) 除了科学上网之外, 你可能还需考虑以下几点: 网速问题, 大天朝内, 普通百姓家里大多数装的是电信百兆宽带, 电信1OOMbps, 即12.5MB/s, 也就是你家里的百兆带宽, 全速跑满也只有12.5 MB/s. 而云主机或VPS, 一般标配千兆口(Gbps), 也就是说, 你的云主机或云主机或VPS可以跑到125MB/s. 理论上, 你的云主机或VPS网络与你家里网络相比, 10:1, 这还只是理想情况. 现实情况是, 你家里的网络, 可能最高能达到6-8MB/s (比如鄙人家里, 电信百兆宽带, 最高能达到5MB/s, 无语中……); 而你的云主机或云主机或VPS, 一般都能跑满带宽(除非你遇到超卖的商家, 那鄙人也无能为力). 这网速悬差, 意味着什么? 意味着同样的工作, 假如能在云主机或云主机或VPS进行, 效率提升至少10倍. (如果你真的感觉SSH与VIM让你很低效, 请尝试下推荐小节中的Cloud IDE再说) 1 Byte = 8 bit, 12.5 MB/s = 100 Mb/s (即100 Mbps, 小p代表per, 每秒传输100Mb数据), 还有什么问题吗? 资源问题, 比如Golang, 比如Github, 比如Rust, 比如Docker, 比如k8s …… 列表很长, 不详细列出来了, 自行体会即可. 所以你身边的同事, 早早用上了自己的云主机或VPS, 除了科学上网外, 他们还经常在上面挂个博客. 云主机或VPS比较适合开发人员, 有多少次, 你想认真地训练个模型, 调个参数(超参数调优), 把任务放到公司服务器上跑, 第二天发现任务早早地被运维”干掉了”, 理由是资源占用; 又有多少次, 你想在自己PC上, 验证下新算法, 奈何本机资源限制(如8G内存, 伤不起), 又或者任务刚跑到一半, 被你女盆友强制关机了, 理由是PC噪音加灯光”刺眼”, 抑或任务跑到第二天上班了还没结束, 只得隐忍作罢. 类似这样的例子, 还有很多, 不详细列了. 说这么多, 主要有两点: 1. 本机PC环境, 容易受到不可抗拒因素影响, 最重要的原因是你无法保证你的PC长时间不断电; 2. 即使是公司的测试集群, 测试主机, 也是公司的, 不属于你, 无法满足个人进一步的开发与调试. 所以, 你需要个人的云主机或VPS, 任务尽管放到后台跑, 不要操心太多. 算法训练, 任务迭代又不占用本机资源, 美哉! 效率问题, 在细述这个问题前, 我希望你把自己的开发环境搬到云主机或VPS上来, 再来谈效率问题. 假定你在自己的云主机或VPS上搞好了开发环境(如果你嫌SSH, VIM以及FTP难用, 请尝试下推荐小节中的Cloud IDE), 你现在可以 以千兆带宽下载数据集(或模型, 或其他文件), 对于要科学上网才能下载的数据集(或模型), 现在你可以几秒钟, 或者几分钟搞定, 而不必苦等几个小时, 甚至是老半天 享受代码提交(或git clone)速率提升的便捷, (通常你的代码提交至Github), 现在你在云主机或VPS上提交代码(或git clone), 瞬间”6得飞起”. (假如你的云主机或VPS节点在北美, Github主力节点也在北美, 那效率真是绝了) 享受”云端”人生, 你的云主机或VPS, 维护不用操心太多, 所有的开发, 调试, 均可以在”云端”进行 享受”无忧”人生, 通常对于算法人员而言, 漫长的模型训练, 迭代, 超参数调优, 特征工程(最主要的是这些过程是不断反复的, 泪啊), 很花时间, 所以时间”分秒必争”. 现在, 你可以将很费时任务训练放到云主机或VPS后台跑, 然后封装下Web接口, 时刻监视每一项重要的超参数. 这生活, 美滋滋! 更加专注, 是时候和”踌躇不已”的自己说再见了, “云端”主机, 让你摆脱束缚, 无畏无惧. 非朝内云主机(或VPS)让你的生活更完美! Non-Chinese 云主机(或VPS) Make Your Life Complete! 投资自己, 请勿吝啬. 无论你是身在大厂也好, 还是小厂也好, 在自己没有真正变得不可或缺时, 请不要停下投资自己的脚步! 举个简单例子, 比如你在Vultr月付5美刀购入云主机或VPS用于科学上网, 5美刀, 约30~40块钱, 在魔都不过一顿饭钱(当然你要吃好可能要多花点), 但是这一顿饭钱, 可以让你享受一个月自由网络, 摆脱束缚, 很值. 投资自己, 绝不妥协! 读到这里, 希望对你有所触动, 假如你身在大天朝, 一台非朝内云主机或VPS真的可以改变你的生活, 小小一台云主机或VPS, 确实能给你带来深远影响, 最重要的是它可以改变你思考的方式, 让你变得更加专注, 更加睿智, 更加无畏无惧!可能下一个问题你会问, 有什么好的云主机或VPS推荐吗? 看你个人需要如果你需要在云主机或VPS上搭建科学上网环境, 可以考虑搬瓦工, Vultr, 或者Gigsgigs Cloud, 科学上网首选.如果你已经能够科学上网, 你想要台备用的云主机或VPS, 用于个人其它需求(比如外贸,跨境电商等), 可以考虑Dream Host, 外贸WordPress/PHP建站首选, 在跨境电商外贸网站托管业界很有口碑; 或者, Liquid Web, 流量给的很足, 对于流量大户, 很有诚意. 对于大数据开发人员而言, 或者算法开发人员而言, 小则几GB数据集, 通常有时需处理上百GB数据集, 云主机或VPS流量很关键, 因为它关系到你是否能”高兴地玩耍”!对于云主机或VPS而言, 通常北美的流量比亚太流量便宜, 比如北美流量$0.01/GB, 1TB流量大概5美刀左右(包含出栈和入栈流量, 所以不是10美刀左右), Liquid Web 低配版每月10TB流量, 两年年付计划每月$15, 真的很良心. (1TB流量按$5.12算, 10TB流量$51.2) 推荐以下是个人使用过的几款可以运行在浏览器中的Cloud IDE. 如果你还有更好的Cloud IDE, 欢迎补充. 以下Cloud IDE在云主机或VPS安装部署时,请确保云主机或VPS已开启IDE对应运行端口, Amazon AWS, Vultr等供应商需要手动开启其它端口. Cloud 9Amazon AWS云端IDE, Cloud 9确实不错, 如果你曾用过, 或许你也想在自己云主机或VPS上装个Cloud 9. 不仅你想, Cloud 9团队也想更多的开发人员使用Cloud 9. 于是, Cloud 9官方团队在Github上放出了Cloud 9 SDK源码, 方便广大开发人员”自给自足”. Cloud 9支持断点测试, Debug调试, 支持终端, 支持浏览器预览, 内部集成了版本控制功能, 如下图所示, 左下方为Git提交的Log View, 对开发人员特别友好. 最让我感到”惊艳”的一个功能是, Cloud 9提供了Process List功能, 你可以不用Shell终端查看云主机或VPS所有后台运行进程, 不仅如此, Cloud 9还提供了Kill与Force Kill两种选项终止进程. Cloud 9安装, 参考指令如下:1234567$ git clone https://github.com/c9/core.git c9sdk \ &amp;&amp; cd c9sdk \ &amp;&amp; scripts/install-sdk.sh$ # Cloud 9安装成功后, 键入以下指令开启服务, Cloud 9默认端口为8181$ # 可以通过以下--port参数指定自定义端口, --auth后为用户名与密码$ node server.js --port 8181 --auth User-Name:Password然后在浏览器中键入 http://你云主机或VPS的公网IP:8181 即可访问Cloud 9官方一键安装脚本, 请移步至这里Cloud 9官方源码编译安装, 请移步至这里 说完了优点, 简单说下Cloud 9不足之处: 首先, 支持语言相对较少, Cloud 9默认仅支持Python, Go, PHP, JavaScript语言, 其它语言可能需要安装插件. Cloud 9代码自动补全功能, 相对简单, 远没有IntelliJ IDEA/Eclipse/Visual Studio强大; 源码跳转, 可能需要插件支持. 个人感觉Cloud 9比较适合Posix(Unix/Linux/MacOS)极客, VIM/EMACS党, 以及CIL爱好者. 对于习惯了IDE的代码补全, 源码跳转的开发人员而言, Cloud 9有些类似于增强版的Sublime (终端, Debug调试, 浏览器预览, 版本控制支持等功能, Sublime添加插件也能实现) 类VS Code产品有没有可能将微软开源的VS Code移到浏览器中, 在浏览器中享受”云端”便捷生活? 答案是肯定的, 类似的产品有: Eclipse Che (可自行部署, 也可使用Red Hat托管的Eclipse Che) Eclipse Theia 其它基于VS Code封装的云IDE (比如腾讯云的云代码编辑器, 国内貌似不止腾讯云, 还有一众Sass服务商将VS Code做成商业化、定制化的云IDE) 这些产品, 本质上将微软开源的VS Code进行封装, 将VS Code GUI功能移到了浏览器端. 云上主机开启VS Code服务端进程, 本地浏览器端开启VS Code客户端进程, 通过HTTP及REST进行通信. 这些产品, 通常使用非常流畅, 有时给人一种运行于本地环境的错觉. 如需自行部署, 前提是得有一台云主机(或VPS), 比如阿里云云主机还不错, 下面以Eclipse Theia为例, 进行私有化部署. 源码安装, 指令参考如下: 12345678$ # 首先拉取源码$ git clone https://github.com/eclipse-theia/theia$ # 也可自定义安装, 如在package.json文件中添加插件依赖或其它自定义依赖等$ yarn # 安装依赖$ yarn theia build # 编译、打包、构建应用$ # 运行, 默认端口为8080, 可以通过--port参数指定自定义端口$ # /my-workspace为工作空间目录, 可自行指定$ yarn theia start /my-workspace --hostname 0.0.0.0 --port 8080 然后在浏览器中键入 http://你云主机或VPS的公网IP:8080 访问即可. 更多细节, 请参考官方文档 Jupyter NotebookJupyter Notebook, 可以让你在浏览器中编写并运行Python代码, 不多介绍了, Python攻城狮必备神器. Jupyter Lab增强版的Jupyter Notebook, Jupyter Lab外观上更像一IDE. 其它如果你喜欢折腾容器(docker, k8s等), Eclipse Che是个不错的选择. 其它Cloud IDE, 如Eclipse Orion, Eclipse Dirigible等也可考虑. Enjoy玩的愉快, 不谢! “等下, 你的Cloud 9, Jupyter Lab以及VS Code, IP均为公网IP”. 呀, 被你发现了呢? 是时候开启你的传奇时刻了, 请让世界遇见更美好的你!]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Cloud IDE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[站点导航 (免查找与搜索, 你想要了解的都在这里 !)]]></title>
    <url>%2Flife%2Fguide%2F</url>
    <content type="text"><![CDATA[本人目前专注于: Deep Learning &amp; Machine Learning (算法) Big Data (大数据) 个人对于Java 8(及后续版本)新增语言特性的几点看法 点击上方链接, 直达站内博文 (免去费时查找与搜索, 你想要了解的都在这里, 比如查看本站点所有与大数据相关博文, 请点击上方Big Data链接即可).]]></content>
  </entry>
  <entry>
    <title><![CDATA[Ambitious Java Evolving系列之ZGC篇]]></title>
    <url>%2Fambitious-java%2Fzgc%2F</url>
    <content type="text"><![CDATA[为何写这个系列的笔记? Java 11在GC上做了很多优化, 比如新引入的ZGC(Z Garbage Collector), 可拓展、低延迟. ZGC作为一种新的GC, 可运用于堆内存(大小可以从及KB到TB级别, 对你没看错, TB级别), 作为一并发垃圾回收器, ZGC可保证应用延迟不会超过10毫秒, 即便是堆内存占用很大(如TB级别)情况也适用, ZGC很容易调优. 引入原因随着现代硬件技术(内存、磁盘、CPU等)的发展, 低延迟、高吞吐应用已不再是奢望, 对于广发Java程序员而言, 一直都希望Java能有个低延迟、高吞吐的垃圾回收器. ZGC延迟不超过10毫秒, 相对于其它垃圾回收器, Stop-the-world Pause较少, 前景诱人. ZGC特点 ZGC作为一并发垃圾回收器, 可以并发进行内存标记、内存拷贝以及重分配. ZGC含有并发引用处理器, 意味着开发人员可以添加任意类型引用(如软引用、虚引用、弱引用及Finalizer等), 无需过多地担心GC Pause. ZGC使用Load Barriers, 与其它HotSpot GC使用Store Barriers不同, ZGC使用Load Barriers. Load Barriers可用于追踪堆内存使用情况, 不同的Load Barrier使用有不同的标色指针, 以便当线程运行时允许ZGC进行并发操作, 如对象重分配或重分配集选择等. 基于Region的垃圾回收器, 与G1 GC相比, ZGC更加灵活(如配置大小及Schema等), 更适合处理较大对象的内存分配与回收. 支持NUMA架构, ZGC含有支持NUMA架构的内存分配器 单代GC, ZGC支持部分内存合并(Compaction), ZGC在内存回收与重分配方面非常高效, 高性能. 缺点在于ZGC目前仅支持Linux/x64位架构, 其它架构和平台的支持会在未来版本中添加. ZGC堆内存ZGC将内存分成不同的Region, 这些Region也称ZPage, ZPage可动态创建和销毁, 可动态扩容(以2MB为单位, 动态扩容这点与G1 GC存在区别). ZGC堆中按Region大小可分为以下三类: Small(2MB), 较小Region Medium(32MB), 中等Region Large(N * 2MB), 较大Region ZGC堆中可有不同大小的Region, 其中中等Region及较大Region内存是连续分配的, 示意图参考如下: 与其它GC不同, ZGC堆中Region物理内存可以映射成较大堆内存地址空间(也可包含虚拟内存), 有助于预防内存碎片问题. 对于多数垃圾回收器而言, 通常JVM需要进行多项GC周期, 释放内存以便获取连续内存空间, 如果内存不够, JVM会由于OOM报错而Shut Down. 但对于ZGC而言, 并不会出现这种问题, 因为物理内存会映射成更大的地址空间, 分配连续内存空间不是问题. ZGC中的GC阶段ZGC的GC周期主要包含以下三个阶段: Pause Mark开始阶段 Pause Mark结束阶段 Pause 重分配开始阶段 第一阶段, Pause标记开始阶段, ZGC从GC Root进行溯源、标记对象, 包括遍历可达对象并进行标记, 该阶段是ZGC中GC工作最密集的阶段之一. 接下来进行同步, 该过程将中止(Pause)大概1毫秒左右, ZGC开始进行引用处理并进行清理, 包括如重分配集选择(Relocation Set Selection), 标记需要合并的Region等. 最后一个阶段, Pause重分配阶段, 触发实际的Region合并, 从GC Root重新扫描遍历, 于重分配集中并发进行对象重分配. 其中Pause Mark开始阶段, 也会Remap还存活的数据(Live Data). ZGC中标色指针标色指针, 也是ZGC一大特色之一, 通过标色指针, 方便ZGC查找、标记、定位以及Remap对象. 但该特性目前并不支持x32位架构机器. 实现标色指针需要虚拟地址标记(可以通过硬件、操作系统或者软件实现), 示意图参考如下: 如上图所示, 该64位对象引用可分为以下几个部分: 18比特未使用, 保留为后续使用 Finalizeble占1比特, 与并发引用处理相关, 标记仅可通过Finalizer访问的对象 Remapped占1比特, 标记位, 并不指向重分配集 Marked1占1比特, 用于标记对象 Marked0占1比特, 用于标记对象 42位对象地址, 可解决4TB地址空间映射问题 运行ZGC时, 会使用很多虚拟内存空间, 主要原因在于Heap间多映射导致, 如指定对象与标色指针在虚拟内存中如何存储等. ZGC调优主要是一些JVM参数调优, 如设置最大的并发线程数(ZGC作为一并发垃圾回收器, 并发线程数需设置合理), 启用较大ZPage, 启用Huge Page, 以及启用NUMA支持特性等 1234$ java -XX:ConcGCThreads=&lt;some-number-you-set&gt; \ -XX:+UseLargePages \ -XX:+UseTransparentHugePage \ -XX:+UseNUMA 用例如何使用? 由于ZGC目前仅支持Linux/x64位架构, 所以你需要一台x64位架构的Linux主机以及JDK 11. 安装指令参考如下: 123$ hg clone http://hg.openjdk.java.net/jdk/jdk$ cd zgc &amp;&amp; sh configure --with-jvm-features=zgc$ make images 测试代码, 参考如下: 12345class BonjourZGC &#123; public static void main(String[] args) &#123; System.out.println("Bonjour from the ZGC!"); &#125;&#125; 启用ZGC并运行代码 123$ java -XX:+UnlockExperimentalVMOptions -XX:+UseZGC BonjourZGC$ # 或者启用GC日志$ java -XX:+UnlockExperimentalVMOptions -XX:+UseZGC -Xlog:gc:YOUR-LOG-NAME.log* BonjourZGC]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>JVM And JVM Languages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ambitious Java Evolving系列之Project Amber篇(四)]]></title>
    <url>%2Fambitious-java%2Famber-enum%2F</url>
    <content type="text"><![CDATA[为何写这个系列的笔记? Project Amber对Java中枚举进行了强化, 如可以在枚举中添加类型变量(或泛型)以及更加完善的枚举类型检测. 这些改变, 意味着可以使用泛型枚举, 在枚举常量中增加状态和行为, 而不必想之前那样考虑由于泛型需要对枚举使用类进行重构. 语法糖首先, 简单回顾下Java中的枚举. 以下是一段简单的枚举代码: 1enum Size &#123;SMALL, MEDIUM, LARGE&#125; 通常上面这段枚举代码会被编译成以下Java源码: 123456789101112131415161718192021222324252627282930// 每一个用户定义的枚举均隐式继承了 `java.lang.Enum` 类final class Size extends Enum &#123; public static final Size SMALL; public static final Size MEDIUM; public static final Size LARGE; private static final Size $VALUES[]; static &#123; // 静态初始化 SMALL = new Size("SMALL", 0); MEDIUM = new Size("MEDIUM", 1); LARGE = new Size("LARGE", 2); $VALUES = (new Size[] &#123; SMALL, MEDIUM, LARGE &#125;); &#125; public static Size[] values() &#123; return (Size[]) $VALUES.clone(); &#125; public static Size valueOf(String s) &#123; return (Size) Enum.valueOf(Size, s); &#125; private Size(String s, int i) &#123; super(s, i); &#125;&#125; 从以上这段代码, 也可以看出, Java枚举不过只是语法糖而已, 编译器将对用户定义的枚举进行构造时, 需继承java.lang.Enum类来构建一个新类, 在新类中增加成员、方法以及初始化器. 访问规则强化版的Java枚举可有自己的状态和行为. 先来看段简单的Java代码: 12345678910111213141516171819202122232425262728293031323334353637enum Size &#123; SMALL(16, 11), MEDIUM(31, 21) &#123; int number = 10; // MEDIUM 中特定方法 int getSize() &#123; return length + width; &#125; &#125;, LARGE(36, 23) &#123; // 重写Size枚举中的 `toTextString()` 方法 @Override public String toTextString() &#123; return "LARGE"; &#125; &#125;; int length; int width; Size(int length, int width) &#123; this.length = length; this.width = width; &#125; int getLength() &#123; return length; &#125; int getWidth() &#123; return width; &#125; public String toTextString() &#123; return length + " x " + width; &#125;&#125; 目前对于强化版的Java枚举而言, 一个枚举常量可以访问: 所有枚举常量中的通用状态和行为 重写方法 但不允许访问某个特定枚举常量的状态和行为. 换句话说, 上面这段代码中, 如果你在某个方法中访问特定枚举常量MEDIUM中的number和getSize()方法时, 编译报错, 代码无法正常运行. 123// 报错, 无法正常通过编译System.out.println(Size.MEDIUM.number);System.out.println(Size.MEDIUM.getSize()); 主要原因在于MEDIUM枚举常量创建了一个匿名类并重写了Size枚举中方法, 并且该枚举常量仍被Size类型变量所引用. 假定对上面的Java源码使用继承重构如下: 123456789101112131415161718192021222324class SizeMeasurement &#123;&#125;class Small extends SizeMeasurement &#123; String text = "Small";&#125;class Medium extends SizeMeasurement &#123; public int getLength() &#123; return 6666; &#125;&#125;class Large extends SizeMeasurement &#123;&#125;enum Size &#123; SMALL(new Small()), MEDIUM(new Medium()), LARGE(new Large()); private SizeMeasurement mrs; Size (SizeMeasurement obj) &#123; mrs = obj; &#125; SizeMeasurement getSizeMeasurement() &#123; return mrs; &#125;&#125; 类似地, 不能访问某个特定枚举常量的状态和行为, 如 1234567class SizeTest &#123; public static void main(String[] args) &#123; var large = Size.LARGE; // 报错, 无法正常通过编译 System.out.println(large.getSizeMeasurement().getLength()); &#125;&#125; 如何解决这个问题呢? 强化版的Java枚举, 引入了泛型(或类型变量). 泛型枚举现在, 使用泛型, 对以上的枚举代码重构如下: 12345678910111213141516171819202122232425enum Size&lt;T extends SizeMeasurement&gt; &#123; SMALL(new Small()), MEDIUM(new Medium()), LARGE(new Large()); private T mrs; Size (T obj) &#123; mrs = obj; &#125; T getSizeMeasurement() &#123; return mrs; &#125;&#125;class SizeMeasurement &#123;&#125;class Small extends SizeMeasurement &#123; String text = "Small";&#125;class Medium extends SizeMeasurement &#123;&#125;class Large extends SizeMeasurement &#123; public int getLength() &#123; return 6666; &#125;&#125; 现在, 重新运行下面这段测试代码, 能正常编译并运行. 123456class SizeTest &#123; public static void main(String[] args) &#123; var large = Size.LARGE; System.out.println(large.getSizeMeasurement().getLength()); &#125;&#125;]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>JVM And JVM Languages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LevelDB学习手札之优化小节]]></title>
    <url>%2Fnosql%2Fleveldb%2Ftuning%2F</url>
    <content type="text"><![CDATA[LevelDB学习手札之LevelDB性能调优篇. Level File可以参考下图, LevelDB主存储为一系列Level级别的SST(Sorted String Table, 这些SST文件通常以.sst后缀结尾但后续可能会改为以.ldb后缀结尾, 为避免与微软之前提出的.sst后缀文件格式冲突), 这些SST文件的下一层Level通常是上一层Level的10倍大小, 最顶层Level中Record无序, 随着后续的数据拷贝、排序及Compaction, 下一层Level的SST数据开始有序. 这种写放大操作, 在LevelDB中可视为提高性能的一种Trade-off, 优点在于提高了写速度而无需基于索引更新避免中断, 而传统的B树索引当树均衡时需重写数据. 调用write()方法时, 数据首先写入memtable(Skip List结构), 并发写入日志文件落地到磁盘(容错需要, 若后续应用故障可进行数据恢复), 当日志文件达到4MB大小(可由write_buffer_limit参数设置)后, LevelDB开始写入新的Log并处理memtable, 此时内存中将保留俩数据结构: imm作为不可变类型继续写入以及后台线程在Level 0拷贝的SST文件. 为有效管理这些持久化文件, 会写入一Manifest文件, 该文件记录了Key键范围及每项SST文件level, 每当产生新的SST文件或Compaction线程合并文件并推送至以下一level时, 该Manifest文件会新增一项数据记录. 读自上而下当调用Get检索Key键时, 主要步骤参考如下: 首先扫描当前memtable的Skip List (如果Key键找到可以退出) 扫描imm的Skip List, 检测是否为空, 当数据刷写至磁盘时该跳表并不为空 (如果Key键找到可以退出) 检测Manifest文件, 判定Key键是否在已有Level File文件中Key值范围内 (可能在也可能不在) 如果候选Level File没有缓存, 则打开候选Level File文件 如果使用了过滤策略, 通过过滤器判断Key键是否在候选Level File文件中 Level File索引(Index)可用于判断文件是否包含囊括目标Key键范围的Block (可能包含也可能不包含) 如果Block包含目标Key(而非Block Cache), 从候选Level File中读取该Block 顺序化遍历该Block中KV键值对, 读取目标Key对应Value值 (可能存在没找到情形) 由于KV键值对长度任意, 所以不能通过计算偏移值方式进行定位, 基本上所有数据读写操作须经过Level File, 缓存及过滤器(如Bloom Filter等)有助于数据查找与定位. 删即写SST文件涉及从上而下, 不同级别level的数据拷贝、排序以及Compaction, Key键的删除与之类似, 自上而下. 与Tree Index不同, 实际上并不会移除Key键, 相反删除意味着一种写入, 对同一Key写入一份副本并包含特定的Marker(标记)告知该Key键数据已被删除. 布隆过滤器LevelDB底层本身做了很多优化措施, 若通过使用过滤策略判定读取的给定Key键是否存在于候选Level File中, 由于Level File中存在一系列不同范围Key, 若能通过使用过滤器(如布隆过滤器), 便可快速查找、定位(如每次打开文件时会缓存Filter数据, 提升整体检索效率, 无需读取索引或扫描Blocks). 布隆过滤器使用示意图如下: 布隆过滤器通过组合使用一些列简单而快速的哈希函数避免哈希碰撞概率, 组合的哈希函数写入对应结果值同一Bitmask. 注意布隆过滤器非哈希表, 该Filter并不会处理冲突(须由其它LevelDB数据结构处理Key值冲突). 布隆过滤器可以保证没有假负(False Negative, 被模型预测为负的正样本), 即若Key键不存在, 则绝对不存在; 若Key键存在, 其它Key可能含有相同序列的Hash. 通常合理修改Key键对应Bit数或改进Filter算法, 可以提升算法整体性能, 缺点在于增加了存储开销(要存储Filter数据). 假定目标Key键百分之百在数据库中, 没必要使用布隆过滤器. LevelDB并不关心用户使用何种过滤器, 仅提供一Hook指定FilterPolicy对象, 可以通过实现该接口编写自定义Filter, 也可使用NewBloomFilterPolicy提供的默认Filter. 如果自定义比较器认定某部分Key乱序, 不能使用默认过滤策略. 也可参考其它优化组件, 如Basho技术团队推出的Riak Server使用LevelDB的Erlang封装eleveldb, eleveldb包含改进的Bloom Filter(Basho团队称该Filter占用更少存储空间,仅有0.05%假负率, 而Google版本LevelDB假负率为1%), eleveldb的布隆过滤器可以用于替标准LevelDB中的布隆过滤器. 选择性缓存LevelDB可以通过将ReadOptions中的fill_cache flag参数为false, 绕过缓存. 缓存虽好, 但某些业务场景可能要求禁止刷新当前缓存. 可以参考以下代码设置缓存大小, 代码中缓存为读缓存, 适用于读远大于写场景. 123456789leveldb::Options options;// 100MBoptions.cache = leveldb::NewLRUCache(100 *1048576); leveldb::DB* db;leveldb::DB::Open(options, name, &amp;db)// Do Some Work// Then Clean Updelete db;delete options.cache; 快照通常数据库内部使用的Key键包含用户定义Key、Flag值以及Snapshot Number, Flag值表明是数据Key键还是待删除Key; 快照数字在写的时候可以保证并发读, 对Key值遍历时可有效避免其它线程更改(Delete或重写Key键等). 快照可通过ReadOptions对Get或Iterator等读操作产生影响: 12345678leveldb::ReadOptions options;// Save before some workoptions.snapshot = db-&gt;GetSnapshot();// 增删Key键, 相关操作代码实现略leveldb::Iterator* iter = db-&gt;NewIterator(options);// 手动清除delete iter;db-&gt;ReleaseSnapshot(options.snapshot); 尽管GetSnapshot应返回与删除相关的数据库状态对象, 如果传入Snapshot Number组成读时使用Key键, 每次新写或批量写入将增大该数字, 而读时检索的实际Key键及快照后续并不可见. 快照作为一短期行为, 适用于数据库当前会话. 目前并不存一种安全而有效的方法在持久化快照于磁盘同时又能保证被后续应用所使用. 配置调优以下LevelDB配置(这些配置可参考LevelDB::Options)对性能调优存在重大影响: write_buffer_size, 默认4MB, 可以适当调大, 当memtable写入磁盘时可能产生阻塞, 如果imm仍在写而当前Buffer已经满了, 可能会产生延迟 max_open_file, 默认为1000, 如果Server上数据库很多, 可以适当提高该参数值, 允许缓存更多的level File打开文件句柄, 避免文件开启、关闭开销 block_cache, 该指针常用于缓存NEWLRUCache创建对象, 默认8MB block_size, 每项Block用户数据大小, 默认4KB, 影响level table索引(每项Block对应一Index Entry), 如果业务数据中存在很多Key键大于4KB, 可以适当修改. 该参数也可用于I/O刷写, 若参数值设置过大可能会导致数据库容易受OS Crash影响而造成数据丢失 block_restart_interval, 默认值为16, 若数据中存在很多顺序化Key且这些Key很少变更, 可以适当修改. 该参数也可视为写入新Key的Checkpoint Interval filter_policy, 默认为NULL, 可以通过使用NewBloomFilterPolicy创建过滤策略, 使用过滤策略虽增加存储开销(磁盘及内存开销), 但优化了Key键查询.]]></content>
      <categories>
        <category>Distributed System</category>
      </categories>
      <tags>
        <tag>LevelDB</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ambitious Java Evolving系列之Project Amber篇(一)]]></title>
    <url>%2Fambitious-java%2Famber-raw-string-literals%2F</url>
    <content type="text"><![CDATA[为何写这个系列的笔记? 随着JDK 12(2019年3月)的推出, Java终于迎来了”生”字符串字面量(Raw String Literals). 什么是”生”字符串字面量? 简单来讲, 它大概长这样: 12345678// 此处只是举个例子, 实际开发环境中常用DOM生成工具String htmlHeader = `&lt;HTML&gt; &lt;BODY&gt; &lt;H1&gt;Add Raw String Literals&lt;/H1&gt; &lt;/BODY&gt; &lt;/HTML&gt; `; 为什么要新引入”生”字符串字面量? 123456789101112131415161718// 对于之前版本的Java, 上面的代码, 你可能会写成这样// 很繁琐, 需要将多行字符串拼接起来, // 如果拼接的字符串过长, 影响代码可读性以及可维护性String htmlHeader2 = "&lt;HTML&gt;" + "\n\t" + "&lt;BODY&gt;" + "\n\t\t" + "&lt;H1&gt;Add Raw String Literals&lt;/H1&gt;" + "\n\t" + "&lt;/BODY&gt;" + "\n" + "&lt;/HTML&gt;";// 或者, 在字符串相对简短的情况下, 使用换行和制表符整成一行代码, 如下// 但这样代码可读性非常差String htmlHeaderOneLine = "&lt;HTML&gt;\n\t&lt;BODY&gt;\n\t\t&lt;H1&gt;Add Raw String Literals&lt;/H1&gt;\n\t&lt;/BODY&gt;\n&lt;/HTML&gt;";// 本例还算好, 但如果存在转义字符呢, 如 &lt;H1&gt;\n Some Text Here \t More Text&lt;/H1&gt;// 字符串拼接后的代码将"不忍直视"// 类似的情况还有Java正则, 比如:String somePatternsHere = "(\\w)(\\s+)([\\.,])";// 简单的正则还好, 但如果正则很复杂, 同样面临一场"恶梦" 对于多行字符串拼接问题, Java之前做的并不出色, 如果字符串过长, 很容易造成”拼接地狱”问题; 类似的还有Java正则, 由于正则模式使用字符串表示, 如果正则过于复杂或转义字符很多, 将严重影响代码可读性以及可维护性. Java中”生”字符串字面量的出现, 有助于解决这些问题, 提高代码可读性以及可维护性. 用例“生”字符串字面量可广泛用于如JSON、XML(或类似的标记语言)文本、文件路径、数据库查询中. 比如数据库查询: 123456789101112// 简单的数据库查询, 使用"生"字符串字面量String queryText = ```SELECT 'product_sk', 'date_sk' FROM 'product_dim', 'date_dim' WHERE 'product_dim.effective_date' = 'date_dim.date' ```;// 而非像之前, 经典的Java写法, 多行字符串拼接String queryTextUsingOldJava = "SELECT product_sk, date_sk " + "FROM product_dim, date_dim " + "WHERE product_dim.effective_date = date_dim.date "; 比如, 文件路径: 1234// 文件路径, 使用"生"字符串字面量 String filePath = `D:\Path\To\Your\File`;// 而非经典的Java写法 (特别是Windows环境, 双转义符号很"优秀")String filePathWin = "D:\\Path\\To\\Your\\File"; 比如, JSON文本: 1234567891011121314151617181920212223242526272829303132333435// 假定有段JSON数据, 长这样// &#123;"department": &#123; // "id": "96111", // "team": &#123; // "stuff": [ // &#123;"name": "Emma Roberts", "age": "24" , "gender": "Female"&#125;, // &#123;"name": "Nia Roam", "age": "21", "gender" : "Female"&#125;// ] // &#125; // &#125;&#125;// 使用"生"字符串字面量, 将JSON数据存储于Java字符串中String json = ```&#123;"department": &#123; "id": "96111", "team": &#123; "stuff": [ &#123;"name": "Emma Roberts", "age": "24" , "gender": "Female"&#125;, &#123;"name": "Nia Roam", "age": "21", "gender" : "Female"&#125; ] &#125; &#125;&#125; ```;// 而非经典的Java写法String jsonUsingOldJava = "&#123;\"department\": &#123; \n" + "\"id\": \"96111\", \n" + "\"team\": &#123; \n" + "\"stuff\": [ \n" + "&#123;\"name\": \"Emma Roberts\", \"age\": \"24\" , \"gender\": \"Female\"&#125;, \n" + "&#123;\"name\": \"Nia Roam\", \"age\": \"21\", \"gender\" : \"Female\"&#125; \n" + "] \n" + "&#125; \n" + "&#125;&#125;"; 基本用法新引入的”生”字符串字面量并不会改变与Java之前传统的字符串字面量值间的交互. Java字节码并不会记录字符串常量是使用传统的字符串创建还是”生”字符串字面量创建. “生”字符串字面量与传统的Java字符串值均存于java.lang.String类的实例中. “生”字符串字面量在Java中定义如下: 1RawStringDelimiter &#123;RawStringCharacters&#125; RawStringDelimiter “生”字符串字面量支持Backtick(`符号)嵌套, 如下: 123456789// 双BackTick中文本可以包含单个BackTickString oneBacktickNested = `` Some Text Provided Here `other text ``;// 四BackTick中文本可以包含三BackTickString threeBacktickNested = ```` Some Text Provided Here ```other text ````;// 多BackTick, 类似, 略 ...... 为了更好地支持新引入的”生”字符串字面量, Java在java.lang.String中新增了一些方法, 如: 1234// 由于Oracle JDK中"生"字符串字面量还处于开发迭代中, // 以下方法可能会重构 (如重命名等)public String unescape() &#123; /** 略 */ &#125;public String escape() &#123; /** 略 */ &#125; 上面这两个方法有什么用呢? 主要用于Escape Sequence(如转义、分割符等)处理, 比如: 123456// 输出: (有换行) // Some // TextSystem.out.println("Some" + `\n`.unescape() + "Text");// 输出: Some\nTextSystem.out.println("Some" + "\n".escape() + "Text"); 多行文本Margin管理对于多行文本处理, 可能需要对齐、移除一些不必要的分隔符等. 为了更好地进行这些文本处理, Java在String类中新增了一些方法, 如align(), indent(), transform()等. align()方法, 主要用于多行文本对齐, 如: 1234567891011String yourText = `Your Text Here `;System.out.print(yourText.align());/* 输出 Your Text Here */ indent()方法, 主要用于指定多行文本的对齐间隔(如N个空格等), 如: 12345678910111213141516String yourText = `Your Text Here `;System.out.print(yourText.align().indent(4));/* 输出: (存在4个空格对齐) Your Text Here */ // 上面这行代码, 实际上也等效于System.out.print(yourText.align(4));// 也就是说, 调用`align()`方法时, 如果没有传入参数, 仅按照给定的多行文本默认对齐// 如果有传入参数, 多行文本对齐的空格数为传入的参数值 detab()与entab()是一对对称方法, detab()将制表符转换成空格, entab()方法反过来. 比如: 123456789101112// 下面这段多行文本按制表符对齐String yourText = `Your Text Here `;System.out.println(yourText.detab(1));/* 输出: (按1个空格对齐) Your Text Here */ transform() 方法, 对应Java源码, 参考如下: 1&lt;R&gt; R transform (Function&lt;String, R&gt; f) 主要用于对多行文本进行转换, 如: 123456789101112131415161718// 假定存在以下文本数据, 现在要将分割符'[ '移除// [ Forest - Fire, Drought// [ Oceans - Plastic Pollution, Human CallousnessString originalString = `[ Forest - Fire, Drought [ Oceans - Plastic Pollution, Human Callousness `;String str = originalString.transform(&#123; txt.stream() .map(s -&gt; s.map(String::strip)) .map(t -&gt; t.startsWith("[ ")? t.substring("[ ".length()): t ) .collect(Collectors.joining("\n", "", "\n")); &#125;);]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>JVM And JVM Languages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LevelDB学习手札之CRUD篇]]></title>
    <url>%2Fnosql%2Fleveldb%2Fcrud%2F</url>
    <content type="text"><![CDATA[LevelDB学习手札之基本概念与CRUD篇. 本文示例代码均采用Nodejs, 为何使用Nodejs? 第一, JS已经占领了浏览器(The Language by which your browser has been dominated); 第二, LevelDB支持脚本语言中, 貌似Nodejs是最快的(心疼Python五秒, 为何是五秒, 因为金鱼的记忆只有五秒, 别问我为何知道, French Guys Told Me That); 第三, JS程序员总有那么几天工作满载、负荷过重, 有时后端攻城狮不得不写一些JS代码. 编码格式LevelDB支持Binary形式的KV键值对, 可以通过keyEncoding与valueEncoding设置KV编码格式: 1234567// 可以使用任意 `Buffer.toString()` 允许的编码格式:// hex, utf8, ascii, binary, base64, ucs2 或 utf16levar options = &#123; keyEncoding: 'hex', valueEncoding: 'base64'&#125;;var db = level(dbPath, options); 也可指定JSON作为Value编码格式, 参考代码如下: 123456789101112131415161718192021222324var level = require('level');var path = require('path');var assert = require('assert');var dbPath = process.env.DB_PATH || path.join(__dirname, 'yourdb');var options = &#123; keyEncoding: 'binary', valueEncodinng: 'json'&#125;;var db = level(dbPath, options);db.put(new Buffer([1, 2, 3]), &#123;some: 'some json value'&#125;, function(err) &#123; if (err) &#123; console.error(err); &#125; db.get(new Buffer([1, 2, 3]), function(err, value) &#123; if (err) &#123; return console.error(err); &#125; assert.deepEqual(value, &#123;some: 'some json value'&#125;); console.log(value); &#125;);&#125;); 使用JSON编码格式, 好处在于可以存储和获取复杂JS对象, 无需开发者手动编码与反编码. 批量操作LevelDB允许开发者进行批量读写, 示例参考代码如下: 1234567891011121314151617181920var batch = db.batch();batch.put('key one', 'value one');batch.put('key two', 'value two');batch.del('key three');batch.write(function(err) &#123; if (err) &#123; console.error('batch operation failed:', err); &#125;&#125;);// 上面这段代码也可链(Chain)起来db.batch() .put('key one', 'value one') .put('key two', 'value two') .del('key three') .write(function(err) &#123; if (err) &#123; console.error('batch operation failed:', err); &#125; &#125;); 除了使用Fluent风格将API链起来, 还可选择使用数组(将批量操作传入一数组中)版本的batch(), 示例代码参考如下: 1234567891011var users = // 具体代码略var operations = users.map(function(user) &#123; // 通过`type`指明操作类型(put或者del等) return &#123;type: 'put', key: user.id, value: user&#125;;&#125;);db.batch(operations, function(err) &#123; if (err) &#123; console.error('error in user batch:', err); &#125;&#125;); 可读流可以通过以下代码从LevelDB创建一可读流(Readable Stream): 12345var stream = db.createReadStream();// 数据读取stream.on('some data', function(data) &#123; console.log('%s = %j', data.key, data.value);&#125;); 除了触发数据, 可读流还可进行下列操作, 参考代码如下: 1234567891011stream.once('end', function() &#123; // 数据读取完 console.log('no more data');&#125;);stream.once('close', function() &#123; // 关闭 console.log('stream closed');&#125;);stream.once('error', function(err) &#123; // 错误处理 console.error('stream emitted error:', err);&#125;); 可以参考以下方式指定数据触发的Key键范围: 123456789var assert = require('assert');var stream = db.createReadStream(&#123; gte: 'start key', lte: 'end key'&#125;);// 数据Key键在 start key 与 end key 之间stream.on('data', function(record) &#123; assert(record.key &gt;= 'start key' &amp;&amp; record.key &lt;= 'end key');&#125;); 限制返回Record条数, 参考代码如下: 123456789var assert = require('assert');// 假定仅对前10条Record感兴趣var stream = db.createReadStream(&#123; limit: 10 &#125;);var count = 0;stream.on('data', function(record)&#123; assert(++count &lt;= 10);&#125;); 使用可读流的一大好处在于可以获取一致性读快照, 这意味着任一Stream开始若进行后续写入或批量写入并不会影响该可读流, 示例代码如下: 1234567891011121314151617181920212223242526272829303132333435var assert = require('assert');var db = require('./db');var batch = [ &#123;type: 'put', key: 'key one', value: 'Value A'&#125;, &#123;type: 'put', key: 'key two', value: 'Value B'&#125;, &#123;type: 'put', key: 'key three', value: 'Value C'&#125;, &#123;type: 'put', key: 'key four', value: 'Value D'&#125;]var index = 0;db.batch(batch, function(err) &#123; var stream; if (err) &#123; console.error(err); &#125; else &#123; stream = db.createReadStream(&#123;gte: 'start key', lte: 'end key'&#125;); stream.on('data', onData); db.batch(batch.map(function(op) &#123; return &#123;type: op.type, key: key.key, value: 'value'&#125;; &#125;), function(err) &#123; if error(err) &#123; console.log(er); &#125; else &#123; console.log('Saved Batch replacing with other value, resuming'); &#125; &#125;); &#125;&#125;);function onData(record) &#123; console.log('read: %j', record); assert.equal(record.value, batch[index ++].value);&#125; SubLevel批量操作可以通过使用level-sublevel NPM模块按需对Key键分区, 而非手动创建Key, level-sublevel模块支持在多项sublevel上原子性批量更新. 安装命令参考如下: 123$ node install level-sublevel --save$ # 可以考虑安装 cuid NPM 模块生成随机唯一ID, 便于后续测试$ node install cuid --save 下面创建两个Database: 一个用于存储用户Record, 另一个用于存储用户消息. 123456789101112// sublevels.jsvar level = require('level');var path = require('path');var sublevel = require('level-sublevel');var dbPath = process.env.DB_PATH || path.join(__dirname, 'sublevels');var db = sublevel(level(dbPath, &#123;valueEncoding: 'json'&#125;));exports.base = db;// users 用于存储用户Record; messages 用于存储用户消息exports.users = db.sublevel('users');exports.message = db.sublevel('messages'); level-sublevel模块支持在多项sublevel上原子性批量更新, 如生成一条用户消息时希望原子性插入该消息至发送邮箱与接收邮箱, 脚本参考如下: 123456789101112131415161718192021222324252627282930var db = require('./sublevels');var cuid = require('cuid');exports.insert = insertMessage;function insertMessage(to, from, subject, body, callback) &#123; var id = cuid(); var message = &#123; to: to, from: from, subject: subject, body: body &#125;; var batch = [ &#123; type: 'put', key: id, value: message, prefix: db.messsage.sublevel(from).sublevel('out') &#125;, &#123; type: 'put', key: id, value: message, prefix: db.message.sublevel(to).sublevel('in') &#125; ]; db.base.batch(batch, callback)&#125; 钩子(Hooks)新建一Hook, 假定脚本名为sublevels_user_hook.js, 参考代码如下: 123456789101112131415var cuid = require('cuid');var db = require('./sublevels');var userChanges = db.base.sublevel('userchanges');db.users.pre(function(change, add) &#123; add(&#123; type: 'put', key: cuid(), value: &#123; when: new Date(), change: change &#125;, prefix: userChanges.sublevel(change.key) &#125;);&#125;); 激活该Hook并Include该模块至sublevels.js中: 12345exports.base = db;exports.users = db.sublevel('users');exports.messages = db.sublevel('messages');require('./sublevels_user_hook'); 用户更新, 编写一测试脚本(sublevels_user_log.js)查询用户更新: 12345678910var db = require('./sublevels').base.sublevel('userchanges');var email = process.argv[2];var userChanges = db.sublevel(email);userChanges.createValueStream().on('data', function(message) &#123; console.log('User Change: %j', message);&#125;).once('end', function () &#123; console.log('no more change');&#125;); 运行该脚本, 效果如下: 1234567891011121314151617181920212223242526272829$ node sublevels_user_log.js usr_one@dotnet.comUser Change: &#123; "when":"2014-10-08T12:19:43.154Z", "change":&#123; "key":"usr_one@dotnet.com", "value":&#123;"name":"Xavier","email":"usr_one@dotnet.com"&#125;, "prefix":["users"], "type":"put" &#125; &#125;User Change: &#123; "when":"2014-10-08T12:19:43.946Z", "change":&#123; "key":"usr_one@dotnet.com", "value":&#123;"name":"Xavier","email":"usr_one@dotnet.com"&#125;, "prefix":["users"], "type":"put" &#125; &#125;User Change: &#123; "when":"2014-10-08T12:19:44.555Z", "change":&#123; "key":"usr_one@dotnet.com", "value":&#123;"name":"Xavier","email":"usr_one@dotnet.com"&#125;, "prefix":["users"], "type":"put" &#125; &#125;no more changes]]></content>
      <categories>
        <category>Distributed System</category>
      </categories>
      <tags>
        <tag>LevelDB</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LevelDB学习手札之Key键迭代与搜索]]></title>
    <url>%2Fnosql%2Fleveldb%2Fsearch%2F</url>
    <content type="text"><![CDATA[LevelDB学习手札之Key键迭代与搜索篇. Key键迭代首先, 创建一些测试数据, 代码参考如下, 当然也可考虑对key之前值使用Slice模板, 但需要注意的是Slice仅有一项数据指针(假如Slice指向的值发生改变, Bug你懂的); 代码中使用WriteBatch不仅为批量写入需要, 还且有助于存储引擎优化文件写入. 123456789101112vector&lt;string&gt; words &#123;"Some", "Random", "Words", "For", "Test"&#125;;string prevKey;WriteOptions syncW;syncW.sync = true;WriteBatch wb;// C++11中Range风格遍历for (auto key: words) &#123; wb.Put(key, prevKey + "\tAdd Some Text"); prevKey = key;&#125;assert(db-&gt;Write(syncW, &amp;wb), ok()); LevelDB提供一迭代器Iterator, 每次使用Iterator时会获取一份LevelDB一致性快照, 进行遍历时会忽略更新. LevelDB向前遍历, 可以通过SeekToFirst()方法跳到第一项KV值, 代码参考如下: 123456Iterator* idb = db-&gt;NewIterator(ropt);for (idb-&gt;SeekToFirst(); idb-&gt;Valid(); idb-&gt;Next()) &#123; cout&lt;&lt; idb-&gt;key() &lt;&lt;endl; // 可以通过调用 `value()` 方法查看Value值 // cout&lt;&lt; idb-&gt;key() &lt;&lt; " " &lt;&lt; idb-&gt;value() &lt;&lt;endl;&#125; 向后遍历, 有些类似(如通过SeekToLast()方法跳到最后一项KV值等), 但效率不高. 123for (idb-&gt;SeekToLast(); idb-&gt;Valid(); idb-&gt;Prev()) &#123; cout&lt;&lt; idb-&gt;key() &lt;&lt;endl;&#125; Key键查找由于Get()返回Key键精确匹配值, 对于Iterator而言, 通常有些业务场景需通过Seek()方法对Key进行查找. 以下代码, 列出所有匹配给定前缀的Key: 1234567void listPrefixMatchedKey(Iterator* idb, const Slice&amp; prefix) &#123; cout&lt;&lt; "List all keys starting with " &lt;&lt;prefix.ToString() &lt;&lt;endl; for(idb-&gt;Seek(prefix); idb-&gt;Valid() &amp;&amp; idb-&gt;key().starts_with(prefix); idb-&gt;Next()) &#123; cout&lt;&lt;ibd-&gt;key() &lt;&lt;endl; &#125;&#125; 向后遍历, 有些复杂, 以下代码以向后遍历的方式列出所有匹配给定前缀的Key: 123456789101112131415void listBackwardsKeysMatched(Iterator* idb, const Slice&amp; prefix)&#123; cout&lt;&lt; "List all keys starting with " &lt;&lt;prefix.ToString() &lt;&lt; " backwards " &lt;&lt;endl; const string keyAfter = prefix.ToString() + "\xFF"; idb-&gt;Seek(keyAfter); if (idb-&gt;Valid()) idb-&gt;Prev(); else idb-&gt;SeekToLast(); for(; idb-&gt;Valid() &amp;&amp; idb-&gt;key().starts_with(prefix); idb-&gt;Prev()) &#123; cout&lt;&lt;idb-&gt;key() &lt;&lt;endl; &#125;&#125; 以下代码, 列出了给定范围内(不包括endKey)的所有Key: 12345678void listKeysBetween(Iterator* idb, const Slice&amp; startKey, const Slice&amp; endKey)&#123; cout&lt;&lt; "List all keys &gt;= " &gt;&gt;startKey.ToString() &lt;&lt; "and &lt; " &lt;&lt;endKey.ToString() &lt;&lt;endl; // 如需包含`endKey`, 将下面代码中小于号改为小于等于即可. for(idb-&gt;Seek(startKey); idb-&gt;Valid() &amp;&amp; idb-&gt;key().compare(endKey) &lt; 0; idb-&gt;Next()) &#123; cout&lt;&lt;idb-&gt;key() &lt;&lt;endl; &#125;&#125; 为了加快数据搜索效率, 有时需要对KV键值对做些相关性索引, 如常见做法有: 将相关Key与下一相关Key链起来形成一相关列表, 便于后续搜索匹配等. 123456789101112131415string nextKey;if (db-&gt;Get(ropt, firstKey, &amp;nextKey).IsNotFound()) &#123; return firstKey + " ** not found **";&#125;// 为了简化, 代码中使用箭头(-&gt;)将相关Key连接起来形成一文本string ret = firstKey;for (;;) &#123; string key = value.substr(0, value.find("\t")); if (db-&gt;Get(ropt, key, &amp;value).IsNotFound()) &#123; break; &#125; ret += " -&gt; " + key;&#125;return ret;]]></content>
      <categories>
        <category>Distributed System</category>
      </categories>
      <tags>
        <tag>LevelDB</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ambitious Java Evolving系列之Epsilon GC篇]]></title>
    <url>%2Fambitious-java%2Fepsilon-gc%2F</url>
    <content type="text"><![CDATA[为何写这个系列的笔记? Java 11新引入Epsilon GC, Epsilon GC也称No-Operation(no-op) GC, Epsilon GC并不会回收任何垃圾, 仅处理内存分配, 当可用的堆内存(Heap Memory)用尽时, JVM会立即Shut Down(停掉). Epsilon GC听起来很怪异, 对不对? 它又有什么用呢? 先回答第二个问题, Epsilon GC可用于测试、Benchmark应用的性能、内存使用、延迟及吞吐等, 以便后续进行性能调优. 引入原因现在回到第一个问题, 为什么引入Epsilon GC? 预测导向, 举个简单例子, 多数环保专家对”全球变暖”持肯定态度, 他们是怎么得出这个结论的? 只是因为最近几年大多数地区变热了吗? 还是他们会”穿越”, “穿越”到未来, 发现地球真的变成了”大火炉”. 现实情况是, “全球变暖”是他们的预测观点, 他们基于历史数据进行科学分析(如工业温室气体排放, 历年全球气温数据等)得出的结论. Java 11引入Epsilon GC也是类似目的, 开发者可以通过使用Epsilon GC预测应用性能, Epsilon GC可以在不回收已分配内存的情况下对Java应用程序的性能、内存使用、延迟以及吞吐等进行真实评估与测试. Epsilon GC特点Epsilon并不会清除未使用对象的堆内存, 仅进行内存分配. 当遇到JVM OOM时, 会立即关闭并抛出OOM错误, 如果启用Heap Dump, 抛出OOM错误后Epsilon会立即进行Heap Dump. Epsilon GC使用一种简单的、无锁的Thread Local Allocation Buffer(TLAB, 线程局部分配缓冲, 以线性化方式分配连续内存), 好处在于TLAB可以绑定使用已分配内存的Process. 由于Epsilon GC并不回收内存, 无需维护对象标记、对象合并(Compaction)、对象图(Graph)或对象拷贝等. 缺点在于Epsilon GC可能存在延迟Overhead, 当Epsilon进行分配内存时可能会有延迟Overhead问题, 比如分配内存过大或分配的内存Chunk过大等. 使用场景小结 场景一: 延迟相关场景假定你的Java程序每秒需要处理上千条消息, 在该种情况下即使一毫秒延迟也会对系统性能产生重大影响, 最糟糕的情况是你并不知道什么时候执行GC进行垃圾回收. 该种情况下, 建议使用Epsilon GC测试该程序, 因为此时Epsilon GC并不会进行垃圾回收, 通过分析日志, 可以定位到产生延迟的一些可能根源: 如与GC相关的GC Worker调度、GC周期、GC Barrier开销等, 或者与GC无关的如OS调度或编译器问题等. GC周期存在延迟Overhead, 影响吞吐, 可能影响因素有, 如堆内存大小、GC持续时间、Region大小、分配单元等. 此外, 系统Overhead也可能导致延迟Overhead, 与GC无关. 可以通过使用Epsilon GC(no-op GC), 来判定是GC相关的问题还是OS/编译器相关的问题导致应用性能问题. 场景二: 短时间运行作业假定你需要创建一个较短运行时间作业, 当退出程序时, JVM Shut Down, 所有的堆内存进行回收, 由于执行GC需要花费一点时间, 此时也可考虑使用Epsilon GC. 用例如何使用Epsilon GC, 以下是个小例子: 123456// Simple Hello Word 代码class BonjourEpsilonGCCase &#123; public static void main(String[] args) &#123; System.out.println("Bonjour From Epsilon GC Case One!"); &#125;&#125; 1$ java -XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC BonjourEpsilonGCCase 再来看个使用Epsilon GC进行内存压测的例子: 1234567891011121314import java.util.*;class MapTest &#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; testMap = new HashMap&lt;String, String&gt;(); int testSize = 1_000_000; for (int i=0; i &lt; size; i++) &#123; String testString = new String("Scala"); String ioStringValue = new String("zScalaRocks.io"); testMap.put(testString, ioStringValue); testMap.remove(testString); &#125; &#125;&#125; 1$ java -XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC -Xlog:gc* -Xmx40M MapTest 如果使用String池重构代码, 如下, 猜猜看会发生什么? 1234567891011121314import java.util.*;class MapTest &#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; testMap = new HashMap&lt;String, String&gt;(); int testSize = 1_000_000; for (int i=0; i &lt; size; i++) &#123; String testString = "Scala"; String ioStringValue = "zScalaRocks.io"; testMap.put(testString, ioStringValue); testMap.remove(testString); &#125; &#125;&#125; 1$ java -XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC -Xlog:gc* -Xmx40M MapTest]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>JVM And JVM Languages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ambitious Java Evolving]]></title>
    <url>%2Fambitious-java%2Fguide%2F</url>
    <content type="text"><![CDATA[本文采用先抑后扬的写作技巧, 可能会有部分读者不太喜欢, 迅速跳出, 本文没有任何贬低或负面的想法, 正如文末所言, 鄙人只是一个观察者, 一个乐于观察Java语言不断演变的Observer. 起由 最初主要是想写Java 8的一些新增语言特性, 记录下Java 8的学习笔记. 后来发现自己对这些Java 8的这些新增特性并不太”感冒”, 最终搁置了一段时间. Java 8新增语言特性, 主要参考如下: Lambda与函数式方法接口 Stream API / Parellel Stream API 并发API增强, 如CompletableFuture API 接口可有默认实现 Optional (为更好地避免空指针问题) 新增原子性容器, 如LongAdder、LongAccumulator等 其它一些API优化与改进, 比如Date API等 (部分日期相关的方法, 变得有点像Joda, 确实是件好事儿) 简单说下个人不太”感冒”的原因. 首先, Java 8中的Lambda与函数式方法接口、Stream API, 不过是Java对FP(函数式编程)的进一步”调情”后的结果, 一直以来Java对FP不断”调情”, 小动作不断. 即便是C++, 动作也比Java快很多, 如C++ 11(先于Java 8, Java 8于2014年发布)中率先新增了对FP的支持. CompletableFuture, 确实优秀, 但Scala、C#等语言早已有了Future/Promise(请注意此处的Future与Java 7及以前的Future并非同一概念). 接口可有默认实现, 到Java 8才出, 初看有点像”抄” Scala中的特质(Trait, 当然Scala的特质主要为Type Class而设计的, 特质的OOP特性不过是副产物而已). 但, 这终究不过是Java的”妥协”(Java 7及以前的接口中所有方法均为抽象方法, 对于小型项目还好, 但对于大型项目而言, 调几个接口而已, 还得实现一堆无关的抽象方法, 瞬间代码越千行, 然后你”很有成就感”与”自豪感”), Java 确实是经历过”痛与泪”, 才明白这条路确实可行. (毕竟, Java多年的接口、库、包、庞大的生态, 必然要经历过”痛与泪”, 才会妥协做出该抉择). Optional, Java到Java 8才想通. “或许避免空指针异常最好的方式是Haskell中的Maybe”, Scala很早就想通了, 于是很早就有了Option(Some/None, 分别对应Haskell中的Just和Nothing); 紧接着Kotlin、Rust、Swift等语言也有了自己对应版本的”Option”(或”Optional”, 可能名称有些小差异, 具体看对应语言实现, 本质上还是借鉴Haskell中的Maybe). 至于Parallel Stream API, 初看很像Java的一场”模仿秀”. Scala中的Collection(集合/容器), 有并行容器(如ParIterable, 包含ParSeq、ParSet、ParMap)与顺序化容器(如Iterable)之分, 最重要的是Scala中顺序化容器到并行容器, 有时仅需要调用.par即可完成. 于是Kotlin顺手”抄”了Scala, 然后你一边对Kotlin”大手称赞”, 一边数落Scala的难用. Java很聪明, 从Stream到Parallel Stream也做了很多优化与封装, 毕竟Java确实把核心给摸透了. 别误会, 在这里并不是说Scala比Java”优秀很多”. 只是这些年(14年及以前), 纵观下各大主流语言(比如C#、C++等), Java 8这些新增语言特性, 确实让人”不太感冒”, 即便是C++, 也变得更加Modern, 变得比Java更加”与时俱进”. 转折那为何突然又想写这个系列呢? 转折点在于Java 9的强化, 让我闻到了一丝”Java的野心”. Java 9 中的Flow API, 让我看到了Java试图将Reactive(响应式)原理引入到Java语言级别做出的努力. 或许那个”充满野心”的Java回来了, 不对, Java从诞生之初, 就一直充满”野心”, 比如Java诞生之初标榜的”编写一次, 到处运行(Write Once, Run Anywhere)”, 本来就代表Sun公司的野心. 或许这些年, Java并没有丧失自己的”野心”. 但Java 8以前这些年(14年以前), 除了JVM生态不断扩大外, Java语言本身, 并没有多大”侵入性”. Java从96年面世至今, 走过的这些年, 让人一直感觉Java就像个中年大叔, 不太喜欢激进与折腾, 不是吗? 这些年Java语言变得肥实了(多金, 无忧), 喜欢充当幕后的观察者. Java变了, 变得有些像静待无声的捕食者, 动静不大, 但”一击必杀”. 不太确定, 以后Java是否会将Reactive完全融入到Java语言级别中, 但我仍然闻到了Java静谧之下的一丝”野心”. 是的, Java的”野心”一直都在. 鉴于Java 9/10, 仅作为JDK的短期快速迭代版本, 我好奇地看了下Java 11及Java 12的一些变化, 作为笔记记录下来. 这个系列的博文, 主题实际上为Java的野心. 但”野心”这个词, 近些年伴随着华文语境的一些变化, 似乎成了一个贬义词, 贬义意味着不喜欢、厌恶. (“野心”, 中性词, 然而随着”野心家”、牺牲品舆论的不断放大, 中性词逐渐变得似乎有一丝贬义词的”味道”. 但不管舆论怎么带节奏, 该中性词依然还是中性词, 就像地球不会突然消失一样). 个人其实对于Java这些变化, 并没有多少反感, 相反, 我只是一个观察者, 一个乐于观察Java语言不断演变的Observer. 标题为Ambitious Java Evolving, 字面意思为”不断演变的、充满抱负的Java”, 引申义为”充满抱负的Java的进击之路”. 内容这个系列的笔记主要以Java 11/12的部分新增语言特性为主, 与君共勉! 站点直链: Ambitious Java Evolving系列之ZGC篇Ambitious Java Evolving系列之Epsilon GC篇Ambitious Java Evolving系列之Project Amber篇(一) - “生”字符串字面量Ambitious Java Evolving系列之Project Amber篇(二) - Lambda遗留问题Ambitious Java Evolving系列之Project Amber篇(三) - Data ClassAmbitious Java Evolving系列之Project Amber篇(四) - 枚举强化Ambitious Java Evolving系列之Project Amber篇(五) - 模式匹配]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>JVM And JVM Languages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ambitious Java Evolving系列之Project Amber篇(二)]]></title>
    <url>%2Fambitious-java%2Famber-legacy-lambda%2F</url>
    <content type="text"><![CDATA[为何写这个系列的笔记? 本文本来准备写Project Amber对Lambda的强化, 但目前Java对Lambda的强化, 还算”小打小闹”, 比如终于可以使用下滑线代替未使用的方法参数了. 但在某种程度上, Java中的Lambda使用还存在一定限制, 比如Lambda中同名参数隐藏问题, 比如调用重载的Functional Expression目前还存在一些问题. 下滑线与未使用的方法参数当调用一个方法或Lambda表达式时, 有时候可能并不需要所有的方法参数, 此时可以通过使用下划线代替未使用的参数. 比如下面这段代码: 12// 此处的下滑线代表并不关心Lambda中的第二个参数情况BiFunction&lt;Integer, String, Boolean&gt; pred = (value, _) -&gt; value &gt; 666; 这行做的好处有两点: 1. 减少编译器对于未使用值的类型检查, 减少编译器开销; 2. 开发友好, 无需传递所有参数. 对于上面这段代码, 如果你不想使用下划线代替未使用参数, 参考做法有以下几种: 12345678// 方法一: 传递Null值给未使用参数BiFunction&lt;Integer, String, Boolean&gt; pred = (value, null) -&gt; value &gt; 666;// 方法二: 传递空字符串值给未使用参数BiFunction&lt;Integer, String, Boolean&gt; pred = (value, "") -&gt; value &gt; 666;// 方法三: 传递任意字符串值给未使用参数BiFunction&lt;Integer, String, Boolean&gt; pred = (value, "Any String You Can Use") -&gt; value &gt; 666;// 方法四: 传递任意变量值(要求对应给定类型)给未使用参数BiFunction&lt;Integer, String, Boolean&gt; pred = (value, str) -&gt; value &gt; 666; 目前, 基于JEP 302, 可以在以下几种情况下使用下划线代替未使用的方法参数: Lambda中 方法中 Catch Handler中 使用下划线代替未使用值, Scala、Python等语言早已嵌入到语言级别, Java总算是”赶上了”. Lambda参数隐藏问题以下是一段可以正常运行的Java代码: 1234List&lt;String&gt; lst = List.of("Bonjour", "Hola", "Salut");lst.stream() .map(str -&gt; str.toUpperCase()) .forEach(System.out::println); 如果在上面代码基础上再加一个同名(与Lambda中参数同名)的str变量, 如下, 猜猜看, 会发生什么? 1234567public void methodProcessing() &#123; List&lt;String&gt; lst = List.of("Bonjour", "Hola", "Salut"); String str = "Ciao"; lst.stream() .map(str -&gt; str.toUpperCase()) .forEach(System.out::println);&#125; 很遗憾, 上面这段代码无法正常通过编译. 为什么无法通过编译? 因为map()方法中的Lambda参数str无法覆盖掉局部变量str (隐藏问题).当代码运行到map方法时, map()方法中的Lambda参数str相当于重定义变量str, 自然报错, 无法正常通过编译. 对于Scala而言, 并不存在这种问题. 如 12345678def someMethod(): Unit = &#123; val lst = List("Bonjour", "Hola", "Salut") val str = "Ciao" lst.map &#123; str =&gt; str.toUpperCase() &#125; // 或者直接 foreach println, 无需点号 // 写成下面这种形式, 是为了更好地体现Scala类型推导的强大 .foreach &#123; str =&gt; println(str) &#125;&#125; 1234scala&gt; someMethod()BONJOURHOLASALUT 得益于Scala强大的类型推导能力, Scala并不会有类似于Java中的Lambda参数隐藏问题. 函数表达式歧义问题首先来看段Java代码: 12345678910111213141516interface Hiking() &#123; boolean hikingOrNot(String conditions);&#125;interface Diver &#123; String dive(double depth);&#125;Class SportsTest &#123; // 定义重载方法 static void evalueate(Hiking hiking) &#123; System.out.println("Start Hiking"); &#125; static void evalueate(Diver diver) &#123; System.out.println("Start Diving"); &#125;&#125; 现在调用SportsTest中的重载方法, 如下: 12345class RunningTest &#123; public static void main(String[] args) &#123; SportsTest.evaluate(d -&gt; false); &#125;&#125; 上面这段代码不能正常通过编译, 主要原因在于上面的Lambda参数d没有指定输入参数的类型, 这样一来的话d既可以是String类型(Diver接口中dive方法) 也可以是boolean类型(Hiking接口中hikingOrNot方法), 此时模棱两可, 编译器无法判断, 只能拒绝编译. 解决方式: 显式地为Lambda参数加上合适的类型, 如下: 12345class RunningTest &#123; public static void main(String[] args) &#123; SportsTest.evaluate((String d) -&gt; false); &#125;&#125; 假如重构上面这段代码, 参考如下: 123456789101112131415interface Hiking &#123; boolean hikingOrNot(double miles);&#125;interface Diver &#123; String dive(double depth);&#125;Class SportsTest &#123; static void evalueate(Hiking hiking) &#123; System.out.println("Start Hiking"); &#125; static void evalueate(Diver diver) &#123; System.out.println("Start Diving"); &#125;&#125; 现在, 猜猜看下面这段代码, 能否正常通过编译: 12SportsTest.evaluate(d -&gt; false);SportsTest.evaluate((double d) -&gt; false); 很不幸, 上面这两行代码均无法正常通过编译, 主要原因在于编译器无法判断到底调用的是哪个重载方法(evaluate()), 因为此时Diver接口中的dive()方法与接口Hiking中的hikingOrNot()方法均接受同一类型(double)参数. 编译器此时很懵逼, 只能”罢工”. 可能你也很疑惑, Diver接口中的dive()方法与接口Hiking中的hikingOrNot()方法, 明明它们的返回类型不同啊!!! 为何编译器不能做出判断??? 请重新回顾下重载的定义: 同一个类中同名方法可以有不同的参数类型、参数个数或者参数个数与参数类型均不同. 方法重载与返回类型, 没有多大关系, 对不? 同样容易产生歧义的还有传递方法引用问题. 比如下面这段代码: 1234567891011// 无法正常通过编译, 编译器无法判定到底是引用哪个重载方法callSomeMethod(Credits::check);class Credits &#123; static boolean check(double number) &#123; return (number &lt; 66.6); &#125; static boolean check(String conditions) &#123; return (lap.equalsIgnoreCase("Some Filters")); &#125;&#125;]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>JVM And JVM Languages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ambitious Java Evolving系列之Project Amber篇(三)]]></title>
    <url>%2Fambitious-java%2Famber-data-class%2F</url>
    <content type="text"><![CDATA[为何写这个系列的笔记? Project Amber为进一步强化Java, 新引入了record关键字以便更好地支持Data Class. 什么是Data Class? 对于广大Java攻城狮而言, 这个概念既陌生又熟悉, 熟悉的是POJO(Plain Old Java Object), 陌生的是新引入的以record关键字为代表的Data Class. POJO, 可以视为Java最早版本的Data Class, 简单来说, 一个POJO封装了一系列数据, 但没有其它额外的行为来更改状态. POJO通常包含类成员、类构造器、getter/setter, 以及重写Object类中一些方法(如toString(), hashCode(), equals()等). Java POJO, 让人又爱又恨. 爱它是因为简单的一个类, 你需要定义好Fields, 类构造器, 一堆的getter和setter, 以及重写Object中一些方法(如toString(), hashCode(), equals()等), 然后你的代码瞬间过百行, 很有成就感, 有木有? 恨它是因为, 拜托, 你不过定义了一个类而言, 活儿没干完. 你写是轻松了(比如IDE简单右键几下搞定POJO), 但你让读的人怎么想? 你让后期维护你代码的人开心吗? Java冗余的语法, 有一半是POJO的功劳. Project Amber新引入的Data Class, 在一定程度上了简化了Java代码, 有助于提高代码的可读性及后期的可维护性. Scala有Case Class, 甚至Python也推出了Data Class, Kotlin也有Data Class, 现在Java终于”补上了”. 比如Scala中定义一个Case Class, 可以这样写:123456// Scala编译器会默认为该Case Class生成// `copy()`、`equals()`、`hashCode()`、`toString()`四个方法// 当然这些方法也可重写case class People(name: String, age: Int, gender: String) &#123; // 重写方法或定义其它方法或相关变量等&#125; 语法使用record关键字, 可以很简单的定义一个Data Class: 12345678910// 很简洁, 对吧record People(String name, int age, String gender) &#123; // 1. 除了上面 `name`, `age`, `gender` 外, // Data Class还可以在里面(此处)添加其它变量或字段 // 2. 或者定义其它方法 // 3. 或者实现自己的构造器, 而非编译器默认生成的构造器 // 4. 或者重写`Object`中方法, 如`equals()`,`hashCode()`及`toString()`等 // 而非Java编译默认生成的方法 // 5. 或者像现在这样, 一行Data Class代码, 仅使用默认实现&#125; 运行上面这段代码时, Java编译器会为该Data Class自动生成默认的Object方法(如equals(),hashCode()及toString()等). 上面这段代码会被Java编译器转换成以下源码: 12345678910111213final class People extends java.lang.DataClass &#123; final String name; final int age; final String gender; public People(String name, int age, String gender) &#123; this.name = name; this.age = age; this.gender = gender &#125; // `equals()`,`hashCode()`及`toString()` 方法实现略 // getters方法略&#125; Data Class可以定义为抽象类, 也可定义为非抽象类, 如果定义为抽象类, 生成的构造器为Protected. 继承规则目前, Java对于Data Class的继承规则, 参考如下: 非抽象(或抽象)的Data Class可继承其它抽象的Data Class 一个抽象(或非抽象)的Data Class可实现任意接口 目前, 以下继承规则是非法的: Data Class可继承常规类 常规类可继承Data Class 一个Data Class可继承另一非抽象的Data Class Data Class继承另一抽象Data Class, 示例代码参考如下: 12abstract record Animal(String name, String family);record Tiger(String name, String family, String description) extends Animal(name, family); Data Class实现一接口, 示例代码参考如下: 1234567891011interface Howl &#123; abstract void howl();&#125;record Wolf(String name, String family, String description) extends Animal(name, family) implements Howl &#123; public void howl() &#123; System.out.println("Wolf Howl !"); &#125;&#125;; 使用Data Class可用于模式匹配, 如: 123456789101112interface Garment &#123;&#125; record Button(float radius, Color color); record Shirt(Button button, double price); record Trousers(float length, Button button, double price); record Cap(...) switch (garment) &#123; // 对`Button` 展开, 进行模式匹配 case Shirt(Button(float f1, Color c2), Color c3): ... case Trousers(float f1, Button(float f2, Color c3), double a4): ... .... &#125; 上面这段代码, 使用switch语句进行模式匹配时, 有些字段也可不展开, 如: 12345switch (garment) &#123; case Shirt(Button b1, Color c2): ... case Trousers(float f1, Button b2, double d3): ... .... &#125; 目前, 对于Data Class设计成可变(Mutable)的还是不可变(Immutable)的, 还存在争议. 若Data Class设计成不可变类型, 有助于并发/并行开发; 可变的Data Class适合频繁更新的业务场景. 由于现阶段Data Class还没有设计成不可变类型, 所以在多线程环境下, 须注意线程安全问题.]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>JVM And JVM Languages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ambitious Java Evolving系列之Project Amber篇(五)]]></title>
    <url>%2Fambitious-java%2Famber-pattern-matching%2F</url>
    <content type="text"><![CDATA[为何写这个系列的笔记? 模式匹配在函数式语言中很常见, 比如Scala, Haskell, OCaml, Erlang等 (有关模式匹配相关概念, 本节将不多作介绍). 目前Java语言中类型系统并不完美. 比如在面临快速业务迭代时, 由于Java语言本身的一些冗余特性, Java类型检测有时会增加复杂性, 如将原本O(1)的复杂性活活的变成了O(n). 比如下面这段代码 12345678910111213141516Object object = new SomeObject();// 类型检测, 判定 `object` 变量类型if (object instanceof SomeObject) &#123; // Do Something Here, Then System.out.println(((SomeObject) object).callSomeMethod()); // 注意上面 `println()` 方法中的主逻辑, 主要有两步: // 1. 强制类型转换 // 2. 对象实例解构, 调用某个方法并获取某个值&#125;class SomeObject &#123; // Define Some Fields Here public double callSomeMethod() &#123; // Place Your Logic Here &#125;&#125; 上面这段代码还算简单, 但也体现出了Java语言本身的冗余特性. 比如上面这段代码, 主逻辑主要有三步: 首先进行类型检测, 判定变量类型是否为目标类型 然后对引用变量进行强制类型转换 最后对实例进行解构, 调用某个方法抽取某个值 作为Java程序员, 或许你早已习以为常, 但是如果你的业务代码长这样 1234567891011121314151617181920public void specificProcessingLogic(Object object) &#123; if (object instanceof ObjectA) &#123; // Do Something Here, Then System.out.println(((ObjectA) object).callMethodA()); &#125; else if (object instanceof ObjectB) &#123; // Do Something Here, Then System.out.println(((ObjectB) object).callMethodB()); &#125; else if (object instanceof ObjectC) &#123; // Do Something Here, Then System.out.println(((ObjectC) object).callMethodC()); &#125; else if (object instanceof ObjectN) &#123; // 类似的逻辑还很长 ...... &#125;&#125;class ObjectA &#123; /* Place Your Logic Here */ &#125;class ObjectB &#123; /* Place Your Logic Here */ &#125;class ObjectC &#123; /* Place Your Logic Here */ &#125;// ...... 类似的逻辑还很长class ObjectN &#123; /* Place Your Logic Here */ &#125; 还没什么感觉? 好, 现在回到问题的本质, 不过是一个类型匹配的问题, 由于反复的强制类型转换、实例解构, 原本底层的复杂性不过O(1), 而上面这段Java代码, 却活生生的变成了O(n). Java很强大, 但有些语言特性也让人抓狂. Project Amber中强化了Java语言对模式匹配特性支持. 换句话说, 上面这段代码, 使用模式匹配可以变成这样 1234567891011121314public void specificProcessingLogic(Object object) &#123; if (object matches ObjectA a) &#123; // Do Something Here System.out.println(a.callMethodA()); &#125; else if (object matches ObjectB b) &#123; // Do Something Here, Then System.out.println(b.callMethodB()); &#125; else if (object matches ObjectC c) &#123; // Do Something Here, Then System.out.println(c.callMethodC()); &#125; else if (object matches ObjectN n) &#123; // 类似的逻辑还有, 略 ...... &#125;&#125; 代码中的matches为新引入的关键字, matches前连匹配对象(如代码中的object), 后接目标类型对象(如代码中ObjectA a). 上面这段代码完全移除了显式的强制类型转换问题, 优雅而高效. 当然, 对于Java而言, 模式匹配常见于switch语句中.]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>JVM And JVM Languages</tag>
      </tags>
  </entry>
</search>
